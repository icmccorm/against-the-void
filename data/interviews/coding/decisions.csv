Number,Reference,Name,Text Content,Document,Codes,Number of Codes,Comment,Start position,End position,Extent,Creator,Creation Date,Modifier,Modification Date
1:1,¶ 3,,"It's, I think the main motivation is that it puts together the control. Maybe control is not the correct word, but you get the idea. The power, I would say, you have with C++ and speed characteristics and things like that with the ease of use of higher level languages.",Interview P1,Rust Performs Well,1,,3,3,1,Author 1,8/8/23,Author 1,1/16/24
1:2,¶ 7,,I contributed to a few Rust image decoders where the performance of Rust is pretty much mandatory.,Interview P1,Data Processing & Serialization,1,,7,7,1,Author 1,8/8/23,Author 1,1/16/24
1:3,¶ 7,, I contributed to a few Rust image decoders where the performance of Rust is pretty much mandatory. ,Interview P1,Rust Performs Well,1,,7,7,1,Author 1,8/8/23,Author 1,1/16/24
1:4,¶ 7,,"Basically, a very small operating system that has a purpose to download the image of an operating system, write it on the disk, and then reboot to that machine. It's mostly related to [name]. And it uses the UEFI interfaces, so it's pretty low level.",Interview P1,Operating & Embedded Systems,1,,7,7,1,Author 1,8/8/23,Author 1,1/16/24
1:5,¶ 15,,"And it's definitely like the whole ecosystem around the nostd is miles ahead of anything else that you have in any other language. It's, or at least any other language I work with is, if you wanted to use C++ in an embedded system, you don't have an option. It's like writing C with classes. You don't have the standard library, you have nothing. In Rust, there is an amazing number of crates that you can use without any support whatsoever for embedded in an embedded system without needing an allocator or with your own custom allocator or with other, more or less, with setups.",Interview P1,Feature Disparity,1,,15,15,1,Author 1,8/8/23,Author 1,1/16/24
1:6,¶ 11,," And the last thing, I think, is as we have some [name]-related tooling that evaluates a problem and generates inputs and does all of that stuff as a distributed system that is written in Rust and sometimes contribute to that, those, I think, are the biggest projects. ",Interview P1,Networking & Distributed Systems,1,,11,11,1,Author 1,8/8/23,Author 1,1/16/24
1:7,¶ 11,,"And the last one, oh, yeah, I actually wrote last week a small server to ask people to compare the difficulties of two problems and just produce a ranking of which problem is hardest and which problem is easiest.",Interview P1,Personal Tools & Toy Projects,1,,11,11,1,Author 1,8/8/23,Author 1,1/16/24
1:8,¶ 19,,And you could write it in C++ if you liked pain.,Interview P1,C++ is Difficult,1,,19,19,1,Author 1,8/8/23,Author 1,1/16/24
1:9,¶ 35,,"One was to do the equivalent of system calls in a UEFI system. So it's, guess, FFI. Yeah, I guess it's FFI with the UEFI runtime. ",Interview P1,System Calls,1,,35,35,1,Author 1,8/8/23,Author 1,1/16/24
1:10,¶ 39,,"But that was basically for working around the type system in a situation in which I knew that it couldn't possibly, you know, the guarantees that were required and satisfied wouldn't apply.",Interview P1,No Other Choice,1,,39,39,1,Author 1,8/8/23,Author 1,1/16/24
1:11,¶ 47,,"Yeah, yeah, I mean, I did that. It was, it is not a sound implementation of send or sync in a generic environment, but in an environment in which there is only one thread sound by definition because, you know, if there is only one thread, every single implementation of send and sync are sound because they have effectively no information.",Interview P1,Contract or Invariant,1,,47,47,1,Author 1,8/8/23,Author 1,1/16/24
1:12,¶ 63,,"No, not at all. I mean, there are already some wrapper functions written around, but, and I use those where I could. In some cases, I couldn't. In some cases, I even just contributed the functions to the upstream implementation, I think.",Interview P1,No Other Choice,1,,63,63,1,Author 1,8/8/23,Author 1,1/16/24
1:13,¶ 83,,"I mean, if I had been aware of my wrappers not being a sound, then I would have tried to fix it.",Interview P1,"""Safe"" API",1,,83,83,1,Author 1,8/8/23,Author 1,1/16/24
1:14,¶ 103,,Those were effectively an implementation of low-level image processing functions. So either discreet design transfer or color conversions. In integer arithmetic and using SIMD operations.,Interview P1,SIMD Intrinsics,1,,103,103,1,Author 1,8/8/23,Author 1,1/16/24
1:15,¶ 147,,"The reason why they are unsafe, even if they're just, you know, an addition, is because if you run this on a CPU that doesn't contain, doesn't have ADX instructions, anything could happen.",Interview P1,No Other Choice,1,,147,147,1,Author 1,8/8/23,Author 1,1/16/24
1:16,¶ 159,,"Gather and scatter are different, because gather and scatter just take, you know, for like, I don't know, let's say for indices and for values. So they take four indices and they load four values from memory from those four addresses, or the opposite and like, take the values and write them to memory into those four addresses, and that's not safe. Like, like, like, you can't just bounds check in the beginning and say, well, let's just a slice access. No, the access that you do is not contiguous. So that I suspect would be quite hard to make safe. Or at least I can’t think of a reasonable way to make a safe wrapper around it. At least not a simple way to make a safe wrapper around it. If that makes sense.",Interview P1,Difficult to Encapsulate,1,,159,159,1,Author 1,8/8/23,Author 1,1/16/24
1:17,¶ 163,,"Although even with targets feature one by one, you still need them safe once to effectively say, okay, let me check that I have this instruction sets and then let me call the function that uses it.",Interview P1,No Other Choice,1,,163,163,1,Author 1,8/8/23,Author 1,1/16/24
1:18,¶ 163,,"And, you know, I am pretty sure you can write it to a macro of some kind that just generates this code for you and that contains all the unsafe for that for that logic, which is not super complicated logic, right? ",Interview P1,Macros,1,,163,163,1,Author 1,8/8/23,Author 1,1/16/24
1:19,¶ 171,,"This was mostly in C++ to be fair, but honestly, when you write intrinsics, it doesn't make that much of a difference if you're writing in C++, C, or Rust. It's like the intrinsics are the same in all the languages and the pitfalls are all the same.",Interview P1,Shared Experiences,1,,171,171,1,Author 1,8/8/23,Author 1,1/16/24
1:20,¶ 216,,"I mean, when you make a wrapper API, then you know, you document it, you make a wrapper around it, maybe you decide not to expose some features that are just broken everywhere anyway, and things like that. Or, you know, maybe expose it, but you just put the comment on it and say, this is broken on every single system I tried it on, so please don't use it.",Interview P1,Documented Contract or Invariant,1,,216,216,1,Author 1,8/8/23,Author 1,1/16/24
1:21,¶ 216,,"I was handling, you know, buffers and slices and checking that the length would be correct and everything. And, you know, I did that by adding some set of asserts at the beginning of the function just to check that everything would be fine",Interview P1,Runtime Assertion,1,,216,216,1,Author 1,8/8/23,Author 1,1/16/24
1:22,¶ 216,," I mean, when you make a wrapper API, then you know, you document it, you make a wrapper around it, maybe you decide not to expose some features that are just broken everywhere anyway, and things like that. Or, you know, maybe expose it, but you just put the comment on it and say, this is broken on every single system I tried it on, so please don't use it. But, you know, there is no specific reason why this should be intrinsic to Rust, you know. The exact same thing could happen if one were writing a C++ library, it's just that the culture tends to be a bit different.",Interview P1,Shared Experiences,1,,216,216,1,Author 1,8/8/23,Author 1,1/16/24
1:23,¶ 220,,"And I think it also makes, you know, is indicative of the culture of make sure it's correct before anything else that tends to be in Rust, uh, Rust land, let's say.",Interview P1,Preference for Safety,1,,220,220,1,Author 1,8/8/23,Author 1,1/16/24
1:24,¶ 236,,"So, you know, it's mostly Oh, yeah, pass a buffer in a length and I will fill the data in it and or the other way around. And so that's like pretty memory trivial, pretty trivial as far as memory models are so",Interview P1,Simple FFI,1,,236,236,1,Author 1,8/8/23,Author 1,1/16/24
1:25,¶ 240,,"Was that there was one specific instruction. I don't remember which one that was intrinsic that had the order of arguments swapped in some version of rust. You know, when they were still nightly so. Before I want to stable.",Interview P1,"FFI & Binding Bug, Mismatched Bindings or Declarations",2,,240,240,1,Author 1,8/8/23,Author 1,1/16/24
1:26,¶ 256 – 257,,"Yeah, I mean, I don't know, I think it would be really good to be able to have an embedded version of address sanitizer, but never, I didn't need to myself.

",Interview P1,Wants Solution,1,,256,257,2,Author 1,8/8/23,Author 1,1/16/24
1:27,¶ 262,,"Yeah. I suspect that that could be very useful. On the other hand, like there is this tendency in Rust to keep your uses of unsafe as local as possible.",Interview P1,Preference for Safety,1,,262,262,1,Author 1,8/8/23,Author 1,1/16/24
1:28,¶ 260,,"Yes, maybe not an address sanitizer. Maybe a unique, uh, pointer sanitizer. But whatever, you know, some sanitizer.
",Interview P1,Wants Solution,1,,260,260,1,Author 1,8/8/23,Author 1,1/16/24
1:29,¶ 19,,"I have to say specifically, one thing I really appreciated is how easy it is to add dependencies that really helped a lot.",Interview P1,Rust Has Great Tooling,1,,19,19,1,Author 1,8/8/23,Author 1,1/16/24
1:30,¶ 27,,"Well, maybe. I may also be, you know, that I am a bit fanboyish and say, oh, yeah, Rust is the best.",Interview P1,Fanboyish,1,,27,27,1,Author 1,8/8/23,Author 1,1/16/24
1:31,¶ 31,,"As far as I know, at least for my contributions, everything else is completely unsafe free. ",Interview P1,No Unsafe,1,,31,31,1,Author 1,8/8/23,Author 1,1/16/24
1:32,¶ 63,,"Honestly, all the problems I had were with the fact that the UEFI implementations don't actually follow the UEFI specification, but that's a problem that is orthogonal to Rust.",Interview P1,"Logical Error, Requirements Bug",2,,63,63,1,Author 1,8/8/23,Author 1,1/16/24
1:33,¶ 75,,"Well, that's at least what I tried to do. Now that I succeeded at doing it, that's a different question, but in theory, yes. In theory, it should be safe.
",Interview P1,"""Safe"" API",1,,75,75,1,Author 1,8/8/23,Author 1,1/16/24
1:34,¶ 71,,I never exposed an unsafe API to other users.,Interview P1,Exposing a Safe API,1,,71,71,1,Author 1,8/8/23,Author 1,1/16/24
1:35,¶ 159,,And I guess you need to rely on the compiler to elide the bounds checks at some point,Interview P1,Compiler Eliding Bounds Checks,1,,159,159,1,Author 1,8/8/23,Author 1,1/16/24
1:36,¶ 248,,Just compile it with the memory sanitizer and the address sanitizer and hope that it works.,Interview P1,Dynamic Analysis Safety Net,1,,248,248,1,Author 1,8/8/23,Author 1,1/16/24
1:37,¶ 248,,"Honestly, for what I've been doing the same tools that work for C++ also work for us.",Interview P1,Shared Experiences,1,,248,248,1,Author 1,8/8/23,Author 1,1/16/24
1:38,¶ 216,,"The exact same thing could happen if one were writing a C++ library, it's just that the culture tends to be a bit different.",Interview P1,Preference for Safety,1,,216,216,1,Author 1,9/2/23,Author 1,1/16/24
1:39,¶ 266,,"You know, just write one unsafe module that wraps everything around. Which is, I think a development practice that, which reduces the need for such sanitizers.",Interview P1,Preference for Safety,1,,266,266,1,Author 1,9/3/23,Author 1,1/16/24
1:40,¶ 19,,"Of course, the fact that it's fast, there is actually an untrivial amount of computation that goes on in that program. And for example, that disqualifies Python because I want the computation to happen in parallel to the normal execution of the server. And you can't do that in Python because global interpreter lock. And you could write it in C++ if you liked pain. And then I guess it is JavaScript, but it's not my favorite language. So, you know.",Interview P1,Rust Performs Well,1,,19,19,1,Author 1,9/5/23,Author 1,1/16/24
1:41,¶ 35,,"As far as I can tell, there is no async executor for, you know, probably there are reasons for that. And I wouldn't have needed unsafe if not for the fact that Rust, of course, tries to be thread safe, but I didn't have locks in, like there is no lock implementation that knows the environment. And for that matter, there aren't threads either. There is only one thread. So basically I mostly used unsafe to tell the compiler, yes, this implements async and it doesn't, but there is also only one thread. So it's okay, you know?",Interview P1,No Other Choice,1,,35,35,1,Author 1,9/5/23,Author 1,1/16/24
1:42,¶ 55,,"Called the function, something happens, the function returns data is no longer used by the UEFI run time, nothing. There is no complex lifetimes involved, effectively.",Interview P1,Simple FFI,1,,55,55,1,Author 1,9/5/23,Author 1,1/16/24
1:43,¶ 87,,"Otherwise, I wouldn't have put unsafe on them. Of course, there are always ways you may not be aware of it, but I am fairly sure it should be fine.",Interview P1,"""Safe"" API",1,,87,87,1,Author 1,9/5/23,Author 1,1/16/24
1:44,¶ 155,,"So what the Rust community is working on is this thing called target feature 1.1, which allows, which makes functions with target feature safe to call from other functions with the same target feature.",Interview P1,Shifting Ground,1,,155,155,1,Author 1,9/5/23,Author 1,1/16/24
1:45,¶ 167,,"I don't actually use them. I try to avoid the gather and scatter as much as I can because they're other than, you know, being inherently dangerous to use. ",Interview P1,Preference for Safety,1,,167,167,1,Author 1,9/5/23,Author 1,1/16/24
1:46,¶ 179,,"Basically, I was using an existing library, but it didn't have some of the functions that I needed.",Interview P1,No Other Choice,1,,179,179,1,Author 1,9/5/23,Author 1,1/16/24
1:47,¶ 192,,Especially because you just need to extract them from the UEFI specification.,Interview P1,Generation VS Validation,1,,192,192,1,Author 1,9/5/23,Author 1,1/16/24
1:48,¶ 200,,"No, because implementers don't actually follow the specification that much.
",Interview P1,"Logical Error, Requirements Bug",2,,200,200,1,Author 1,9/5/23,Author 1,1/16/24
1:49,¶ 7,,"And you certainly would, in general, appreciate not risking segmentation faults and other security issues.",Interview P1,Memory Safety,1,,7,7,1,Author 1,9/5/23,Author 1,1/16/24
1:50,¶ 216,,"And one thing that somewhat surprised me, like positively, is that the reviewer said, well, this check could be wrong if there is an overflow here. Or some, you know, other similar, like this addition could overflow here, so we should replace this function with a check add instead of a normal addition. Which is completely correct, of course, and I should have thought of that, but the fact that, you know, that the reviewer codes this and noticed this and decided to make sure that this was fine was very welcome.",Interview P1,"Engaging with the Rust Community, Preference for Safety",2,,216,216,1,Author 1,9/5/23,Author 1,1/16/24
1:51,¶ 248,,"Nothing what I did, but I also, you know, never touched anything that stood pointers, for example, or references like, you know, if I had to work on a slice of references to something and had to ensure that I wasn't violating the borrow check that the uniqueness constraints. Then my answer may be made different, different. But in terms of what I've been doing so far, all pretty simple.",Interview P1,It's not a problem,1,,248,248,1,Author 1,9/5/23,Author 1,1/16/24
1:52,¶ 216,," I guess, there is the, I guess, this cultural thing in Rust libraries that they don't try to hide the complexity from the user. This is a bit more of, this is a meta-observation that I made about Rust developers in general. So I see this tendency, you know, that there are languages in which you try to make the simplest possible API and that has the result, then, you know, there are some complicated aspects that the user then doesn't think about and then they come to bite him or her at some point. Rust has a tendency to, you know, make the API as complicated as it needs to be to fully represent what is actually happening behind the scenes. ",Interview P1,When to Encapsulate?,1,,216,216,1,Author 1,9/14/23,Author 1,1/16/24
2:1,¶ 7,,"You have to just know certain things about how this other part of the program is written and I think over time that's gotten a little bit better for C++, but a language where there are the, I don't really have much against C++ having a lot of dialects that get used in different large code bases, especially like each large code base has its own special dialect usually with its own internal library. That's fine, a lot of people do that, a lot of Rust projects that work on do that, but pair that with the fact that understanding what your code is doing is very very important for safety, that becomes much trickier. I just never felt that comfortable working on large C++ code bases.",Interview P2,C++ is Difficult,1,,7,7,1,Author 1,8/8/23,Author 1,1/16/24
2:2,¶ 7,, I worked on [browser] as well for a while when I was working on the Rust integration and wrote quite a bit of C++ there,Interview P2,Web Browser Development,1,,7,7,1,Author 1,8/8/23,Author 1,1/16/24
2:3,¶ 11,,"What happened was like the Rust side was still easy, but the C++ side, every turn there were problems due to things I had not realized yet and some of this was because I was not an experienced person in that code base. I knew C++ but it wasn't like I'd been writing [browser] code for five years, so some of that was that and over time I've picked picked up on that and some of that was just, it would have been, anyone else would have taken that amount of time because some of this was memory safety, some of this was thread safety. What we were doing was definitely out of the bounds of what people expected that code to do and since there were no guardrails around it, you kind of just had to do the thing and then see what broke, which was not great because it's impossible to kind of understand for something so deeply integrated in the code base and understand all the effects it might have. ",Interview P2,C++ is Difficult,1,,11,11,1,Author 1,8/8/23,Author 1,1/16/24
2:4,¶ 15,,"The [name] browser tried to be less monolithic, but they're still rather monolithic and there are no clean components. You can't just go, oh yeah, that's the style system. It's all integrated with everything else. There's no nice public API. They're all just meshed like that. The way you do this kind of integration is you find a roughly okay part to tear. Then you get this jagged tear and then you glue it together. Because of that, that makes the FFI stuff a bit complicated.",Interview P2,Difficult FFI,1,,15,15,1,Author 1,8/8/23,Author 1,1/16/24
2:5,¶ 19,,"Fortunately, there were asserts all over the place for this. So it wasn't like, we didn't have to break out thread sanitizer, but it was annoying. And what we realized through that is actually, it was a validation of a belief that a lot of people had was that this would have been impossible to do in pure C++ because you we were we had to hit this for the occasional times we had to call out to C++ from Rust and we'd hit this every now and then. But if we were only writing C++ code and we were just using all the internal C++ APIs, we would have been hitting this constantly.",Interview P2,C++ is Difficult,1,,19,19,1,Author 1,8/8/23,Author 1,1/16/24
2:6,¶ 23,,"In Rust, basically, a very efficient way of doing deserialization that involves not allocating new space for anything you deserialize, but instead, having your deserializations all be stack copies or pointers to the original data, which we use a lot in [library], the internationalization library I work on, because we want internationalization data to be loaded efficiently. And implementing that in Rust is possible. I'm not the first one to implement it in Rust, but the strategies around that, we need some amount of unsafe to do that correctly.",Interview P2,"Increase Performance, No Other Choice, Performance is Necessary",3,"For Author 1: is there a reason this has ""No Other Choice"" instead of just ""Increase Performance""?",23,23,1,Author 1,8/8/23,Author 1,1/16/24
2:7,¶ 23,,"I’ve been doing zero copy deserialization. In Rust, basically, a very efficient way of doing deserialization that involves not allocating new space for anything you deserialize, but instead, having your deserializations all be stack copies or pointers to the original data, which we use a lot in [library], the internationalization library I work on, because we want internationalization data to be loaded efficiently.",Interview P2,Data Processing & Serialization,1,,23,23,1,Author 1,8/8/23,Author 1,1/16/24
2:8,¶ 23,,"Here, mostly what I'm doing is the main library I work on is something that we want to be callable from other languages. And we're using this tool that I've built that lets you build those APIs using kind of like a shared interface in between. ",Interview P2,Directionality,1,,23,23,1,Author 1,8/8/23,Author 1,1/16/24
2:9,¶ 37,,"But when you write your backend, you kind of figure out these Rust APIs, how would they be idiomatic? How would they be idiomatic in this language? Like, oh, yes, you know, a struct in Rust is a class in JavaScript or C++. A result in Rust is an exception in JavaScript, but maybe it's still a result type in C++ because people don't like exceptions in C++. Like, you figure out where you're landing on all of this and you do this translation so that another library can call this Rust API in a roughly idiomatic looking way.",Interview P2,Idiomatic FFI Encapsulation,1,,37,37,1,Author 1,8/8/23,Author 1,3/18/24
2:10,¶ 45,,"But for I think there has been controversy about this in the Rust community in the past, because for example, CXX, the tool CXX does not actually mark everything as unsafe. Because it trusts you when you write a C++ header, that that header is correct. And there's a perspective that you're calling into foreign code, that it can do anything. So it's unsafe. But the other perspective is that then you get unsafe absolutely everywhere in your code base, and it stops being useful.",Interview P2,"CXX, Shifting Ground",2,,45,45,1,Author 1,8/8/23,Author 1,3/18/24
2:11,¶ 45,,"You should not do the trust me, I'm right, if you're manually writing the bindings. But if you go to the tool reading the C++, gaining the and understanding what the C++ is trying to do from the headers, it's fine to do that. ",Interview P2,Generation VS Validation,1,,45,45,1,Author 1,8/8/23,Author 1,3/18/24
2:12,¶ 45,,"And furthermore, I think the point is, if you are linking to a different language, you have already put a cap in the level of safety you're gonna get. I spent like a different unsafe language, if you're linking to a different unsafe language, you've got a cap on the amount of safety you're gonna get. You already have a giant part of your code base that's going, trust me, I know how to do this.",Interview P2,Difficult FFI,1,,45,45,1,Author 1,8/8/23,Author 1,3/18/24
2:13,¶ 45,,"And that's kind of the position here is, you can put preconditions post conditions, we do this sometimes. Like, for example, we do we don't actually, right now, assume anyone is giving us valid UTF-8, we validate it if you give us a string. Most of our APIs take very small strings, so it doesn't matter. There's some APIs that take large ones, but they also support unvalidated, unvalidated UTF-8 directly and things like that. So even though on the Rust side, our APIs take UTF-8 strings, we validate them before everyone over FFI gives us basically bytes. That's one way we do preconditions and post conditions, we do those manually.",Interview P2,Runtime Assertion,1,,45,45,1,Author 1,8/8/23,Author 1,3/18/24
2:14,¶ 49,,"So yeah, so for unsafe code, unsafe library code, pre and post conditions work quite often quite quite well, sometimes, not for everything that they work often. But for unsafe, FFI code, they really don't because to do this kind of thing, you've got to maintain a bunch of state that you're not going to be maintaining on the other side.",Interview P2,Difficult to Encapsulate,1,,49,49,1,Author 1,8/8/23,Author 1,3/18/24
2:15,¶ 53,,"You really don't want to send Rust's structs over FFI by move. You really don't want to return a box over FFI because there are some ABI concerns around things like that. In particular, I think MSVC gets very annoyed about that. And the bindings change across different platforms and stuff like that. It basically is a mess. So you don't want to do that. So you want to just turn it into a raw pointer first and return it.",Interview P2,Simple FFI,1,,53,53,1,Author 1,8/8/23,Author 1,3/18/24
2:16,¶ 53,,"The other thing is if you are implementing some low level unsafe thing and you're using Box or Vec or Rc as a kind of like a spring off point, you want them to do their thing. You want them to do the allocation for you or whatever. And then you want to do some of your own things on it. And you want to store it as your own thing. Then sometimes it's useful converting to a raw pointer.",Interview P2,Allocation in Rust,1,,53,53,1,Author 1,8/8/23,Author 1,3/18/24
2:17,¶ 57,,"So the other half of that logic exists somewhere. It might if you might forget to hook it up. That has happened. I recent last year, I think the last time I had this problem was last year, I refactored some of the zero copy deserialization code to be slightly different. And I forgot to write a destructor. So it ended up not. It ended up like having a memory leak. But it was it was kind of like, that was also just easily caught and easily found.",Interview P2,"Memory Leak, Memory Leaks",2,,57,57,1,Author 1,8/8/23,Author 1,3/18/24
2:18,¶ 57,,"But yeah, I, for [browser] and stuff like that, we have used tools like Valgrind and whatever to do this. In general, I haven't found this to be that big an issue. Leaks are possible there. You can get them by accident. But I think it's not as likely to have a leak.",Interview P2,Memory Leaks Aren't an Issue,1,,57,57,1,Author 1,8/8/23,Author 1,3/18/24
2:19,¶ 61,,"So I think that's one thing is that if you FFI tools should not have to read the entire code base on the other side, they should read a subset that you clearly define.",Interview P2,Generate Bindings From a Subset,1,,61,61,1,Author 1,8/8/23,Author 1,3/18/24
2:20,¶ 69,,"And the end result of this is if you're doing FFI, the only things you should pass by value are copy types. Or the only things you should pass by value are primitives. And you can pass structs by value sometimes.",Interview P2,Simple FFI,1,,69,69,1,Author 1,8/8/23,Author 1,3/18/24
2:21,¶ 73,," Honestly, one thing that I remember, the C and C++ model of memory is not that different. It's just that you have to keep track of it in your head. And I remember when we were doing the [browser] stuff, we had a bunch of experienced C++ programmers start to learn Rust when we were doing this. And I was helping them do that and kind of also very interested to know where their challenges were. And the thing that I remembered was they did not have problems with what was widely known as the most complicated part of Rust. They were like, yeah, the borrow, that's fine. And their reasoning was this is how we think anyway. We're working on a large C++ code base. This is what we're doing in our head. So now it's doing it for us. Great",Interview P2,Becoming the Borrow Checker,1,,73,73,1,Author 1,8/8/23,Author 1,3/18/24
2:22,¶ 73,,But what people consider to be the complicated parts of Rust were not there. ,Interview P2,Becoming the Borrow Checker,1,,73,73,1,Author 1,8/8/23,Author 1,3/18/24
2:23,¶ 73,,"But overall, like the memory stuff is still similar, the way you deal with memory in Rust is very much inspired by the way people manually do it in C++.",Interview P2,Becoming the Borrow Checker,1,,73,73,1,Author 1,8/8/23,Author 1,3/18/24
2:24,¶ 73,,"One thing that C++, for example, has that Rust does not is it has a far finer distinction of different kinds of value types, value kinds, I forgot what they're called, like l values, x values, they're basically C++ can has a way of talking about temporaries at a type level, which is how C++ implements moves. C++ has a bunch of other things there. That gets complicated sometimes. That's Rust in Rust, you kind of just have, you do have a distinction between l values and r values are what we call places and temporaries. But that distinction is basically internal. And you need to care about it in a couple places when it comes to borrowing. But the fixes are straightforward. So it's not it's not as in your face as it is in C++, where I've often had to think about these things.",Interview P2,Feature Disparity,1,,73,73,1,Author 1,8/8/23,Author 1,3/18/24
2:25,¶ 81,,"If you're borrowing memory from C++, yeah, you just consider things like, it might be null in C++. You have to consider things like C++ might have some internal lifetime relationship that is not reflected in your API. And you can figure that out by reading the C++ and understanding or documenting it and then going to the Rust side and putting the right lifetimes there. ",Interview P2,Different FFI Memory Model,1,,81,81,1,Author 1,8/8/23,Author 1,3/18/24
2:26,¶ 85,,"There are some caveats, but if you're doing low level abstractions, a lot of what is and isn't undefined behavior in Rust hasn't been pinned down yet. And that's, I think, one of unsafe Rust's biggest problems so far is that they're still working on that, which means when you write unsafe Rust, there is kind of this mix of community best practice. Knowing what it's very unlikely that the unsafe code guidelines will break, and also just knowing where their heads at right now, knowing what's coming soon, you have to kind of be in that space, which makes it a much harder proposition. ",Interview P2,Shifting Ground,1,,85,85,1,Author 1,8/8/23,Author 1,3/18/24
2:27,¶ 85,,"And I think part of the thing is a very nice thing they've done is they have tried to define their unsafe model in terms of Miri, or in terms of something Miri can do. So even though I mentioned that there are some things it doesn't catch, these are mostly things that they have, they have decided on, but has not been implemented or have been fully implemented. But in theory, it should be able to catch.",Interview P2,Shifting Ground,1,,85,85,1,Author 1,8/8/23,Author 1,3/18/24
2:28,¶ 85,,"Clippy is just a general useful for catching things, making sure API is clean. I've heard it's like, I've gotten great feedback that it's very useful for people learning the language. It did not exist when I was learning the language.",Interview P2,Clippy for Learning Rust,1,,85,85,1,Author 1,8/8/23,Author 1,3/18/24
2:29,¶ 85,," It's also just the more experienced you get in Rust, a lot of the bugs that Clippy can catch, you also notice so you end up just having it help with your API for people new people new to Rust working on our code bases, I've definitely noticed that like Clippy is very helpful for them, because like, sometimes they come to me, they're they're like, hey, so like, I saw this error earlier. And like, I did what it told me to, but can you explain more or whatever?",Interview P2,Clippy for Learning Rust,1,,85,85,1,Author 1,8/8/23,Author 1,3/18/24
2:30,¶ 89,,"And really, the actual thing that's missing here is more human analysis than static analysis, which is, there isn't really a good way to like a clearly agreed upon way to review unsafe code.",Interview P2,Shifting Ground,1,,89,89,1,Author 1,8/8/23,Author 1,3/18/24
2:31,¶ 89,,"Like one of the rules that we're hoping to settle on is not just that your unsafe code should be documented, but your unsafe code should be documented so that people reviewing the unsafe code do not need to hold your entire code base in their head to review it, they should be able to go block by block, and maybe like, read the comments at the top of an individual file, but not have to jump around the code base to understand because they can trust, they can trust your comments. Like as to why things are unsafe, the comments say enough about the rest of the effects to know this. And then, then they have to just verify that the comments are correct, which is a much easier process.",Interview P2,Audience-Dependent Documentation,1,,89,89,1,Author 1,8/8/23,Author 1,3/18/24
2:32,¶ 17,,"There's C++ calling it to Rust. Rust calling it to C++. The call stacks get kind of mixed up, which is fine. That's what we want. But it means that sometimes we call it to C++ from the wrong thread, which is not a problem in [browser] because it was very clear in [browser] when you were on non main threads. In Rust, we were throwing threads around all the time. That was the point. So there was a lot of things where we'd have to go back and fix that.",Interview P2,"Difficult FFI, Fearless Concurrency",2,,17,17,1,Author 1,8/8/23,Author 1,1/16/24
2:33,¶ 41,,"You can't do arbitrary things in it. It will like if you start doing generics, it will yell at you. If you start doing start using really complicated types, it will yell at you. But it can do most basic things. And as long as you stick to that subset of Rust, it will generate a C API for you and the tool.",Interview P2,"Limitation of Binding Tool, Simple FFI",2,,41,41,1,Author 1,8/8/23,Author 1,3/18/24
2:34,¶ 69,," This is not that hard to achieve in Rust. You slap on repr C on that thing, and I think in C++ as well, you have some control over repr. So you can, you do that, and then it's the same.",Interview P2,Shared Experiences,1,,69,69,1,Author 1,8/8/23,Author 1,3/18/24
2:35,¶ 69,,"You can cause problems on this lunging and you platforms, but you can also like you can MSVC, like MSVC is definitely the one where I've seen more of these problems",Interview P2,MSVC,1,,69,69,1,Author 1,8/8/23,Author 1,3/18/24
2:36,¶ 69,,"And it is well within the scope of what C++ and Rust are allowed to do to differ on this. And to some extent, like C++ and Rust don't have the same constant of destructors in the first place. So when you say a type with a destructor works this way, you can't necessarily mean the same thing on the Rust side in the first place. But also it is very much like C++ has choices on how to do this and Rust has choices on how to do this. And they haven't necessarily picked the same thing. There's no standard on this. There can't be a standard on this because different languages kind of have different notions of destructors and stuff like that. So yeah, so this is a bit of a mess",Interview P2,Different FFI Memory Model,1,,69,69,1,Author 1,8/8/23,Author 1,3/18/24
2:37,¶ 81,,"Like, if you're doing complicated FFI things you are going to care about, does this does who borrows from who? Is this its own allocation? Is this a borrow? If it's a borrow, where is it from? And again, this is also how people are thinking in terms of C++, they may not they may not be using the same terminology of borrows, but they are still thinking about this pointer comes from here and needs to needs to live this long.",Interview P2,Becoming the Borrow Checker,1,,81,81,1,Author 1,8/8/23,Author 1,3/18/24
2:38,¶ 7,,"part of it is just if you're working on a large project on your own, you have to keep track of everything and what I noticed is if you're contributing to a large project, they all have their own kind of internal practices around this, which are not necessarily what everyone else does, and figuring that out and figuring out what's going on, you really just, it's almost like you're learning a new language. For C++, it's almost like you're learning a new language each time when you work on a large code base because a lot of the subtleties change and they change in ways that are not immediately obvious when you look at the code. ",Interview P2,C++ is Difficult,1,,7,7,1,Author 1,9/5/23,Author 1,1/16/24
2:39,¶ 11,,"It took me around two or three weeks and what happened was partly I had to figure out how to split it up into pieces so that the C++, so that if there was a memory safety error, I'd have a small amount of things to look at and partly it was actually chasing those down. ",Interview P2,C++ is Difficult,1,,11,11,1,Author 1,9/5/23,Author 1,1/16/24
2:40,¶ 3,,"When I started using Rust, I had touched C++ a bunch and I found that that was really nice, but also I didn't really feel comfortable doing very large things in it and Rust came along and it let me do a kind of programming that I was overall, did not have the time to get good at otherwise at the time.",Interview P2,C++ is Difficult,1,,3,3,1,Author 1,9/5/23,Author 1,1/16/24
2:41,¶ 3,,"But also I really like systems programming, I like programming where I'm really close to what the computer's doing. I like having that level of mechanical sympathy with the computer.",Interview P2,Low-Level Access,1,,3,3,1,Author 1,9/5/23,Author 1,1/16/24
2:42,¶ 15,,"there's a bunch of stuff where it was just like, yeah, to do this refactor I need to change how we use this pointer in C++. Oh, this pointer can be null. That was not clear. Stuff like that. That's a C++ problem itself where I'm making basically a pure C++ change. There's Rust involved, but the actual change I'm making is mostly a C++, can be expressed in C++ and then there's like some nuance there. ",Interview P2,Different FFI Memory Model,1,,15,15,1,Author 1,9/5/23,Author 1,1/16/24
2:43,¶ 19,,"Fortunately, there were asserts all over the place for this. So it wasn't like, we didn't have to break out thread sanitizer, but it was annoying. ",Interview P2,Runtime Assertion,1,,19,19,1,Author 1,9/5/23,Author 1,1/16/24
2:44,¶ 19,,"And it was the only reason it was even possible to parallelize was because we we could do most of it in Rust and then occasionally there'd be C++ stuff on other threads and we'd have to kind of sit down and specifically handle those cases, which was still a lot of work, but much less work than doing everything.",Interview P2,Fearless Concurrency,1,,19,19,1,Author 1,9/5/23,Author 1,1/16/24
2:45,¶ 23,,The other thing I do is,Interview P2,Engaging with the Rust Community,1,,23,23,1,Author 1,9/5/23,Author 1,1/16/24
2:46,¶ 31,," And you give it kind of a C++ or C header, and it gives you stuff so you can call from Rust. You can use it to go the other way around. It's clunky to do that, but [browser] has done that.",Interview P2,bindgen,1,,31,31,1,Author 1,9/5/23,Author 1,1/16/24
2:47,¶ 35,,"I never want to call code that's not Rust, but I want everyone to talk to me. I don't want one language to talk to me. I want everyone to be able to use me as a library.",Interview P2,Directionality,1,,35,35,1,Author 1,9/5/23,Author 1,1/16/24
2:48,¶ 35,,"There's one by Mozilla called UniFFI, where you kind of write these IDL files. And what it does is I think it generates traits on the Rust side and headers and stuff on the other, whatever other side, and you implement these traits or you plug into whatever stuff it gives you. And then from the other side, you can call it.",Interview P2,Uniffi,1,,35,35,1,Author 1,9/5/23,Author 1,1/16/24
2:49,¶ 37,,"And then there's Diplomat…which is you write these. It works similarly to CXX and where you write all of your public kind of FFI APIs go in these bridge modules. You write these bridge modules that have, you can have like types and methods and stuff. And what it does is that it generates additional Rust code using a proc macro to, so that all of the actual underlying C functions exist. And then every backend for different languages calls those same C functions.",Interview P2,Diplomat,1,,37,37,1,Author 1,9/5/23,Author 1,3/18/24
2:50,¶ 41,,And the tool does not read the C API. This tool also generates the C API. So like we are not the thing that we as humans write is not C API. The thing is we as humans write is something that looks like the Rust API just that it's somewhat restricted in what you can do.,Interview P2,"Diplomat, Generation VS Validation",2,,41,41,1,Author 1,9/5/23,Author 1,3/18/24
2:51,¶ 45,,"It is fine for the user interface, the interface between Rust and C++ to also be trust me, that like, like C++ to be able to go to Rust, trust me, I'm doing this right. Because you're already doing that all over within the C++ code base",Interview P2,C++ is Difficult,1,,45,45,1,Author 1,9/5/23,Author 1,3/18/24
2:52,¶ 45,,"But yeah, when it comes to FFI, you can do stuff like that, but there's a limit to how much you can do because you're ultimately just trusting the rest of that code base the same way people within that code base are trusting the rest of that code base.",Interview P2,Difficult FFI,1,,45,45,1,Author 1,9/5/23,Author 1,3/18/24
2:53,¶ 53,,"I think one of the entries there was UnsafeCell. If you want to use that if you're doing anything with custom interior mutability, which is rare because there are a bunch of existing good cell APIs, but I've been around long enough that not all of them existed at the time. So I've had to do this. And if you're using UnsafeCells, you have to use raw pointers. That is how that API works.",Interview P2,UnsafeCell<T>,1,,53,53,1,Author 1,9/5/23,Author 1,3/18/24
2:54,¶ 57,,"I don't think we've had that many problems around that. Or I've had, I don't really do this kind of thing. Well, okay, Diplomat does this. But in holistic code bases, I don't think I've actually had a problem there just because usually when you do that, you're handing it off to a type on the other side, FFI or whatever, where the rest of that logic is written. Like where, where, where you're turning it into like a unique pointer or something in C++.",Interview P2,It's not a problem,1,,57,57,1,Author 1,9/5/23,Author 1,3/18/24
2:55,¶ 61,,"if you're if your FFI tool is reading Rust code, it's actually not great for it to read all of the Rust code you have, you should give it a small subset of your Rust code to read and tell it to stick to that. Because what you don't want is you make some internal Rust change and then your FFI suddenly changes. You want to notice that. ",Interview P2,Generate Bindings From a Subset,1,,61,61,1,Author 1,9/5/23,Author 1,3/18/24
2:56,¶ 61,,"I've used cbindgen in the past, it is great for what [organization] wants to use it for. But it, it has a mode for where you can kind of have it just read everything. Basically, cbindgen looks at the extern C functions in your library, and it just generates everything based on that. If you use a type in that, it'll go find that type and generate something for that type. And there's a mode when cbindgen where it can do that and also chase down crates, if you can tell it, look for look for this type and other crates and stuff, it's not from here. And that when it works, it works. But when it doesn't work, it's a mess. Because cbindgen does not understand all of Rust, and it can't generate FFI for all of Rust anyway.",Interview P2,cbindgen,1,,61,61,1,Author 1,9/5/23,Author 1,3/18/24
2:57,¶ 61,,"So my general opinion is that if you're building a tool where your source of truth is Rust code, make the source of truth be very explicitly tagged Rust code, like a separate crate, or separate modules, and both CXX and diplomat do this.",Interview P2,"CXX, Diplomat, Generate Bindings From a Subset",3,,61,61,1,Author 1,9/5/23,Author 1,3/18/24
2:58,¶ 61,,"In bindgen’s case, the source of truth is instead the entire C++ code base. But worth noting about bindgen is, is very configurable. And the way everyone kind of uses it is, you point it at a C++ code base, and then you manually kind of tell it what headers are important, and which headers are not, because what you don't want is for it to generate FFI for everything you wanted to generate FFI for the things you care about, because that's faster, and also less, less chances of it trying to generate FFI for some weird messed up template thing that you don't care about in the first place. ",Interview P2,bindgen,1,,61,61,1,Author 1,9/5/23,Author 1,3/18/24
2:59,¶ 61,,"So I think I mean, I think the thing is, it's hard to some of these tools are unidirectional, some of these tools are unidirectional, the other directional and other direction and some of these tools are bidirectional. So that makes it hard to compare.",Interview P2,Directionality,1,,61,61,1,Author 1,9/5/23,Author 1,3/18/24
2:60,¶ 69,,"This is great as long as the type is being a pointer, right? When the type is being a pointer, all you care about is the memory representation being the same. But there are other ways of accessing a type across FFI. And one way is a function might return a type or accept a type as a parameter. Again, if it's a pointer, it's fine. If it's primitives, they're fine. The primitives work the same. And if they don't, you should use the primitives that do.",Interview P2,Simple FFI,1,,69,69,1,Author 1,9/5/23,Author 1,3/18/24
2:61,¶ 69,,"But the moment you start doing something that's not a primitive, then, so structs and enums and stuff like that do have additional impacts on this. And what the impact is, is that whether or not the type may be represented the same way, but when a function, when a function ABI is defined when they're like calling convention and stuff happens, whether or not a type from the parameters or return values goes in a register or on the stack or be had a pointer or whatever, those different things differ based on the kind of thing it is. So if you've got primitives on either side, they'll work the same. But if you've got a struct on one side and a struct on the other side, it's not just that it had, it's a struct, like it can be a struct, it can have the same layout. But if one of them has a destructor, and one doesn't, they may not behave the same. ",Interview P2,Difficult FFI,1,,69,69,1,Author 1,9/5/23,Author 1,3/18/24
2:62,¶ 69,," do this in Diplomat, but they only do structs without destructors.",Interview P2,Diplomat,1,,69,69,1,Author 1,9/5/23,Author 1,3/18/24
2:63,¶ 73,,"There were definitely concepts Rust had that C++ didn't have that they took time to pick up. And there are things like RefCell, for example, is not a concept C++ has. And it took a while for people to wrap their heads around that.",Interview P2,Feature Disparity,1,,73,73,1,Author 1,9/5/23,Author 1,3/18/24
2:64,¶ 73,,"And overall, the memory model, not the memory model, the way people reason about memory is very similar in the two languages. Except Rust does it for you by default.",Interview P2,Becoming the Borrow Checker,1,,73,73,1,Author 1,9/5/23,Author 1,3/18/24
2:65,¶ 85,,"Yeah, so Miri is great for looking for testing on safe code. I actually haven't had the time to write Miri tests for the zero copy deserialization things I've written. I mean, we have tests and we can run them under Miri and they pass but we haven't put them in CI yet because I want to write some more tests and stuff and I just haven't gotten around to that. ",Interview P2,Running tests through Miri,1,,85,85,1,Author 1,9/5/23,Author 1,3/18/24
2:66,¶ 89,,"The problem with unsafe is when you're when you're statically checking unsafe, you have already been you've already stepped out of the bounds of rust, or normal rust, you're already in a situation where you're doing something weird. It already becomes harder to glean intent from code from broken code. ",Interview P2,Unsafe is Difficult to Understand,1,,89,89,1,Author 1,9/5/23,Author 1,3/18/24
2:67,¶ 93,,a lot of progress here is just blocked on the unsafe code guidelines finishing. ,Interview P2,Shifting Ground,1,,93,93,1,Author 1,9/5/23,Author 1,3/18/24
3:1,¶ 3,,"But it just seemed like constantly the language was evolving in a direction that made it more complicated, more confusing. There are a thousand ways to do the same thing. And when Rust showed up, it seemed like, Hey, here's a language that lets me have the low level control of C++ without a lot of, you know, generational cruft built up and with a bright future, a clean syntax and generally like nice capabilities.",Interview P3,Cruft,1,,3,3,1,Author 1,8/8/23,Author 1,1/16/24
3:2,¶ 7,,And so the same problem would end up being like conceptualized in similar ways in C++ and Rust for like small tasks.,Interview P3,Shared Experiences,1,,7,7,1,Author 1,8/8/23,Author 1,1/16/24
3:3,¶ 7,,"Using templates to substitute types in at compile time was just heavily discouraged. The errors that you get would be off the wall and you wouldn't know if things were broken until you actually went to use them. And it was really difficult to keep coherence through a really long chain of systems working together. In Rust, I'm a lot more comfortable using generics and treat bounds to enforce that kind of structure, even as I'm building really large interlocked systems. And so I would say that's probably the main difference for like the way that I approach structural problems. ",Interview P3,C++ is Difficult,1,,7,7,1,Author 1,8/8/23,Author 1,1/16/24
3:4,¶ 7,,Rust is nice because I don't have to worry about memory safety a lot. So I spend a lot less time writing no pointer checks.,Interview P3,Memory Safety,1,,7,7,1,Author 1,8/8/23,Author 1,1/16/24
3:5,¶ 11,,"Talking about all of these nested template types and picking those apart is a lot of work. I guess part of that is because the compilers C++ compilers tend to generate really unfriendly errors. And the other part of it is that those only show up when you actually go to use them. And so in Rust, I'd be comfortable like writing a bunch of code and then after I'm satisfied with how it looks, I can write some tests to make sure it works. But if I want to actually make sure templated code works, I basically have to write the tests upfront before I'm even ready to like decide on a permanent structure of how I want to approach things. ",Interview P3,C++ is Difficult,1,,11,11,1,Author 1,8/8/23,Author 1,1/16/24
3:6,¶ 19,,"The first is obviously to, you know, outsmart the compiler, squeeze a little more performance out. You know, when I know that certain invariants are met, I can use unsafe to speed up my code a bit and then wrap that in some sort of safer, larger abstraction.",Interview P3,"Increase Performance, When to Encapsulate?",2,,19,19,1,Author 1,8/8/23,Author 1,1/16/24
3:7,¶ 19,,"And then the other side of it is I use unsafe to construct new like compiler level, well, not compiler level, but to construct new language level primitives. ",Interview P3,"Data Structures, Primitives, and Operations, No Other Choice",2,"For Author 1: from this quote alone it's not immediately clear why they need unsafe to construct language-level primitives; then in a later quote we tag the reason with ""As Documentation"", so is there a particular reason we don't use that same code here?",19,19,1,Author 1,8/8/23,Author 1,1/16/24
3:8,¶ 19,,"So like when I'm building some new language level primitives, I'll use unsafe to make sure that everybody, you know, enforces contracts by wrapping things in unsafe blocks and justifying them properly so that you can take advantage of some large scale invariants or build up some new invariants that let you write more efficient code or more simple code or more practical code.",Interview P3,As Documentation,1,,19,19,1,Author 1,8/8/23,Author 1,1/16/24
3:9,¶ 23,,So I write a serialization framework called [name]. And obviously a goal for it is to be extremely performant.,Interview P3,Data Processing & Serialization,1,,23,23,1,Author 1,8/8/23,Author 1,1/16/24
3:10,¶ 23,,"And so when I was doing a point transition, I thought this is an opportunity to squeeze a little bit more performance out of it. And so I switched to using a custom like basically like a bump allocator that comes with the serializer. And it has much more restricted semantics for how you're allowed to allocate and deallocate things. And it's like extremely thorny as an API, but for the most part, if you're using it, you're writing unsafe code anyway. You understand how to like use this very like sharp edged abstraction properly. And so when I switched over to using that, it cut like, I think it was like 20 to 40% off some benchmarks. Just because the amount of like extra data that I needed to allocate was just thrashing the global allocator really hard",Interview P3,"Increase Performance, Performance is Necessary",2,,23,23,1,Author 1,8/8/23,Author 1,1/16/24
3:11,¶ 23,,"But using a bump allocator, it was really quick to just allocate a big chunk and then free it.",Interview P3,Unsafe Data Structure,1,,23,23,1,Author 1,8/8/23,Author 1,1/16/24
3:12,¶ 27,,"Uh, so working that in was kind of difficult. Uh, that's basically an unsolved problem. Uh, we have like some approaches for fixing it that use like, uh, drop handlers, but they're kind of nasty. Uh, so panic safety is like a particularly thorny, uh, API surface.",Interview P3,Shifting Ground,1,,27,27,1,Author 1,8/8/23,Author 1,1/16/24
3:13,¶ 27,,"And so the, uh, the allocation API that I had, uh, needed to be panic safe so that if like someone else's serialization code panicked while you were in the middle of like building up this giant list, uh, that you wouldn't accidentally go and stomp over things or use free pointers or, uh, go tread back into like data that you shouldn't be reading. ",Interview P3,Panic Safety,1,,27,27,1,Author 1,8/8/23,Author 1,1/16/24
3:14,¶ 27,,"And then besides that, it's basically just it's raw pointers everywhere. Uh, it's not a really sophisticated API surface. It doesn't expose a lot of types. It's kind of kept as minimal and straightforward as possible. ",Interview P3,Exposing an Unsafe API to Users,1,,27,27,1,Author 1,8/8/23,Author 1,1/16/24
3:15,¶ 27,,"Uh, because of the way that the memory is owned, it was difficult for me to, uh, build a structure that could free that memory without using extra unnecessary data to reference a variable that I already have on hand. So I have my serializer. It knows where all the memory is allocated. But if I wanted to make like a vector that uses that, uh, it would need to hold a reference to that, uh, that allocator, even though I already have the allocator, it's in my local variable. Uh, and I ended up with duplicated like references all over the place, even though they're short lived, they only last the length of a function. Uh, and I don't really neeeeeeeed to hold on to them. And so if I make a lot of those, I end up using a lot more memory than I need to, uh, which is a little frustrating. ",Interview P3,Difficult to Encapsulate,1,,27,27,1,Author 1,8/8/23,Author 1,1/16/24
3:16,¶ 35,,"So this is a library that works, uh, that builds up to, uh, like relative pointers, uh, in rust, which are, they have their own very particular, uh, peculiarities. Uh, but one of the main difficulties is ensuring that you have two pointers in the same allocated region in LLVM terminology, uh, which basically means that you can, uh, translate between the two pointers effectively. And so you can go from, you can take two pointers, you can find the offset between them without invoking undefined behavior. You can offset from one pointer to another, uh, and get to another place safely without invoking undefined behavior.",Interview P3,"Pointer Arithmetic, Unsafe Data Structure",2,,35,35,1,Author 1,8/9/23,Author 1,1/16/24
3:17,¶ 51,,"So I also use it for stuff like that, where I construct these new ideas that I can use to, uh, make more efficient code or make my code even possible.",Interview P3,"Increase Performance, No Other Choice, Performance is Necessary",3,,51,51,1,Author 1,8/9/23,Author 1,1/16/24
3:18,¶ 59,,"I think the coolest one in it is probably static ref, that builds on some of the other primitives to make a zero size type that is a safe reference to a static variable scoped reference to a static variable.",Interview P3,"Static Variables, Unsafe Data Structure",2,,59,59,1,Author 1,8/9/23,Author 1,1/16/24
3:19,¶ 67,,"Uh, and so there's this weird notion where we have the length of an iterator being this thing that's unsafe to implement, but it doesn't directly correspond to memory safety. It's like you can construct situations where it can affect memory safety and therefore it's unsafe. Uh, it's kind of that weird dichotomy where, uh, you can bound things really tightly with unsafe and like build these really tightly knit systems of invariance. Uh, and you, you can, as long as you can like feasibly construct a situation where violating them would cause memory and safety, you can just mark them all unsafe, even if that never actually occurs in practice.",Interview P3,"As Documentation, Contract or Invariant",2,,67,67,1,Author 1,8/9/23,Author 1,1/16/24
3:20,¶ 71,,"Uh, we have this notion where unsafe means there are invariants that you need to uphold when implementing this trait, but that idea is really distant from memory safety explicitly. It's kind of like there is this, uh, logical bridge you have to construct between the two where violating these invariants can cause memory unsafety. Whereas when you're writing an API, you mark things as unsafe as soon as they require special invariants, but on the implementing end, you're, you like, may or may not leverage those invariants or you may or may not have a situation where violating them causes undefined behavior.",Interview P3,"As Documentation, Exposing an Unsafe API to Users",2,,71,71,1,Author 1,8/9/23,Author 1,1/16/24
3:21,¶ 75,,"Uh, so I do windows programming and windows programming is absolutely wild. ",Interview P3,Windows,1,,75,75,1,Author 1,8/9/23,Author 1,1/16/24
3:22,¶ 75,,"And so the natural thing in Rust to do is just Box something into raw it and stick that pointer into that API, like pointer sized slot that you have, and then you can pull that back out to reference your data. And then when the windows closed, you get an event and you rewrap it and drop the Box to be polite. ",Interview P3,"Allocation in Rust, Box<T>",2,,75,75,1,Author 1,8/9/23,Author 1,1/16/24
3:23,¶ 75,,"Uh, so that's a place where I've used Rc/Arc for all of its like unsafe stuff. And then it's easier to just like manually increment and decrement the ref count and stuff.",Interview P3,Easier or More Ergonomic,1,,75,75,1,Author 1,8/9/23,Author 1,1/16/24
3:24,¶ 75,,"With Rc/Arc, I've written a, uh, an executor, uh, and, uh, it uses tasks that may be shared in multiple locations, like wakers may reference a task and like your execution queue and your executor may reference a task. Uh, the thread that's actually pulling it may reference a task. And so the natural way to express those is with an Rc/Arc. Uh, but there is a tricky bit where, uh, I can't remember exactly what it is. I think it's, uh, you only have like a pointer sized, uh, slot to hold memory in. I think it's, uh, it might be waker, uh, lets you create a waker from and a pointer to unit, uh, using an unsafe API. And so naturally I just make a task, put it in an Rc/Arc, and then, uh, turn that Rc/Arc into a raw pointer to the Rc/Arc, cast it to that unit type and throw that into the waker API.",Interview P3,Arc<T>/Rc<T>,1,,75,75,1,Author 1,8/9/23,Author 1,1/16/24
3:25,¶ 83,,"So I write this other crate called [name], uh, which lets you do safe destructuring of a whole bunch of different types",Interview P3,"Data Structures, Primitives, and Operations, Unsafe Data Structure",2,,83,83,1,Author 1,8/9/23,Author 1,1/16/24
3:26,¶ 83,,"Uh, so this is essentially for doing, uh, field by field initialization for some structs. Uh, you would basically make a MaybeUninit of it and then you want to like destructure it into MaybeUninits of all of its fields that you can initialize those in place. And then once those are all initialized, you just assume in it the whole thing. ",Interview P3,MaybeUninit<T>,1,,83,83,1,Author 1,8/9/23,Author 1,1/16/24
3:27,¶ 83,,"It's just turning my MaybeUninit into a pointer, doing offsets, a whole bunch of stuff like that.",Interview P3,Pointer Arithmetic,1,,83,83,1,Author 1,8/9/23,Author 1,1/16/24
3:28,¶ 87,,"I know some people do, but one of the hazards of doing a bunch of like custom stuff with bindgen is if you like add derives to your, or like attributes to your bindgen configuration, you can cause all sorts of bad things to happen if you like tweak the layout properties of the type in a way that's not, uh, consistent with like, uh, repr(C) or something. Or if you're going to derive some stuff for that type and it ends up that, oh, well, you didn't consider this one case where the type has some awkward layout and now the derive makes code that is, uh, like either faulty or like, we'll, we'll result in a compiler error or we'll cause undefined behavior when you do stuff.",Interview P3,"bindgen, FFI & Binding Bug, Undefined Behavior",3,,87,87,1,Author 1,8/9/23,Author 1,1/16/24
3:29,¶ 87,,"Um, for wasm-bindgen, uh, I basically have only used it for tests. I just mark everything as wasm-bindgen and I fire it off to whatever the wasm thing that runs my stuff is, and it eventually gets back to me or gives me some cryptic error that I have to go search on GitHub for. ",Interview P3,wasm-bindgen,1,,87,87,1,Author 1,8/9/23,Author 1,1/16/24
3:30,¶ 91,,"Uh, I have used wasm-bindgen to actually communicate back and forth with like a JavaScript application. That was extremely painful. Uh, I did not expect it to be so difficult to like just make calls back and forth between Rust and JavaScript, but it required a ton of boilerplate. And even then it was like, man, this is a lot more complicated than I wish it was. Wish I could just make like one call.",Interview P3,"Limitation of Binding Tool, wasm-bindgen",2,,91,91,1,Author 1,8/9/23,Author 1,1/16/24
3:31,¶ 95,,"This was the blog post, but for it, I made this, uh, JavaScript puzzle game. And part of that is it has a solver for the puzzles that's written in rust compiled to, uh, web assembly and then loaded in and invoked from the puzzle. ",Interview P3,Web Application Development,1,,95,95,1,Author 1,8/9/23,Author 1,1/16/24
3:32,¶ 95,,"That was like, that hit the nail right on the head of what I wanted WASM to do for me, uh, because writing this kind of a solver in JavaScript is completely untenable. The like memory performance is not high enough in a GC language.",Interview P3,Rust Performs Well,1,,95,95,1,Author 1,8/9/23,Author 1,1/16/24
3:33,¶ 99,,"and there are a slew of like really tricky correctness problems because Rust's memory model is not precisely defined, but also is certainly different enough from C and C++ that you can't just throw objects over the fence. Uh, so I'll say in my personal experience, I haven't run into issues with it, but only because I basically avoid that, but I'm aware of a lot of really tricky issues with, uh, C++ and Rust interop.",Interview P3,"Different FFI Memory Model, Shifting Ground",2,,99,99,1,Author 1,8/9/23,Author 1,1/16/24
3:34,¶ 99,,"Uh, C generally tends to be less of a problem because the memory model is so simple, but, uh, for example, pointer provenance is a really good example of where C and Rust diverge because Rust doesn't exactly have strict provenance, but it's moving in that direction and strict provenance is a lot stricter than C's, uh, forget what that acronym is, but I think it's PVNI, something like that, uh, provenance via non-integer, whatever, uh, and so if you call any C code, uh, you basically have to, uh, understand that you're working inside of a different memory model where like, uh, pointer and pointer round trips are safe, uh, and that's not necessarily the case in Rust.",Interview P3,Different FFI Memory Model,1,,99,99,1,Author 1,8/9/23,Author 1,1/16/24
3:35,¶ 103,,"on the JavaScript side, setting everything up to make a function call into WASM is kind of tricky. You basically load everything into, like, uh, JavaScript's version of, uh, like, raw arrays and then pump them into, like, a function that you dynamically fetched out of your, like, loaded Wasm binary. Uh, and so it's really weird. Uh, it's kind of annoying to write all of those, but, uh, yeah, like I mentioned before, it's probably something that, like, uh, Wasm-bind-gen could do for me but I didn't figure it out in time, uh, or I didn't care to figure it out. So that part in particular was a little tricky.",Interview P3,"Limitation of Binding Tool, wasm-bindgen",2,,103,103,1,Author 1,8/9/23,Author 1,1/16/24
3:36,¶ 111,,"Uh, even though the thing that they call do have that restriction, like the inter call requires that it be within a certain size, it doesn't check those to like panic safely. And so, uh, you can construct like a custom allocator that meets all the requirements and then plug that in and then make an allocation that also like on the other end meets all the requirements that they're relaxed because you're using the like looser API and it causes a segfault because you've tried to do the wrong thing and blown everything up and you've got, you've gone and violated my, uh, safety guarantees without realizing it.",Interview P3,"Logical Error, Requirements Bug, Undefined Behavior",3,,111,111,1,Author 1,8/9/23,Author 1,1/16/24
3:37,¶ 111,,"And at the time, which has completely slipped my mind that when I free that allocator or when I drop that, that new Vec, uh, it's going to free using a layout that is the right size, but it's going to say alignment one because that's the alignment for U8 when I allocated it with the rights with the same size, but alignment 16. Uh, and so someone found that and reported that. I think they found it with Miri, uh, and reported that. And, uh, it turned out to be a very sad, but easy fix where I just allocated a new allocation and copied all the bytes over.",Interview P3,"Allocation & Alignment Bug, Improper Alignment, Miri found a bug",3,,111,111,1,Author 1,8/9/23,Author 1,1/16/24
3:38,¶ 115,,"It's the alloc function, which calls out to global alloc, alloc, and that safety condition says, uh, you have to make sure that the layout that you pass has non zero size. Uh, and that can trip people up if they're not ready for it. Uh, if you've written a generic container and your type is a ZST, then, uh, you go to like allocate some array of them, you'll get a, uh, length zero, uh, layout in there, and that'll trip up your allocator potentially, potentially it will trip up your allocator. I've seen plenty of cases where it doesn't on certain systems and things just chug along as normal. Uh, but, uh, I've also run into situations where it introduces undefined behavior for real and it just, you don't realize that it happened until it's way too late and then tracking it back as a nightmare.",Interview P3,"Allocation & Alignment Bug, Architecture Dependent Problem, Zero-Sized Allocation",3,,115,115,1,Author 1,8/9/23,Author 1,1/16/24
3:39,¶ 115,,"Uh, there is this kind of weird badlands of undefined behavior that is related to like semantics, uh, in Rust that are not exactly defined yet. Uh, stuff like uh, pointer provenance is a really good example of this, but uh, there's also like the whole memory model is not well defined. And so, uh, there are things that are okay by convention, but might technically allow for undefined behavior. Um, and so like the unsafe code guidelines have like slowly been like tweaking this way and that way to make sure that they like tighten in on what is okay or not okay in Rust. ",Interview P3,Shifting Ground,1,,115,115,1,Author 1,8/9/23,Author 1,1/16/24
3:40,¶ 115,,"So it's basically not going to cause any problems when it's boiled down to like LLVM IR. Uh, but still it's not exactly in alignment with what we say things should be undefined behavior and having me recheck that all of your objects are like recursively initialized is also really tough. So there's this ongoing discussion of like, should we allow mutable references to be uninitialized as long as you don't read from them first? And, uh, it's just a question, you know, no one knows the answer. Right now it tends to be the case that it's not going to cause undefined behavior unless you read from it. Uh, and so that's kind of where everyone is going with it.",Interview P3,Shifting Ground,1,,115,115,1,Author 1,8/9/23,Author 1,1/16/24
3:41,¶ 115,,"Uh, if you make a mutable reference from a, uh, an uninitialized value, like if I have a MaybeUninit and I have a pointer to it and dereference it into a reference, uh, is that undefined behavior? The gut reaction is yes, but there's a lot of question about, hey, what if I want to pass in, uh, for example, in [crate name], you have this byte structure that's used for like an input output buffer. What if I want to make a bytes that, uh, aliases mutably those uninitialized bytes? Uh, but I'm only going to write to them.",Interview P3,"MaybeUninit<T>, Shifting Ground",2,,115,115,1,Author 1,8/9/23,Author 1,1/16/24
3:42,¶ 119,,"Oh yeah. Uh, Clippy is great. Asterisk. It's definitely annoying, hence the name. But there have been a couple of times when there's legitimately caught bugs for me, and that makes it all worth it. Uh, I can't think of any particular ones, but I think it's all related to like, oh, you used the, uh, the wrong semantics here. This is going to cause an implicit dereference and you're not allowed to do that right here. You probably didn't mean to implicitly dereference this. ",Interview P3,Clippy Finds Bugs,1,,119,119,1,Author 1,8/9/23,Author 1,1/16/24
3:43,¶ 119,,"Miri is just like the big hammer for finding undefined behavior. Uh, I run all of our tests through Miri and if stuff comes up, it's undefined behavior. And then whether or not it actually is undefined behavior, we fix it. ",Interview P3,Running tests through Miri,1,,119,119,1,Author 1,8/9/23,Author 1,1/16/24
3:44,¶ 119,,"One of the tricky things about Miri is that stacked borrows is a like runtime approximation of Rust's, uh, ownership rules. It's not exactly correct because Rust's, uh, implementation is like too rapidly changing at like the micro level to like formally specify what it is.",Interview P3,Shifting Ground,1,,119,119,1,Author 1,8/9/23,Author 1,1/16/24
3:45,¶ 119,," Uh, for me, Miri got on my nerves because, uh, stacked borrows didn't handle relative pointers where you create intervening references properly. Uh, it basically always detects that as undefined behavior. Uh, and that really made me sad because I wanted to use Mary to check everything else, but it would just instantly error out as soon as I, uh, did like one thing with a relative pointer. Um, the nice thing is we have a new model that's like currently in development called tree borrows and that handles the case perfectly.",Interview P3,Stacked Borrows is too strict,1,,119,119,1,Author 1,8/9/23,Author 1,1/16/24
3:46,¶ 131,,"Uh, you cannot fix undefined behavior with just Miri and Clippy. They are great tools, but they are not enough. Uh, from personal experience, I can say you need a good debugger, and it is the most important component, because when push comes to shove, only a debugger will tell you what's going wrong.",Interview P3,Debugger,1,,131,131,1,Author 1,8/9/23,Author 1,3/18/24
3:47,¶ 135,," So because of the very nature of what it's doing, there is a ton of unsafe in this. We basically have to like probe some data on disk and make sure that all of the invariants that we need are upheld, whether that's Chars being in the right range, Booleans being zero or one, floats being some restricted set. Uh, and then eventually that builds up to like, Oh, well, you know, vectors need to have valid pointers and this and that. And hash maps need to have, you know, entries that hash to the right values back and forth, into the right buckets. So it gets to a really high level really quickly. ",Interview P3,"Contract or Invariant, No Other Choice",2,,135,135,1,Author 1,8/9/23,Author 1,3/18/24
3:48,¶ 135,,"And through no fault of their own, they introduced this really nasty undefined behavior, because of a mislink on Windows when you use thin LTO and figuring out what this problem was was really tough. It basically ended up being like an atomic pointer somewhere was initialized to the wrong value. And it was because the like section that it was being linked in with wasn't being relocated properly. Really crazy. And the only way that I could figure it out was by firing up a WinDBG, which is Windows' reversible debugger environment.",Interview P3,"Architecture Dependent Problem, FFI & Binding Bug, Incorrect Linking, Undefined Behavior",4,For Author 1: this doesn't immediately seem to be about FFI; am I missing some context?,135,135,1,Author 1,8/9/23,Author 1,3/18/24
3:49,¶ 135,,"So like when push comes to shove, you need a good debugger. I will say I don't think that we have really a rust quality debugger experience yet. And I think everyone basically agrees. We have a lot of debuggers at work, like MSVC's debuggers works and LLDB works, but it's not really like a rust level experience where you can get all the bells and whistles that you want and things just work nicely together. It's still kind of just getting down in the mud.",Interview P3,Debugger,1,,135,135,1,Author 1,8/9/23,Author 1,3/18/24
3:50,¶ 23,,"And it's like extremely thorny as an API, but for the most part, if you're using it, you're writing unsafe code anyway. You understand how to like use this very like sharp edged abstraction properly.",Interview P3,Tacit Knowledge,1,,23,23,1,Author 1,9/5/23,Author 1,1/16/24
3:51,¶ 35,,"Uh, and so I use unsafe there to say, take, uh, some pointer that I know is associated with some region type and glue them together and say, okay, whoever called this new function has promised that this pointer and this region type correspond with each other. Uh, and I can use that to make sure that I can take two pointers that I know are in the same memory region and do all these operations safely with them. ",Interview P3,Contract or Invariant,1,,35,35,1,Author 1,9/5/23,Author 1,1/16/24
3:52,¶ 41,,"Also in that crate, uh, there's this unique trait, uh, which is related to that region. And it's, it represents a type that only one value of it can ever exist at a time. Uh, and that's used for basically like uniquely identifying those regions. So a unique type could be turned into a region just like a, it's kind of like a brand. If you've, I don't know if you've read, uh, or heard of the ghost cell paper.",Interview P3,"Contract or Invariant, Unsafe Data Structure",2,,41,41,1,Author 1,9/5/23,Author 1,1/16/24
3:53,¶ 87,,"It's not so difficult to write all those by hand, but keeping them in sync is a pain.",Interview P3,Generation VS Validation,1,,87,87,1,Author 1,9/5/23,Author 1,1/16/24
3:54,¶ 87,,"Uh, cbindgen and bindgen are, I mean, they basically generate what you'd expect. It's like, what is the signature of this according to C and C++? And then, well, according to C, I should be, I should be more careful with my wording. Uh, and that basically just gets exported. It's almost no different from just a raw header file that lists out all of your symbols. It's basically for convenience.",Interview P3,"bindgen, cbindgen",2,,87,87,1,Author 1,9/5/23,Author 1,1/16/24
3:55,¶ 87,,"Uh, windows-bindgen is, it's just generating, uh, bindings for Windows APIs. Those are a lot closer to like C bindings for the Windows APIs, but they're generated from metadata. So you pick and choose what APIs you want.",Interview P3,windows-bindgen,1,,87,87,1,Author 1,9/5/23,Author 1,1/16/24
3:56,¶ 99,,"Uh, so basically no, but that's only because the guarantees are so uh, ill-defined that I basically only stick to like extremely primitive stuff back and forth.",Interview P3,Simple FFI,1,,99,99,1,Author 1,9/5/23,Author 1,1/16/24
3:57,¶ 99,,"Rust doesn't exactly have strict provenance, but it's moving in that direction",Interview P3,Shifting Ground,1,,99,99,1,Author 1,9/5/23,Author 1,1/16/24
3:58,¶ 111,,"Uh, and I realized just by chance that the allocation APIs didn't have the same safety requirements. And so I reported that upstream. Uh, I constructed an example where that could cause undefined behavior and then reported that upstream.",Interview P3,Engaging with the Rust Community,1,,111,111,1,Author 1,9/5/23,Author 1,1/16/24
3:59,¶ 115,,"A really big clump is obviously like just good old fashioned. You mismanaged your pointers, uh, uh, you know, using the wrong pointer somewhere or using it after you should or leaving a dangling or, you know, all sorts of weird pointer errors. That's obviously a big clump of them.",Interview P3,Pointer errors,1,"For Author 1: I see that the filter for this view uses the ""Bug Categories"" code group instead of the ""New Bug Categories"" code group; is that intentional?",115,115,1,Author 1,9/5/23,Author 1,1/16/24
3:60,¶ 115,,"I've seen plenty of cases where it doesn't on certain systems and things just chug along as normal. Uh, but, uh, I've also run into situations where it introduces undefined behavior for real and it just, you don't realize that it happened until it's way too late and then tracking it back as a nightmare.",Interview P3,It's not a problem,1,,115,115,1,Author 1,9/5/23,Author 1,1/16/24
3:61,¶ 115,,"So that specific one has happened to me where I've allocated a, where I've made an allocation of size zero and it caused undefined behavior and I had to like basically bisect it back because I couldn't corner it. It wasn't like causing a segfault immediately. I had to bisect it back until I had to figure out what was causing it.",Interview P3,"Allocation & Alignment Bug, Zero-Sized Allocation",2,,115,115,1,Author 1,9/5/23,Author 1,1/16/24
3:62,¶ 115,,"So it's basically not going to cause any problems when it's boiled down to like LLVM IR. Uh, but still it's not exactly in alignment with what we say things should be undefined behavior and having me recheck that all of your objects are like recursively initialized is also really tough. ",Interview P3,It's not a problem,1,,115,115,1,Author 1,9/5/23,Author 1,1/16/24
3:63,¶ 123,,"I was talking to, uh, [name] at [event] last year and I was basically like, please, can I have some sort of fix for Miri? And he was like, I don't know, maybe. So I'm glad that it happened.",Interview P3,Engaging with the Rust Community,1,,123,123,1,Author 1,9/5/23,Author 1,3/18/24
4:1,¶ 7,,"So I mean, the very first starting point was cargo. Ada has a build system. It's not make file based, but it is very hard to actually split things into multiple libraries and cargo that was just out of the box trivial to do and yeah, it even had uploading your libraries to share them with other people and everything. By now Ada has caught up, but back then that was not even on the radar.",Interview P4,Rust Has Great Tooling,1,,7,7,1,Author 1,8/9/23,Author 1,1/16/24
4:2,¶ 15,,"We're getting there. Basically the only thing left is subtyping, custom subtyping, so that you can specify like I want an integer, but only between one and 10. That is something that Ada has built into the language and is a core feature that's basically making embedded development and security critical development very easy. That's something that we're missing. That's something that we need.",Interview P4,Wants Solution,1,,15,15,1,Author 1,8/9/23,Author 1,1/16/24
4:3,¶ 19,,"Basically I was avoiding any kind of unsafe optimization or anything else, just accessing hardware on embedded devices. ",Interview P4,"Operating & Embedded Systems, Preference for Safety",2,,19,19,1,Author 1,8/9/23,Author 1,1/16/24
4:4,¶ 19,, Recently to implement multithreaded primitives.,Interview P4,"Data Structures, Primitives, and Operations",1,,19,19,1,Author 1,8/9/23,Author 1,1/16/24
4:5,¶ 23,,"So we tried to isolate all the unsafe into a single setting at the beginning, like producing safe references to or safe accessors to the hardware. And so all our unsafe usage was limited to taking a raw pointer in the beginning, converting that to a reference and to calling various volatile or atomic operations in those wrappers.
",Interview P4,"Atomic Intrinsics, Local, Minimal Unsafe, Volatile Intrinsics",3,,23,23,1,Author 1,8/9/23,Author 1,1/16/24
4:6,¶ 27,,"I took a hardware address that was specified in the hardware documentation, converted that to a raw pointer, and then the reference it to get a reference out of it. And from then on, it was all field references and two structs that were all safe field access.",Interview P4,"Local, Minimal Unsafe",1,,27,27,1,Author 1,8/9/23,Author 1,1/16/24
4:7,¶ 31,,"Basically, I don't know issues like that, because the hardware is already aligned. And so in order to get a pointer to the right hardware thing, you already have an aligned pointer. You basically, you never had an unaligned memory situation there.",Interview P4,Contract or Invariant,1,,31,31,1,Author 1,8/9/23,Author 1,1/16/24
4:8,¶ 35,,"So just the nature of the app, the fact that you're working within that embedded context, sort of rules out a bunch of the typical pitfalls that you'd have with alignment, specifically, you get a funny pitfall, which is the address zero is actually an address where you can store data. So that is something that's funky in embedded that you need to make sure that doesn't affect your Rust program, because Rust doesn't obviously doesn't like that.",Interview P4,"Different FFI Memory Model, Operating & Embedded Systems",2,,35,35,1,Author 1,8/9/23,Author 1,1/16/24
4:9,¶ 43,,"Well, we wrote documentation explaining why our unsafe code was okay,",Interview P4,Documented Contract or Invariant,1,,43,43,1,Author 1,8/9/23,Author 1,1/16/24
4:10,¶ 43,,we never exposed any unsafe operations. We we wrapped it everything in safe operations. We were exposing that to students. We didn't want anybody to actually mess with the stuff. So yeah.,Interview P4,Exposing a Safe API,1,,43,43,1,Author 1,8/9/23,Author 1,1/16/24
4:11,¶ 47,,"Kind of the problem is once you get to to this embedded hardware level, as like, you're undefined behavior, or is you're not doing something correctly by the spec of the hardware, which might not affect your program at all. Like it might. It's not undefined behavior in the common sense. It's more like your device will not act as you expected. And that is something where we documented everything heavily, but we couldn't really add any assertion. ",Interview P4,"Contract or Invariant, Documented Contract or Invariant",2,,47,47,1,Author 1,8/9/23,Author 1,1/16/24
4:12,¶ 55,,"So you only add data to it. You never ever delete or modify anything. And that means we can have infinite reading participants. And at the same time, a writer can do some work at something new to it without affecting all the readers. So there's only a conflict between the writers. And for that, I had to implement a new primitive to support some data structures for that. Basically, a vector that could be used multi-threaded.",Interview P4,"No Other Choice, Unsafe Data Structure",2,,55,55,1,Author 1,8/9/23,Author 1,1/16/24
4:13,¶ 59,,"Amusingly, using more unsafe made it less fragile. I was trying to avoid various uses of unsafe before. And instead, you use things like Boxes and vectors to abstract reallocations. But at some point, I needed to deallocate memory. So I was using the raw deallocation API. But I did something wrong. And I wasn't even clear on what I did wrong. But in the end, it was simpler to use the raw allocation and deallocation API directly instead of trying to use the existing higher level primitives, mixing them with the unsafe APIs. That was the problem. Because I didn't have full control. I didn't understand how they were allocating data.",Interview P4,Easier or More Ergonomic,1,,59,59,1,Author 1,8/9/23,Author 1,1/16/24
4:14,¶ 67,,"That might have been avoidable. But like from the time and effort I had to put in, it was easier to just do that. And the final result was much clearer to understand and reason about.",Interview P4,Easier or More Ergonomic,1,,67,67,1,Author 1,8/9/23,Author 1,1/16/24
4:15,¶ 71,,"And now, since I'm using the allocation API and reallocate API directly, it's basically there's three points where I'm using unsafe and they all are using the same like get the size, get this alignment and then feed them all to the raw allocate APIs instead of trying to match up various different APIs that don't quite match up.",Interview P4,"Local, Minimal Unsafe",1,,71,71,1,Author 1,8/9/23,Author 1,1/16/24
4:16,¶ 79,,"Basically, like if there's a good safe API that people have written, I will always go with that. And if that solves the job, I won't even try to use unsafe. It's mainly if I know there's a certain point where I need to use unsafe, I try to use some consistent API or an existing wrapper that makes that doesn't wait with it for me.",Interview P4,Preference for Safety,1,,79,79,1,Author 1,8/9/23,Author 1,1/16/24
4:17,¶ 83,,"So when you allocate with something like a Box or an Rc, you don't actually know if they're going to feed the alignment of your type to the underlying allocator or if they feed a larger alignment to the underlying allocator. You don't have control of that during the allocation. So when you manually deallocate, you need to specify the correct alignment. And if you don't know what that is, you can't even do this correctly at all. So if there's too much abstraction, you lose the information that you need to make it actually sound.",Interview P4,"Arc<T>/Rc<T>, Box<T>, Easier or More Ergonomic",3,"For Author 1: wouldn't this actually be ""No Other Choice"", because of the sentence at the end? ""So if there's too much abstraction, you lose the information that you need to make it actually sound.""",83,83,1,Author 1,8/9/23,Author 1,1/16/24
4:18,¶ 95,,Definitely. And that is accessing bits of a pointer that irrelevant due to alignment or some other information. That's basically tagging pointers. It's impossible to address it correctly or safely right now. ,Interview P4,No Other Choice,1,,95,95,1,Author 1,8/9/23,Author 1,1/16/24
4:19,¶ 99,,"That goes back to the embedded world. When we started using interrupts, we needed to synchronize our accesses to shared memory between the interrupts and the main program. And for that, we needed to implement our own mutexes because there's no operating system or anything interesting there that you could reuse. And for implementing those, we needed UnsafeCell to be able to have interior mutability and then figure out some locking scheme around that to soundly access that shared memory.",Interview P4,"Data Structures, Primitives, and Operations, No Other Choice, Operating & Embedded Systems, Unsafe Data Structure, UnsafeCell<T>",5,,99,99,1,Author 1,8/9/23,Author 1,1/16/24
4:20,¶ 103,,"No. So if we're in a single-threaded environment, I just use RefCell liberally. And I have benchmarked a few cases. And it's usually just a single bully and lookup to check if you can access it most of the time. So yeah, we haven't seen any performance problems with RefCell at all.",Interview P4,"Profiling, RefCell<T>",2,,103,103,1,Author 1,8/9/23,Author 1,1/16/24
4:21,¶ 107,,So I'm working on the [name] for Rust.,Interview P4,Rust Project Contributor,1,,107,107,1,Author 1,8/9/23,Author 1,1/16/24
4:22,¶ 115,,Static mut is a horrible other situation where we can't actually make it safe. Like static mut by itself is probably unsound whenever you use it.,Interview P4,Shifting Ground,1,,115,115,1,Author 1,8/9/23,Author 1,1/16/24
4:23,¶ 115,," Static mut is a horrible other situation where we can't actually make it safe. Like static mut by itself is probably unsound whenever you use it. And the correct way would be to use normal static and build an abstraction on top of that was with UnsafeCell that allows you to access the underlying data, even unsynchronized if you want to do. But as long as you're sure it's sound, it's okay. And there is a small nuance difference between using static with UnsafeCell versus using static mut. And that's basically just that you could have multiple mutable references to the same memory location at the same time. And that's not allowed by the Rust memory model. And yeah.",Interview P4,"Static Variables, UnsafeCell<T>",2,,115,115,1,Author 1,8/9/23,Author 1,1/16/24
4:24,¶ 111,,"So one funny type that Rust allows in constants is, for example, Option of Cell of something. And if that isn't a constant, and you had a constant that is sum and then the Cell, you could technically mutate that with the set operations and so on. Like if you put in a static, for example, and you have static, that's Option Cell, and then you pick the name of static, got set, and you could change it without any thread safety or anything. And that would obviously be a problem. And at the same time, Rust allows you to use that type as the type of static as long as you put none in there. The moment you use some, it stops allowing that. So it's revealing the value of the static to figure out if you're actually allowed to have that value in the static. If you just do the type based analysis, you'd be, no, no, no, that's bad. But since it's compile time, you can actually look at the value and then make the decision. ",Interview P4,"Cell<T>, Option<T>, Static Variables",3,,111,111,1,Author 1,8/9/23,Author 1,1/16/24
4:25,¶ 123,,"So the great thing is simply that it works really quickly. You get access to your C API and you don't have to put a lot of work into it of having a somewhat nice API. You don't have to synchronize the implementation on the C side with the implementation on the Rust side. Instead, you'd get a Rust type error if you used it wrong. So you have a single specification. That's the header file. And that is just super convenient compared to writing it once on the Rust side, writing it once on the C side and hoping to get it right. So yeah, just taking off a lot of menial work. ",Interview P4,"bindgen, cbindgen, Generation VS Validation",3,,123,123,1,Author 1,8/9/23,Author 1,1/16/24
4:26,¶ 123,," So you have a single specification. That's the header file. And that is just super convenient compared to writing it once on the Rust side, writing it once on the C side and hoping to get it right.",Interview P4,Generate Bindings From a Subset,1,,123,123,1,Author 1,8/9/23,Author 1,1/16/24
4:27,¶ 127,,"Oh, no, you have to reason about it completely yourself. You need to look at the the code and figure out how those pointers relate to each other and then write those lifetimes manually.",Interview P4,Contract or Invariant,1,,127,127,1,Author 1,8/9/23,Author 1,1/16/24
4:28,¶ 135,,"So trying to avoid the problem entirely in hopes that in future, there will be a better method for doing this correctly, but it's better for you to just use raw pointers than attempt to write findings that are applying lifetime semantics to foreign code.",Interview P4,Wants Solution,1,,135,135,1,Author 1,8/9/23,Author 1,1/16/24
4:29,¶ 123,,"What's not so great is that there is ways to write a nicer API on the Rust side that directly is a function interface to the C side without having intermediate layers. Like you could write something that passes a reference to a C function, even if that C function obviously can only declare a pointer. But on the Rust side, you could declare that function interface to have a reference, even with a lifetime linking it to the return type. And if you use bindgen, you need to manually write a wrapper around that that calls that C function. So it's probably more of an aesthetic thing, but yeah, would be nice if that could be done better.",Interview P4,"bindgen, Limitation of Binding Tool",2,,123,123,1,Author 1,8/9/23,Author 1,1/16/24
4:30,¶ 139,,"WebAssembly has things like value ref types that basically like shared references or something that you can't convert to an actual address. It's like an opaque address, basically. You can use it, you can pass it around, but you can never actually write it like access it's bytes. And we needed that. And the only way to get that was either writing manual WebAssembly wrappers ourselves or using Wasm-bindgen and hoping that the optimizer is powerful enough to actually get us to the point that we need.",Interview P4,Generation VS Validation,1,,139,139,1,Author 1,8/9/23,Author 1,1/16/24
4:31,¶ 147,,"Various times, but they were all pretty straightforward where we just realized that it wasn't even a tool that was wrong. It was literally just like we were using it wrong, not using the tool wrong. We were using the API to the tool generated wrong. So it was never an issue with the tool actually doing, yeah, generating bad code.",Interview P4,Difficulty with Generated APIs,1,,147,147,1,Author 1,8/9/23,Author 1,1/16/24
4:32,¶ 151 – 152,,"The one pattern that we've noticed was just handling the differences between mutable references, immutable references, and owned references or Boxes, I guess. But whatever other kind of allocator you have in the background, just handling the ownership differences in a C foreign function interface is challenging. It's already challenging just writing C code, but then mixing it with Rust, which has a lot of assumptions built in, you need to actually make sure everything is correct and maybe you have a bunch of pointers that it'll all work out. So yeah.

",Interview P4,Different FFI Memory Model,1,,151,152,2,Author 1,8/9/23,Author 1,1/16/24
4:33,¶ 155,," If you didn't have an old pointer and you tried to put it in a Box, then you deallocate something that you didn't have ownership of, that's bad. And if you do it the other way around, that's not really an issue.",Interview P4,"Box<T>, Box<T> Bug, From Raw, Wrong Pointer",3,,155,155,1,Author 1,8/9/23,Author 1,1/16/24
4:34,¶ 163,,"Oh, it's not even the size. No, literally, because it's impossible to run the C++ code. So it's just going to break your ... We can test the foreign function interfaces with Miri because you can write external functions that you just write a mocking crate and link it against it. And then it'll complain if you screwed up the API there. But yeah, doesn't work for actually invoking lots of C code.",Interview P4,Miri doesn't support this feature,1,,163,163,1,Author 1,8/9/23,Author 1,1/16/24
4:35,¶ 159,,"Yeah. We've had a bunch of these. And the thing, the main issue we've had was they were happening because the programs that we used were too big to run in Miri. At the moment, we had small libraries and so on. We could just feed it all onto Miri and write some mocking on the C side to check that everything works out. And with more complex programs where you get like a 50,000 lines of code C++ space, that's just not possible.",Interview P4,"Borrowing or Provenance Bug, Miri doesn't support this feature, Stacked/Tree Borrows Violation",3,,159,159,1,Author 1,8/9/23,Author 1,1/16/24
4:36,¶ 163,,We can test the foreign function interfaces with Miri because you can write external functions that you just write a mocking crate and link it against it. ,Interview P4,Worked Around Miri's Limitations,1,,163,163,1,Author 1,8/9/23,Author 1,1/16/24
4:37,¶ 171,,The only other intrinsics that we've used were the volatile ones for the embedded project.,Interview P4,Volatile Intrinsics,1,,171,171,1,Author 1,8/9/23,Author 1,1/16/24
4:38,¶ 183,,"The main thing with Miri was always introducing it later in the project. I mean, I guess it's the same with Clippy. If you introduced either of these tools later in the project, it becomes much more challenging to run your test suites with that or run it across your project. If you started from the beginning, you always making sure that already works with those tools. That's been the biggest hurdle that I've had so far with Miri. ",Interview P4,"Difficult to introduce, Miri is slow",2,,183,183,1,Author 1,8/9/23,Author 1,1/16/24
4:39,¶ 183,,"With Clippy, the issues are upgrading Clippy to a new version that causes lots of more lints to get triggered and simply using it on an existing code that hasn't been run with Clippy a lot. There is no good tooling for gradually integrating Clippy. You can only manually slap a bunch of allows if you were. But I've seen tooling for similar static analysis tools where you'd run it and then it would just store all the information about all the lints that triggered in a separate file and then you could gradually just work on it to get rid of them or address them in some manner. So having that approach with Clippy would be considerably helpful for these projects where you have to introduce a little later stage. ",Interview P4,Difficult to introduce,1,,183,183,1,Author 1,8/9/23,Author 1,1/16/24
4:40,¶ 187 – 188,,"One thing we've seen is that using synchronization primitives wrongly or using multiple mutable references to the same data keeps happening and is not unsound in practice. So people will have been using that left and right and basically they're using multiple mutable references to the same data and not using the correct synchronization accesses, like not atomic operations or nothing, but sometimes they use for example volatile instead of atomics, which is still not correct, but it's like making sure that the optimizer is sufficiently restrained to not break your code in really bad ways. So it could happen at any time when you do an LLVM upgrade or something, when you get to a new Rust version that your code suddenly breaks, but it is very unlikely, simply because the code is so far apart that the optimizer will never see both things at the same time and realize that you're doing undefined behavior and that it can go off of the rails and just do whatever it wants.

",Interview P4,It's not a problem,1,,187,188,2,Author 1,8/9/23,Author 1,1/16/24
4:41,¶ 199,," There's one where Miri just doesn't detect it, because it doesn't happen in the executions of our tests. ",Interview P4,Missed a Bug,1,,199,199,1,Author 1,8/9/23,Author 1,1/16/24
4:42,¶ 199,,"The usual case is actually we detect something and it's way too big to refactor. And getting there is like a multi-year project. So it's happening in the background. We're ensuring that not more issues are cropping up, but we know which tests are not going to pass and we need to work on them. And yeah, we know about the soundness issues, basically.",Interview P4,Laziness Fights Tooling,1,,199,199,1,Author 1,8/9/23,Author 1,1/16/24
4:43,¶ 207,,"No, this is for completely pure Rust for now. Or going to with interop, the thing that we're exploring is basically a Valgrind version of Miri where you could run your program without modifying it without running without compiling it especially for Miri or something. What you'd do is you'd feed it to Valgrind and Valgrind knows about the Rust rules, like with a certain plugin that we've been developing. And then that will also uphold your constraints within the C code base. Treating the C code base basically as a Rust code base that is just raw pointers everywhere and unsafe everywhere.",Interview P4,Wants Solution,1,,207,207,1,Author 1,8/9/23,Author 1,1/16/24
4:44,¶ 51,,"And on the other side, if you have generated information, which we have definitely used, we did a big pre, a big part of data in the Linux kernel that we were actually scraping for our hardware. And that data allowed us to generate all these data structures that I was talking about earlier, those wrappers for the hardware, because they had all the information about addresses and everything in there.",Interview P4,Generation VS Validation,1,,51,51,1,Author 1,9/5/23,Author 1,1/16/24
4:45,¶ 131 – 132,,"At the moment it's not obvious, we just resort to keeping raw pointers around and not even trying to abstract it nicely at that point.

",Interview P4,Difficult to Encapsulate,1,,131,132,2,Author 1,9/5/23,Author 1,1/16/24
4:46,¶ 175,,No. I think the intrinsics were chuckling change loss style enough that we could care to not use them too much and also just build good wrappers around them that were simple enough to verify the hand. We've never had any problems with intrinsics as far as I can remember.,Interview P4,It's not a problem,1,,175,175,1,Author 1,9/5/23,Author 1,1/16/24
4:47,¶ 191,,"You don't. You know it basically by, or you're guessing at it by your program is running fine on the millions of machines or something and so if it's not stack folding on those machines, statistically it looks like you're not unsound and that might be true for your specific compilation and the binary that you're producing, but it might, it's unclear when that will break. So you really just have to continue testing and ensure that these, that the behavior is still consistent, but there aren't any good formal ways of going about doing this",Interview P4,Tacit Knowledge,1,,191,191,1,Author 1,9/5/23,Author 1,1/16/24
5:1,¶ 3,,"My motivations have been that as mostly a C++ developer throughout my career, the language had started accumulating too much cruft in a way that it was too difficult to get rid of and without having many initiatives to clean it up. In other words, I ended up in certain projects just finding myself more comfortable just doing C rather than C++ due to the ever-evolving nature of C++ and what seemed to me to me a not particularly useful direction. So for cases where the code was relatively low level and simple enough, I'd switch to C and C++ whenever the code base was bigger. ",Interview P5,Cruft,1,,3,3,1,Author 1,8/9/23,Author 1,1/16/24
5:2,¶ 7,," But within, or maybe it might have been [name], that within C++ lies a smaller, neater language trying to get out. And to an extent, all the developers that I've worked with who work with C++ tend to pick their own favorite sub-language within the language. And if you start working on large enough code bases, the intersection of the sub-languages means the whole language. And that makes for a relatively unruly and unmaintainable code base.",Interview P5,C++ is Difficult,1,,7,7,1,Author 1,8/9/23,Author 1,1/16/24
5:3,¶ 7,,"And if you compile C++ without the standard library, you're basically down with C with templates and classes. You're basically doing C again, so you might as well do C. So Rust offers a way out of that, where you can statically link pretty much everything you need and go from there.",Interview P5,Feature Disparity,1,,7,7,1,Author 1,8/9/23,Author 1,1/16/24
5:4,¶ 7,,Rust is a way to get things to be cleaner. ,Interview P5,Rust is ergonomic,1,,7,7,1,Author 1,8/9/23,Author 1,1/16/24
5:5,¶ 11,,"But then you find that as a C++ developer moving to Rust, there's many tricks that you'd like to do that you just don't get to do out of the box. Some of them are genuinely hard to pull off. I mean, things like referring to having a pointer into your own object becomes very, very hard, because of this assumption that everything is going to be movable by default.",Interview P5,Feature Disparity,1,,11,11,1,Author 1,8/9/23,Author 1,1/16/24
5:6,¶ 11,,"So there's still cases that you sort of know better and you go, okay, well, okay, how do I break out of the constraints imposed by the language? And the initial beginner response to that is just to breach out for unsafe, which is not wrong as a learning experience, I think, because it allows you to find where the edges of the language are. Once you start writing more production code, you realize that actually there's Cell and RefCell, and there's Pin, and there's all sorts of little utilities that allow you to, not necessarily always, but quite often address that problem.",Interview P5,"Cell<T>, Easier or More Ergonomic, No Other Choice, Pin<T>, RefCell<T>",5,"For Author 1: to me this idea of using unsafe as ""training wheels"" while learning the language feels closer to ""For Fun"" than any of the other codes.",11,11,1,Author 1,8/9/23,Author 1,1/16/24
5:7,¶ 15,,"And it's still not perfect. I mean, it's kind of trivially easy to write a smart pointer in C++, but it's not trivially easy to do it in Rust, for example. I think there's a couple of things that are, I don't know the details about it and I haven't really looked at it because I haven't, but if I wanted to write truly highly performant code, and that means that I really, really need to sweat memory allocation, then that is still an area where I feel that it's still harder to do in Rust than it would be in C++.",Interview P5,C++ is Easier to Use,1,,15,15,1,Author 1,8/9/23,Author 1,1/16/24
5:8,¶ 19,,". So sometimes it's just as trivial as a profiling piece of code, and you've got something that loops over vectors, and you just want to get rid of the bounds checks. So it's my code, I know exactly what it does, top to bottom, and it's basically a for loop. It's like, okay, great. I had a hotspot there and I managed to gain an extra 10% performance.",Interview P5,"Increase Performance, Profiling",2,,19,19,1,Author 1,8/9/23,Author 1,1/16/24
5:9,¶ 23,,"Another case would be something like, yeah, usually it's like 99% of my use cases actually are just FFI's, either calling things that aren't Rust from Rust or exposing Rust to other things.",Interview P5,No Other Choice,1,,23,23,1,Author 1,8/9/23,Author 1,1/16/24
5:10,¶ 35,,"because some checks like bounds checks that we talked about, some of them you could potentially get rid of at compile time, but not all of them. ",Interview P5,Compiler Eliding Bounds Checks,1,,35,35,1,Author 1,8/9/23,Author 1,1/16/24
5:11,¶ 35,,"So say, for example, I receive a buffer from which I know is in UTF-8, and I trust that the Python interpreter will give me a UTF-8 buffer when I ask for one. I would use a piece of unsafe. I think it's like a UTF-8 unchecked on this stereotype. I forgot what it is, but you basically have a way to elide some checks. ",Interview P5,"Contract or Invariant, Increase Performance",2,,35,35,1,Author 1,8/9/23,Author 1,1/16/24
5:12,¶ 35 – 36,,"For me, I don't use Rust because I'm particularly paranoid about memory. I've spent all of my life basically dealing with lots of programming languages, and I'm relatively comfortable that certain patterns of code will be safe. So I'm happy with those.

",Interview P5,Tacit Knowledge,1,,35,36,2,Author 1,8/9/23,Author 1,1/16/24
5:13,¶ 43 – 44,,"We're now being very specific about that. So if a piece of logic is effectively isolated and encapsulated away, such that what I think are invariants are indeed invariants, then I'm happy to do that.

",Interview P5,"Local, Minimal Unsafe",1,,43,44,2,Author 1,8/9/23,Author 1,1/16/24
5:14,¶ 55,,"Sure, I will certainly not use the unsafe word beyond what is necessary. So yes, I have a safe wrapper. But obviously at some point I decided that this was the correct boundary layer to delineate the safe wrapper. Now we're talking about why did I decide that marking this code as safe is indeed possible? And that is because I knew that within the program I had certain guarantees that go beyond what could have been expressed by the type system. So for example, yes, this is an integer, but I know that it's never below 1000 and never above 3000. So if the compiler knew that, then it could go off and apply lots of optimizations, but it doesn't. But I do, so there you go. Bye-bye bounds check, because in this case you don't need it. So as simple as that, basically. That's what I mean. So if everything, if I've isolated the code that has the piece of unsafe in a way that I know more about it than the compiler does, then I'm happy to take over.",Interview P5,When to Encapsulate?,1,,55,55,1,Author 1,8/9/23,Author 1,1/16/24
5:15,¶ 59,,"There's nothing worse than a comment that is wrong, because now you start wondering, now you start wondering, is it the comment which is wrong, or is the implementation that is wrong? Because comments don't have a compiler. When you chuck enough people at a code base, comments don't really get read all that much. So there's always this thing of, is it worthwhile putting in a comment that may or may not be maintained at this point in time? It's just a pragmatic thing and it's a call you need to make. So I don't actually advocate documenting every piece of unsafe because of that.",Interview P5,No Docs > Incorrect Docs,1,,59,59,1,Author 1,8/9/23,Author 1,1/16/24
5:16,¶ 63,,"I think I'm giving you a nugget of experience that I think transcends Rust or not Rust. Just when to comment and when not to comment. So step one, don't comment anything that the code is obviously doing. Step two, if you are going to comment, comment intentionally. Step three, think that this comment may not be maintained as much the risk.",Interview P5,No Docs > Incorrect Docs,1,,63,63,1,Author 1,8/9/23,Author 1,1/16/24
5:17,¶ 71,,"Yeah, so I work for a database company and we've got a client for a database and I originally had written this in C.",Interview P5,Databases,1,,71,71,1,Author 1,8/9/23,Author 1,1/16/24
5:18,¶ 71,,So the whole library got rewritten in Rust.,Interview P5,Rewrite it in Rust,1,,71,71,1,Author 1,8/9/23,Author 1,1/16/24
5:19,¶ 71,,"It was ABI compatible, which is nice, with the C interface on top. And then obviously that was a C++ interface on top of that, which is where that goes. And then we thought, okay, well, now we have got the C and C++ API. Can we expose the library to Python? So the C API got exposed to Python. And so thinking about the Python library that is basically Python calling Cython, which is just C at the end of the day, which then calls the C API, which then calls the Rust implementation",Interview P5,Directionality,1,,71,71,1,Author 1,8/9/23,Author 1,1/16/24
5:20,¶ 87,,"Yeah. Yeah. No, because you could, I think there's, it's called JNA, that it sort of dynamically loads the compiled binary and sort of introspects into the available functions and calls them as if it were a C library from Java. Yeah, kind of don't use it because you'll hit a wall in what you can do. And it's not quite as fast as JNI anyways. JNI in itself is already quite slow. You're talking about an order of magnitude slower is like 20, 25 times slower than calling a native Java function. ",Interview P5,"JNA, Limitation of Binding Tool",2,,87,87,1,Author 1,8/9/23,Author 1,1/16/24
5:21,¶ 97,,"Yeah. So within Rust and JNI it's all manual. I've actually hooked up the library for the, so within the client, client got rewritten. It already had a C header. So what I did is that I hooked up cbindgen so that I could double check that what I'm doing is actually the header that I have. Since all the header already had like sections and documentations and macros and things like that, whilst you could replicate most of it in cbindgen, handwritten code just tends to look nicer.",Interview P5,Generation VS Validation,1,,97,97,1,Author 1,8/9/23,Author 1,1/16/24
5:22,¶ 97,,It would be nice if there was tooling for both C and Java that tells you whether your FFI conforms to your expectations rather than necessarily tell you what you're expecting generated.,Interview P5,Wants Solution,1,,97,97,1,Author 1,8/9/23,Author 1,1/16/24
5:23,¶ 101,," Another thing which I don't like about cbindgen is just the compile time. It just adds another like 20 seconds of compile time, at least in my case because I have a library that doesn't actually have all that many dependencies and as soon as I pull cbindgen in it's like 20 seconds every time. So I just made it a feature and I switch it on whenever I want to and then I just diff the header and go from there.",Interview P5,cbindgen,1,,101,101,1,Author 1,8/9/23,Author 1,1/16/24
5:24,¶ 113,,So all of these FFI type things for the most part if they go wrong they tend to go horribly wrong and quickly wrong. So ironically that makes it among the least dangerous bugs that you can have. ,Interview P5,"FFI & Binding Bug, Mismatched Bindings or Declarations",2,,113,113,1,Author 1,8/9/23,Author 1,1/16/24
5:25,¶ 113,,You can probably end up talking to a security researcher that goes oh yes except for these cases and then you end up with a nice little overflow and blah blah blah and here you go someone took over your system. I'm sort of ignoring that for the best but yeah it's the usual case of write once code review three times.,Interview P5,Ignoring Security Issues,1,,113,113,1,Author 1,8/9/23,Author 1,1/16/24
5:26,¶ 131,,Yeah in the case you either have a linker error or you have an error whenever the symbol is locked up after a deal opens. This is assuming you get the error wrong. It's a little bit more fiddly if you get the signature wrong because now you're basically or if you get like the calling convention wrong then you're basically just sticking the wrong stuff in your registers and your stack before you actually call the function. So that would be harder to diagnose but usually it'll blow up pretty significantly and it's pretty easy to tell when it blows up that it did and then it's just a matter of going oh yeah of course I forgot that and then it's like two seconds to fix.,Interview P5,"FFI & Binding Bug, Mismatched Bindings or Declarations",2,,131,131,1,Author 1,8/9/23,Author 1,1/16/24
5:27,¶ 135,,I think one thing which is really cool about Rust is that it has this these marker traits like Send and Sync and things like that. Once you cross an FFI layer those are gone basically so it becomes trivially easy to make concurrency mistakes that you just wouldn't have been able to do if you just stuck to plain vanilla Rust. So that is one thing that maybe is a less obvious thing that you might get bitten at.,Interview P5,Different FFI Memory Model,1,,135,135,1,Author 1,8/9/23,Author 1,1/16/24
5:28,¶ 139,,So the way that I tend to structure code when I do FFI's is that there's generally a clear owner. So usually it's from the mutability point of view like you wouldn't you wouldn't expose fields you expose an API. I haven't really come across that.,Interview P5,Simple FFI,1,,139,139,1,Author 1,8/9/23,Author 1,1/16/24
5:29,¶ 153,,With more detail. Yeah so it's just one of those cases where it's it's unsafe code that you need to read like 10 times before you think is this even safe at all. But yeah this is definitely this is definitely something where the the memory model disparity is really obvious.,Interview P5,Unsafe is Difficult to Understand,1,,153,153,1,Author 1,8/9/23,Author 1,1/16/24
5:30,¶ 181 – 182,,"So I'm basically I'm basically completely breaking Rust's expectation because my my C object holds this Rust object a mutable it basically holds a field and then I just want to update it in place as if it were a moot self. But what I'm doing is basically taking it updating it and then putting it back in putting it back in practice so you have this pointer right back into the same location.

",Interview P5,Different FFI Memory Model,1,,181,182,2,Author 1,8/9/23,Author 1,1/16/24
5:31,¶ 141,,There are some things that are genuinely difficult to to quote-unquote write to unsafe your way out of what I mean by there's so if you have methods for example say you have a builder pattern in Rust it's quite common so that you can actually do builders in two flavors in Rust you can either do builders that take self mutate self and then return self so you basically daisy chain until it basically blips out of existence into the thing that you wanted at the end or you could have builders that take a mut self ref reference and then they only destroy the thing at the very end. Writing bindings for builders that take that basically move self along is really hard.,Interview P5,"Difficult FFI, Difficult to Encapsulate",2,,141,141,1,Author 1,8/9/23,Author 1,1/16/24
5:32,¶ 189,,"So I either, every time that I create something, so let's say I'm building an FFI I need to create something, the easiest way to to to build the API in a way that is semi-maintainable is to just return a pointer to an opaque object in C.",Interview P5,Opaque Pointer,1,,189,189,1,Author 1,8/9/23,Author 1,1/16/24
5:33,¶ 189,,my create will take a Box and basically my create will take a Box and basically leak it into and across the C FFI and then at some point the destroyer will take that pointer reconstitute it back into a Box and then drop the Box at the very end. So that's typical that's a typical usage of Box across an FFI. ,Interview P5,"Allocation in Rust, Box<T>",2,,189,189,1,Author 1,8/9/23,Author 1,1/16/24
5:34,¶ 189,,Then they for for an Rc/Arc so the Rc/Arc you sort of end up creating a Box of an arc and that is so that you can have an extra layer of indirection say for example that object the object's lifetime exceeds the the frame that I'm calling it from so I may have created it via this create and destroy pair of functions across the C interface or JNI interface or whatever it is the the the the technique is basically the same but at some point the rust code wants to extend the lifetime of that object and so to do that you basically have a root arc that the FFI owns that the foreign client owns and then if you want to extend that then you would do a clone and then that that basically lives this means that even even if even if the client code drops it sorry destroys it cause a destroy function before anything else then it's still alive for the duration of everything else ,Interview P5,"Allocation in Rust, Arc<T>/Rc<T>, Box<T>",3,,189,189,1,Author 1,8/9/23,Author 1,1/16/24
5:35,¶ 195,,You wouldn't be able to do it out of the box with the standard types. You wouldn't be able to do with an Rc/Arc. Okay yeah so you actually have to have a Box of an Rc/Arc it's a bit annoying it's not great for performance,Interview P5,"Arc<T>/Rc<T>, Box<T>",2,,195,195,1,Author 1,8/9/23,Author 1,1/16/24
5:36,¶ 211,,that make it to production tend not to be because of safety or at least the ones that are identified don't tend to be because of safety they tend to be logical errors so this for example I've had a bug report lately and that was one part of the code requires that all date times are epoch time stamps in in microseconds and they need to be signed integers sorry positive integers I always use unsigned for for daytime for consistency but in one part of the code it had to be you know after unix epoch 1970 january 1st,Interview P5,"Logical Error, Requirements Bug",2,,211,211,1,Author 1,8/9/23,Author 1,1/16/24
5:37,¶ 219,,Yeah bindings is always a fiddly mess and the reason for that is that you will inevitably have to at the very least duplicate signatures in two languages at the very least usually it's at the very least usually it's at least three often four times because you tend in practice what you tend to have is if say you're you're bridging language A and language B you would tend to have a high level implementation in language A a low level binding in language A for language B a low level implementation in language B and then a high level implementation in language B so because of that you basically have the same thing slightly different four times keeping those four versions of it in sync is often but not always aided between the tooling,Interview P5,Bindings are a Fiddly Mess,1,,219,219,1,Author 1,8/9/23,Author 1,1/16/24
5:38,¶ 227,,I think your your question was a little bit more generic than just um than just bindings um yeah i mean there's there's there's two things here there's there's obviously the the tooling aspect there's also the language itself aspect so there's there's cases where it would be nice to potentially maybe like slightly more formally document certain assumptions certain invariants or things like that um so I have code for example where where i use unsafe during um so I'm building from raster dynamic library um a whole bunch of unsafe wrappers for things which are only ever set once when the library is loaded so i kind of don't want to have locks afterwards so that's you know that's another use case of unsafe and you know does it really have to be unsafe isn't there a better isn't there a pattern around this so that i don't need to care about,Interview P5,Wants Solution,1,,227,227,1,Author 1,8/9/23,Author 1,1/16/24
5:39,¶ 231 – 232,,"So yeah i'll i'll be honest half time half the time i won't use a tool just because it'll take me so long to set up and i need to tweak the kernel parameters just to get it running and maybe I’m currently not on linux and good luck getting anything working on on those and and honestly just getting gdb working on the on on a mac is a pain and hassle in itself because lldb will work just fine but honestly i never remember all the arguments to it so yeah half of the time you'll just go okay can i just stare at this for another five minutes grab a coffee and then is that good enough so programmer laziness is um is yeah fights tooling unfortunately

",Interview P5,Laziness Fights Tooling,1,,231,232,2,Author 1,8/9/23,Author 1,1/16/24
5:40,¶ 237 – 238,,"Yeah there's there's actually one other problem that I forgot to mention, and I think this is genuinely a problem within, uh, within unsafe code, and that is lies. Um, what I mean by that is that sometimes you have safe wrappers to things that aren't safe, and actually this is really really really common, um, especially when you have libraries, Rust libraries that wrap, say, a C API, and to make it usable, it'll make a bunch of assumptions but those set of assumptions aren't actually correct, true, and valid. So now, it basically, so now it basically, it, it basically created a lie, quote unquote, that this is safe, when in actual fact, um, it isn't.

",Interview P5,"""Safe"" API",1,,237,238,2,Author 1,8/9/23,Author 1,1/16/24
5:41,¶ 249,,"So, you know, how do you guard against it? And it's like, well, usually it works, but the original, the original author of the Rust library thought it would work, but you, you basically have, you know you, you have no guarantees, so it's a trust layer, but sometimes those, those, the, the, the trust layer is, is buggy.",Interview P5,"""Safe"" API",1,,249,249,1,Author 1,8/9/23,Author 1,1/16/24
5:42,¶ 35,,"So if I know better, then I will happily put a little bit of unsafe code there. It depends what you want out of the language.",Interview P5,Tacit Knowledge,1,,35,35,1,Author 1,9/5/23,Author 1,1/16/24
5:43,¶ 59,,"Sometimes it's just plain obvious what's going on. And that's okay not to put a comment on it, but if it isn't, then yes.",Interview P5,Audience-Dependent Documentation,1,,59,59,1,Author 1,9/5/23,Author 1,1/16/24
5:44,¶ 101,,"But this code is more than just something that gets compiled in. It's a form of communication. So whenever you have something that you actually want to expose to thousands of people, then it's sort of useful to tweak that so it's nice and readable. ",Interview P5,Generation VS Validation,1,,101,101,1,Author 1,9/5/23,Author 1,1/16/24
5:45,¶ 243,,"So that is actually, I think I see why people do it. It's kind of necessary, um, and there's sort of no way around that, as there's no, no way to, to express this something as being, because it's like, you just infinitely label it as unsafe, um, and it's, yeah, like a standard thing would be like, something that loads up something as a memory map file, um, and then halfway through the C library just unmaps the file, but, and it gives, you have a reference to something that you thought was good, and then the whole thing dies.",Interview P5,"""Safe"" API, Difficult to Encapsulate",2,,243,243,1,Author 1,9/5/23,Author 1,1/16/24
6:1,¶ 3,,"So that has a lot of bugs in C++, like it's very error-prone. So at that point, I think it's 2019, and Rust is still relatively new, and this language and look at it, and I found, okay, this is probably, it's really promising, and it has a lot of tool, and it has security, a lot of memory safety guidelines, like a lot of things enforced by the compiler.",Interview P6,Memory Safety,1,,3,3,1,Author 1,8/9/23,Author 1,1/16/24
6:2,¶ 7,,"So for the Rust, you have to manage the lifetime, but in C++, you don't have that thing explicitly enforced by the compiler, but you still have to consider the lifetime, because those things are the critical to make sure that your programming, your memory is correct, but that is kind of optional in C++, and you have to do it after you have refunded bugs, but for the Rust, you have to consider that when you're writing the code, otherwise it won't compile.",Interview P6,Becoming the Borrow Checker,1,,7,7,1,Author 1,8/9/23,Author 1,1/16/24
6:3,¶ 7,,"So that's pretty good. And the other, the second, I think, is the toolchain, I would say, because in C++, you have a lot of choices, but they are not perfect. In Rust, like things are built, I would say the community is more focused on the safety of the programming of the language, so you go to, you have some tools, like easy access for like Miri, and also you have some concurrency checkers that I use in my development, which I found really, really helpful.",Interview P6,"C++ is Difficult, Preference for Safety",2,,7,7,1,Author 1,8/9/23,Author 1,1/16/24
6:4,¶ 19,,"So my specific scenario is I have a B-Tree, I can say we have a B-Tree end pointer, and we are going to point to, the pointer will point to either a leaf node or internal node. So there are different data structures. So only when you're reading that memory, you know what type it is. So in that case, I think there's no way in Rust that you can express them without any overhead.",Interview P6,Increase Performance,1,,19,19,1,Author 1,8/9/23,Author 1,1/16/24
6:5,¶ 19,,"And after that, I will do a transmute so that I know what exactly, how exactly I should interpret the rest of the memory. ",Interview P6,Transmute,1,,19,19,1,Author 1,8/9/23,Author 1,1/16/24
6:6,¶ 23,,"Yeah, so I was saying, for these kind of data structures, you really don't want to pay the extra overhead of, for example, dynamic dispatch, divide in Box, divide in something, because that's the eight byte point, that doesn't become like from eight byte pointer to a 16 byte pointer, which is not great for the high performance computing, et cetera. So that's not great. So you have to do some hack and do some, this kind of stuff. But this is really common in C++, so I kind of got used to it.",Interview P6,"Increase Performance, Shared Experiences",2,,23,23,1,Author 1,8/9/23,Author 1,1/16/24
6:7,¶ 31,,"I have to use UnsafeCell. So I use UnsafeCell because I have to get internal mutability. And I have to do that because, so we're writing lock free code. So lock-free code basically use atomic operations to do the concurrency, to ensure the concurrency, to, to protect the multiple writers, et cetera. ",Interview P6,"Data Structures, Primitives, and Operations, UnsafeCell<T>",2,,31,31,1,Author 1,8/9/23,Author 1,1/16/24
6:8,¶ 31 – 32,,"So in this scenario, you're going to read data that is unprotected. But you have to use a customized logic to make sure your data is, is consistent, is an intricate, but that kind of allow you to read the, uh, like dirty data. So in that case, you have to do the UnsafeCell to wrap the data so that you, so that the compiler will not do stupid things with data.

",Interview P6,UnsafeCell<T>,1,,31,32,2,Author 1,8/9/23,Author 1,1/16/24
6:9,¶ 47,,"And I look at, and at that point I learned that there's something called UnsafeCell. Okay, I feel, okay, I need to use it here to protect undefined behavior. But I don't know. I actually don't know if this actually works. Yeah, I mean, the UnsafeCell, like, whether it has an effect or if I just do it, it will probably work fine.",Interview P6,"Tacit Knowledge, UnsafeCell<T>",2,,47,47,1,Author 1,8/9/23,Author 1,1/16/24
6:10,¶ 51,,So I have some internal checks,Interview P6,Runtime Assertion,1,,51,51,1,Author 1,8/9/23,Author 1,1/16/24
6:11,¶ 51,,"I have been working on some open source roster applications for the most of the cases, I don't expose unsafe APIs, like, I'll say most of them are safe. So I have some internal checks and I'll put some wrappers around the unsafe code and we kind of reluctant to expose unsafe code, like API because that's kind of dangerous.",Interview P6,Exposing a Safe API,1,,51,51,1,Author 1,8/9/23,Author 1,1/16/24
6:12,¶ 71,,"ParticipantLike a bounds check, like, what is that? And also, sometimes I would do alignment check, because we're dealing with, we sometimes ensure that your pointer passing in this, like, properly aligned.",Interview P6,Runtime Assertion,1,,71,71,1,Author 1,8/9/23,Author 1,1/16/24
6:13,¶ 79 – 80,,"Yeah, so the ManuallyDrop, I think is I want to prevent. And yeah, so I think ManuallyDrop is basically associated with use of MaybeUninit. So you have a, so you have, in a struct, you have a field that may not be initialized at the time of the construction. And I forgot exactly how to use that. But yeah, there's a scenario where I have to do that, because in initialization time, there's not available. And, and I, at that time, I also cannot use Option something, because Option something will make it larger.

",Interview P6,"Increase Performance, ManuallyDrop<T>, MaybeUninit<T>, Option<T>",4,,79,80,2,Author 1,8/9/23,Author 1,1/16/24
6:14,¶ 83,,"if I think of like a ManuallyDrop case that I use, is that when I have a data structure that is a linked list, something like a link list. And if you, if you automatically drop, then if the link list is the chain of link list is really long, then you're going to drop from the end of the chain. So you start, you start from distracting, distracting, and you push every, every data structure, like every data structure on the stack. And until you reach the end of the chain, that drop will happen. And then you're going to pop up all all the items, all the strats, like pop all the strats, and we call the drop. So in this case, we want to enforce like a drop order, so that it will not have some stack overflow. In that case, we just manually drop.",Interview P6,"Increase Performance, ManuallyDrop<T>",2,"For Author 1: does preventing a stack overflow really count as ""Increase Performance""? Seems more similar to ""No Other Choice"" in this case.",83,83,1,Author 1,8/9/23,Author 1,1/16/24
6:15,¶ 91,,"I think, well, I forgot to say that my use case is unwrap a Box. So my case is, yeah, so sometimes we need to get the raw pointer and you can do the allocation a lock, but you can also do a Box and then unwrap it. I think they're the same. So yeah, I use them interchangeably.",Interview P6,Box<T>,1,,91,91,1,Author 1,8/9/23,Author 1,1/16/24
6:16,¶ 91,,"But for me, I think it's not a big, I haven't found bugs involved with that property because I use address sanitizer. Because I think this kind of bug is quite easy to check because if you leave memory, then you don't immediately be checked. And yeah.",Interview P6,"ASAN, Memory Leaks Aren't an Issue",2,,91,91,1,Author 1,8/9/23,Author 1,1/16/24
6:17,¶ 95,,"And like in our application, we actually have our customized allocator. So it's not like we call allocator all the time. We will have, because allocator, like the system allocator is really slow. And in the very high performance applications, you don't want to call the system allocator all the time. ",Interview P6,"Custom Allocator, Increase Performance, Performance is Necessary",3,,95,95,1,Author 1,8/9/23,Author 1,1/16/24
6:18,¶ 95,,"But in that case, you cannot use Box, because once you bought it, if you deallocate that portion of the memory, then I think that's a good thought. And so basically, that essentially says that we cannot use Box in our application because we use our own allocator. Yeah. And to do that, we actually have some like a wrapper around this kind of thing, like a similar to Box, on Box.",Interview P6,"Box<T>, Increase Performance, Unsafe Data Structure",3,"For Author 1: just to check, is this ""Increase Performance"" because the same interviewee earlier stated that the reason for having their own allocator is increased performance?",95,95,1,Author 1,8/9/23,Author 1,1/16/24
6:19,¶ 103,,"So to generate the bindings, I think it mostly works fine because C is really simple and it's pretty straightforward. But what you get is very unsafe functions. You have to do all the stuff that's unsafe and it's pretty error prone because you always have to use the C types and use the C function unsafe every time. That's not great.",Interview P6,"Bindings are a Fiddly Mess, Generation VS Validation, Preference for Safety",3,,103,103,1,Author 1,8/9/23,Author 1,1/16/24
6:20,¶ 103,,"My major use case was previously was to generate C++ bindings for Rust and that is really challenging because C++ is really complex. And at that time, CXX was still in the early stage. But I don't know what the current state of the CXX is. At that time, I feel that library has a really smart idea and it really works. But when you scale up, so when you have to deal with a really complex C++ library, that can be quite challenging even with CXX. And I think the major goal of CXX is not to generate binding for C++ projects. It's more of you develop some part of your coding C++ and also you develop some part of a coding Rust so that they can coexist.",Interview P6,"CXX, Limitation of Binding Tool",2,,103,103,1,Author 1,8/9/23,Author 1,3/18/24
6:21,¶ 111 – 112,,"I think I was concerned about this. So I was clear and that's why I didn't go that way because I tried to write bindings and I found there are so many complicated things I have to deal with. For example, the allocation, the deallocation, the alignment and the different typing system. And yeah, a lot of things that are really complex and challenging. So yeah, I was scared. So I didn't do that way. I tried and I have some samples working. But to the scale of my application, which is database system, I feel that's too much overhead, too much mental burden for me.

",Interview P6,Bindings are a Fiddly Mess,1,,111,112,2,Author 1,8/9/23,Author 1,3/18/24
6:22,¶ 119,,"And so calling foreign function is not their overhead. And you have to use linking time optimization, which is really slow itself, like compile time, double or triple or compile time. It's not great.",Interview P6,Linking Time Optimization (LTO),1,,119,119,1,Author 1,8/9/23,Author 1,3/18/24
6:23,¶ 131,,"Okay, so I think the first thing is allocator. allocator is really complex because theoretically, you cannot assume that you will see application and Rust application are using the same allocator. And that is definitely you cannot do that. But in practice, sometimes you have to, in practice, our high-performance applications have used some runtime overrides of the allocator. So they will override your default system allocator with some more high-performance allocator, for example, jemalloc. In that case, because the C and the Rust are both compared to the same machine code. And when you reference to the allocator, they actually reference the same allocator. So when you replace that allocator, you actually point to the same allocator. So yeah, that caused confusion to people. When you say, okay, you are not a different allocator, but in fact, it is.",Interview P6,"Allocation & Alignment Bug, Deallocate Foreign Memory in Rust",2,,131,131,1,Author 1,8/9/23,Author 1,3/18/24
6:24,¶ 147,,"when I read, whenever I read the data, I need to first check the version number. And after read it, I need to check the version again, make sure that it's correct. And then on top of time, I just forget to check that again. And when I forget to check it, it's definitely a bug.",Interview P6,"Concurrency Bug, Data Races",2,,147,147,1,Author 1,8/9/23,Author 1,3/18/24
6:25,¶ 147,,"But I haven't found out, like, there are, there are, there are some optimistic concurrency control library in Rust, but they are not really, they're overhead. So you actually pay some overhead with, like, all kinds of stuff. So I cannot use them because our system really cares, cares performance about that",Interview P6,Increase Performance,1,,147,147,1,Author 1,8/9/23,Author 1,3/18/24
6:26,¶ 163,,"So whenever I do an insert operation, I will insert my post to standard library B-Tree and my B-Tree. And I will check if their, their return value is correct. Like, if they're return value is the same. So if they behave differently than them, definitely take a bug",Interview P6,"Fuzzing, libfuzzer",2,,163,163,1,Author 1,8/9/23,Author 1,3/18/24
6:27,¶ 167,,"And I think Clippy is a very low-high influence you can get because it's really helpful. But I think that is like the remaining of our synthetic, like a static level. So cannot do a lot of things, but it definitely checks some patterns, your code that is not great. It's not for readable or, I don't think it can capture bugs, but it definitely makes your code more readable.",Interview P6,"Clippy Doesn't Find Bugs, Clippy for Clean Code",2,,167,167,1,Author 1,8/9/23,Author 1,3/18/24
6:28,¶ 7,,"So that will basically eliminate a very large portion of my bugs that is used like using the stack pointers, like written on a stack pointer of your function, so that will not happen. That turns out to be one of the most frequent bugs that I wrote when I was writing in C++.",Interview P6,C++ is Difficult,1,,7,7,1,Author 1,9/5/23,Author 1,1/16/24
6:29,¶ 7,,"I also use AddressSanitizer in C++, that's not really helpful because I'm dealing with lock-free developing. So yeah, so that sort of analyzer will not help you with a lock-free programming, but in Rust, you have some tools recently, I think last year, AWS shuttle, which I found extremely helpful. ",Interview P6,"ASAN, AWS Shuttle",2,,7,7,1,Author 1,9/5/23,Author 1,1/16/24
6:30,¶ 47,,"Like, in the beginning, I was not using UnsafeCell and I believed it caused problems. But, but later I, like, I searched around because at that time I'm still like a new learner. So I didn't know how to correctly use that. And I read some document and look at some referencing presentation or call you to the low level concurrency",Interview P6,Engaging with the Rust Community,1,,47,47,1,Author 1,9/5/23,Author 1,1/16/24
6:31,¶ 55,,"But most of the cases, we will have some wrappers, for example, like in C API, you probably have some lock and unlock, and that is unsafe because you're directly operating on the lock. So we're going to develop, we're probably going to add a wrapper for them like the lock guard, like on top of the raw lock and unlock manually.",Interview P6,Exposing a Safe API,1,,55,55,1,Author 1,9/5/23,Author 1,1/16/24
6:32,¶ 59,,"Yeah, but I was, they just have some overhead like runtime. I'll also add the check.",Interview P6,Runtime Assertion,1,,59,59,1,Author 1,9/5/23,Author 1,1/16/24
6:33,¶ 95,,"I think there are cases when we need to handle string in front of another language. For example, when I do a string between Rust and Python. So Python string, like you pass a Python string to Rust and you use it and you cannot deallocate it because otherwise you just break Python. So you have to give back, like give back to Python. And I think that's the case where we have allocation where, because the memory is not from Rust, it's from another language. And you have to make sure that you're not accidentally deallocated.",Interview P6,Different FFI Memory Model,1,,95,95,1,Author 1,9/5/23,Author 1,1/16/24
6:34,¶ 119,,"And also, I want to say about FFIs, it's really difficult to get correct. Even to get a real working demonstration because C and C profiles are really complex building systems. You can do Bazel, you can do CMake, you can do make, and to compile things and to deal with the name mangling. And you need to correctly link things and stuff. That's just not great. I think I have a demo to set up this kind of linking. And that's really complex. And the people have been found useful, but I personally think very few people can really get it correct.",Interview P6,Bindings are a Fiddly Mess,1,,119,119,1,Author 1,9/5/23,Author 1,3/18/24
6:35,¶ 135,,"Yeah, that's tricky. But we basically just don't want to do that. Yeah, because that is too tricky",Interview P6,Simple FFI,1,,135,135,1,Author 1,9/5/23,Author 1,3/18/24
6:36,¶ 135,," Rust has official support for libc. So they have good documentation if you call this function, you have to make sure several things in Rust. That's really helpful",Interview P6,Engaging with the Rust Community,1,,135,135,1,Author 1,9/5/23,Author 1,3/18/24
6:37,¶ 147,,"So, yeah, actually, I haven't figured out a way to make me to like, for example, check the version number before reading and then check the version number again after reading. This kind of bug happens a lot.",Interview P6,Contract or Invariant,1,,147,147,1,Author 1,9/5/23,Author 1,3/18/24
6:38,¶ 147,,"And I was using the, like, the shuttle, the shuttle library had talked before. I used that to detect that, okay, this is not, this is bug. I cannot do it myself, because it's really difficult to reason about. And I was not totally unaware of this kind of unprotected read.",Interview P6,"AWS Shuttle, Unsafe is Difficult to Understand",2,,147,147,1,Author 1,9/5/23,Author 1,3/18/24
6:39,¶ 167,,"And memory sanitizer, oh, I forgot. I actually use address sanitizer more. And the memory sanitizer is mostly about, I think I'm leaking, memory leak. Yeah. Because those sanitizers are incorporated into the fuzzer. So when I run the fuzzing, like libfuzzer, it will like enable the sanitizer by default.",Interview P6,"ASAN, Fuzzing, libfuzzer, MSAN",4,,167,167,1,Author 1,9/5/23,Author 1,3/18/24
6:40,¶ 167,,"Miri is more limited because I have to deal with a lot of IO operations and a lot of functions that are not supported by Miri. At least the time I'm using it. And it's pretty useful. So it's both the speed and the fact that Miri is not, like it just doesn't support the types of functions that you need.",Interview P6,"Miri doesn't support this feature, Miri is slow",2,,167,167,1,Author 1,9/5/23,Author 1,3/18/24
6:41,¶ 175,,"I have an integer overflow bug, which, in my case, I have a counter. And the counter to save space, I use U8. So it's a very tiny one byte data. And I think that should be enough for the most of cases. And it is enough for the most of cases. But with shuttle, you kind of will test with some extreme scheduling. And in that case, it will trigger the bugs. That's a, in my case, it actually will, I think the overall flow. So that, I think that is a case where it's almost impossible for me to test during my development. It can only be unveiled using this kind of tools.",Interview P6,"Concurrency Bug, Integer Bounds & Overflow Bugs, Integer Overflow",3,,175,175,1,Author 1,9/5/23,Author 1,3/18/24
6:42,¶ 191,,"So yeah, at least for my version, I don't think fuzzing can do the permutation for me. So I can only test with single thread. Like, I mean, the single thread version, but you can run multiple instance of the testing, but they don't interact with that. They don't have concurrency things happening. So I use fuzzing tool to make sure my single thread version is correct. And I use a shuttle to make sure that, at least to get the idea of how correct it is for my multi thread version.",Interview P6,"AWS Shuttle, Fuzzing",2,,191,191,1,Author 1,9/5/23,Author 1,3/18/24
7:1,¶ 3,,"I guess I was curious and I just picked it up out of curiosity and then I continue using it because it kind of like the type safety, low level access, all that kind of stuff kind of lines up with my way of thinking and like the way I like to write code. So type safety, immutability, all that sort of stuff.",Interview P7,"Low-Level Access, Memory Safety",2,,3,3,1,Author 1,8/9/23,Author 1,1/16/24
7:2,¶ 15,,"There's other ones about like, sometimes you have to implement like unsafe interfaces or like you might have to roll your own primitives or I don't know, something, I don't know, like say you have to do use futures and you have to write your own future and you have to use unsafe because of pinning or whatever or, you know, like, what else?",Interview P7,"Data Structures, Primitives, and Operations",1,,15,15,1,Author 1,8/9/23,Author 1,3/18/24
7:3,¶ 31,,"I try and hide it just for, like you try it just because that way it's that way I can control everything. I don't really want to have to trust because once you open it to the user, then you have to start worrying about a lot more stuff like, I don't know, but you have to rely on them to actually uphold your promise, like, yes, sure, you call it an unsafe trait. So in theory, the burden of proof is on them, but also like if they implement something improperly, then they're going to create a ticket because they'll be like, oh, I use your library and it's a fault. And then, you know, so even though you say, yes, it's your fault, they still, like, you can't shift all of the burden onto the user. So it's easier to encapsulate everything.",Interview P7,"Engaging with the Rust Community, Exposing a Safe API",2,,31,31,1,Author 1,8/9/23,Author 1,3/18/24
7:4,¶ 39,,"So when the audience is, like, internal, then you can be lazy. When it's public, you'll want to have, you know, proper, you know, like, how you have the unsafe section of your documentation. And you'll say, like, you know, these are the assumptions, like, or whatever. It's used, assumptions are usually around lifetime of objects, like if you're using, or like, say I've got a pointer, how long does that pointer go into live for? Like is it okay for the implementation to stash away a copy of that pointer, or does it have to, you know, it's invalid by the end of the function call, or, you know, just random things like that. But yeah, usually, yeah, it's dependent on your audience.",Interview P7,"Audience-Dependent Documentation, Documented Contract or Invariant",2,,39,39,1,Author 1,8/9/23,Author 1,3/18/24
7:5,¶ 43,,"Oh, FFI. I need to allocate something. I do Box new, Box into raw, pass the pointer across, and then in, you know, you'll have like a destructor function in Box from raw, and drop it, easy and stuff like that. ",Interview P7,"Allocation in Rust, Box<T>",2,,43,43,1,Author 1,8/9/23,Author 1,3/18/24
7:6,¶ 43,,"MaybeUninit is also like an FFI thing, like, you know, how C likes to use out pointers, so like, you'll do a MaybeUninit on the stack, and then you'll pass it into the function, it'll do the initialization, and then you do assume afterwards.",Interview P7,"MaybeUninit<T>, Return Pointers",2,,43,43,1,Author 1,8/9/23,Author 1,3/18/24
7:7,¶ 47,," But because at C, you want all your methods to take a, not immutable, a shared reference to self, because pretty much all C functions make assumptions that it's shared pointers. So you want those semantics, but even though technically, yes, you're mutating, you don't want that unique access part of, you know, mutable reference. So that's where UnsafeCell can come in. It can let you preserve the C semantics of, you know, shared access, and, you know, still do mutations, all that kind of stuff.",Interview P7,"Different FFI Memory Model, UnsafeCell<T>",2,,47,47,1,Author 1,8/9/23,Author 1,3/18/24
7:8,¶ 55,,"something I do a lot in personal projects is, I might like wrap a C library.",Interview P7,Rust Bindings for a C Library,1,"For Author 1: shouldn't this also be ""Personal Tools & Toy Projects""?",55,55,1,Author 1,8/9/23,Author 1,3/18/24
7:9,¶ 59,,"It's, you end up have, when you, it depends on the language, like some languages have like PyO3, which gives you nicer ways to do things, like, you know, wraps a lot of the unsafe, but you have like other languages where you have to write like going from Rust to the C API, and then from the other language down to the calling into the C API. So you have to, so it kind of sounds like it's unidirectional, but you have to do both sides of the bindings.",Interview P7,Directionality,1,,59,59,1,Author 1,8/9/23,Author 1,3/18/24
7:10,¶ 75,,"Bindgen, yeah, it's kind of like the overall, you know, the tool works quite well. There are some, like, you do run into some build issues on like, you've got the decision, do I commit, do I generate my binding statically, and then publish those, or do I generate them in a build script? And generating them in a build script is best because then you get bindings for exactly your architecture. So like, say the library, you're calling into changes API, depending on Windows or Mac or Linux or whatever, then, you know, you use, if you run Bindgen inside the build script, then you can, you know, you get, you get the correct symbols, the correct, the correct bindings for the architecture. ",Interview P7,Generation VS Validation,1,,75,75,1,Author 1,8/9/23,Author 1,3/18/24
7:11,¶ 75,,"But it's a real pain because you now have to add Bindgen as a dependency. And Bindgen pulls in LLVM, and LLVM is a gigantic pain as a dependency because you can have multiple incompatible versions of LLVM. I've had lots of situations where, like, you have two dependencies that pull in, say they both pull in Bindgen, Bindgen pulls in LLVM, LLVM pulls in llvm-sys, you can't have two incompatible versions of llvm-sys, otherwise you, cargo says, says no. And then you end up in like an impossible situation where you have to like, either fork an upstream project or make a pull request so that it's using the exact same version like for all dependencies, if that makes sense.",Interview P7,"bindgen, Limitation of Binding Tool",2,,75,75,1,Author 1,8/9/23,Author 1,3/18/24
7:12,¶ 87,,"I would, no, I would not write it manually. Like, I wouldn't write, I wouldn't write it manually for anything other than like something trivial and hacky. So just like trying something out. And then once it's like, you know, bigger than like a couple of lines, like a couple of functions, you're not going to want to do that manually. So it's just better to, you know, I've got a header file, I just throw, throw the header file at bindgen, bindgen gives me some stuff. And then I can wrap that stuff.",Interview P7,Generation VS Validation,1,,87,87,1,Author 1,8/9/23,Author 1,3/18/24
7:13,¶ 91,,"No, I wouldn't. I don't think I've ever had to. And even then I would, I would be very, like if it was either myself or a co-worker that was having to go in and modify bindgen generated stuff, I would be asking questions because that's really bad from long-term maintainability perspective, because then header file updates, you regenerate your bindings, you've lost your changes. ",Interview P7,Generation VS Validation,1,,91,91,1,Author 1,8/9/23,Author 1,3/18/24
7:14,¶ 99,,"You just, I don't know, it's just like encapsulation, make sure you're, you write your APIs and like, it's as long as you keep everything high level, which you'll want to do anyway. So if, if it's very high level, it's a very easy to encapsulate those problems go away. ",Interview P7,Simple FFI,1,,99,99,1,Author 1,8/9/23,Author 1,3/18/24
7:15,¶ 99,,"Even for low level stuff, like if it's, if you've got a very chatty API that jumps between Rust and C a lot, things get a bit more difficult there. But usually you would hide that in like a single module that's, you know, just fall to the brim of unsafe.",Interview P7,"Local, Minimal Unsafe",1,,99,99,1,Author 1,8/9/23,Author 1,3/18/24
7:16,¶ 99,,"Like you've got MaybeUninit, you've got UnsafeCell, you know, you can, when in doubt, just throw another level of indirection at the problem and usually it goes away.",Interview P7,"MaybeUninit<T>, Tacit Knowledge, UnsafeCell<T>",3,,99,99,1,Author 1,8/9/23,Author 1,3/18/24
7:17,¶ 99 – 100,,"And if you're, yeah, if you're getting to situations where you have to know the, like where the memory models are different enough that things are like, if you're getting to that point where it's a bit concerning, then you're, you probably need a really good reason to continue. Like, and, you know, you should be stepping back and being like, okay, why do I need to get down? Why do I have to worry about this? From, an engineering designs perspective.

",Interview P7,Simple FFI,1,,99,100,2,Author 1,8/9/23,Author 1,3/18/24
7:18,¶ 107,,"I'm generally not a fan of, so you know how a function could take like a, say there's a C function that takes a pointer. I'm not normally a fan of rewriting it so that the rust version of it takes in like an Option reference because then C is thinking it's a pointer and then Rust is seeing it's an Option reference. And yes, those to a 100% ABI compatible. And I, like, you know, it's safe and correct to do that, that little transformation. But I feel like it's almost better to leave it as a pointer. Because then it's like everyone knows that this is like we're dealing with, you know, like we're dealing with pointers here",Interview P7,"Option<T>, Simple FFI",2,,107,107,1,Author 1,8/9/23,Author 1,3/18/24
7:19,¶ 111,,I would say I want the function that the C library exposes should have the same like I should be able to look at the header file in C and then look at the the extern C block in rust and see that these two signatures are identical.,Interview P7,Simple FFI,1,,111,111,1,Author 1,8/9/23,Author 1,3/18/24
7:20,¶ 119,,"And then that's it. So like there was no memory leaks in that way. And so one of the things I did was I made an allocator which just wraps dlmalloc, which is the one we're using. I wrapped we alloc at the time. And then I was printing the address of the pointers and the size. And I was seeing that you know, the way we alloc allocates memory causes fragmentation, ",Interview P7,Custom Allocator,1,,119,119,1,Author 1,8/9/23,Author 1,3/18/24
7:21,¶ 119,,"Other times is for like statistics. So I just want to be able to tell people, you know, you allocated, you know, the maximum memory you allocated was 10 megabytes or whatever. ",Interview P7,Custom Allocator,1,,119,119,1,Author 1,8/9/23,Author 1,3/18/24
7:22,¶ 123,,"Stats tracking and like printing out thing allocations, like whenever an allocation is done, that's for that's kind of like the printf style debugging. So it's quick and dirty. You know, it's only like 30 lines. Most of it can be generated by Rust analyzer anyway",Interview P7,Printf-Style Debugging,1,,123,123,1,Author 1,8/9/23,Author 1,3/18/24
7:23,¶ 131,,"So my first job, I was working at a company that builds CNC machines for cutting foam.",Interview P7,Manufacturing,1,,131,131,1,Author 1,8/9/23,Author 1,3/18/24
7:24,¶ 131,,"And I can't, it was, the root problem was that I had improperly defined the type on the Delphi side. So the equivalent of my extern C block, I'd written the function incorrectly. So, you know, Rust, the function might take like a, like an integer, an integer and a pointer. And on the Delphi side, I'd only said this function takes an integer and a pointer.",Interview P7,"FFI & Binding Bug, Mismatched Bindings or Declarations",2,,131,131,1,Author 1,8/9/23,Author 1,3/18/24
7:25,¶ 139,,"And because I was writing the bindings on the Delphi side by hand, because bindgen can output, cbindgen can output a header file, which is fine, except Delphi doesn't use her C header files. So, so like there is a automated solution, but it only works for C, or things that can consume C, like Python C FFI. ",Interview P7,Generation VS Validation,1,,139,139,1,Author 1,8/9/23,Author 1,3/18/24
7:26,¶ 147,,"I've just got a bunch of bytes, and then I've, I've cast it to a pointer to whatever. And if those bytes came from a file, sure, my struct will contain a field, you know, which contains a pointer, but that pointer points to garbage now, because, you know, it was written by a different process.",Interview P7,"Incorrect Type Casting, Temporal Memory Bug",2,,147,147,1,Author 1,8/9/23,Author 1,3/18/24
7:27,¶ 173,,"So the type system is, oh, you know how like with Rust, if it compiles, it works? Like in the, in a previous job, where I was using C sharp, I'd literally use a debugger like two or three times a day. And I'd be constantly stepping through my code in C sharp, Visual Studio. And Rust, because I've probably had to use a debugger like in maybe once a year for Rust code. ",Interview P7,"If it compiles, it works",1,,173,173,1,Author 1,8/9/23,Author 1,3/18/24
7:28,¶ 181,,"I guess one I haven't mentioned is Miri. So Miri is awesome. There's one pain point. It's that it's not terribly useful when it comes to FFI, because it obviously can't interpret like C code. Like any other insurmountable things. ",Interview P7,Miri doesn't support this feature,1,,181,181,1,Author 1,8/9/23,Author 1,3/18/24
7:29,¶ 191,,"I can't think of any, I guess one problem would be like, there's a lack of, not writing unsafe, but the culture around unsafe is that everyone's like unsafe is the boogeyman. And it's like, you know, it's like people have either like the laissez-faire like, oh, I write, I've been writing C for 20 years, so I know what I'm doing. And then they proceed to do something stupid. Or you almost in reaction to that and to rust like desire for safe interfaces is that people are like, they try and shy away from it. And like they, any, any code that uses unsafe is like, like heavily, like unnecessarily, like criticized. So it's like this code, or yeah, I don't know how to, it's like it's unsafe can be demonized in a way. ",Interview P7,Stigma Against Unsafe,1,,191,191,1,Author 1,8/9/23,Author 1,3/18/24
7:30,¶ 187,,"But sometimes you can get to a point where you try and abstract things so much that now if there's any bug in the tool, like say the tool generates a slightly wrong thing, it's a gigantic pain to track down. And sometimes you, like when you're writing code, and you know, you're like, Oh, I do the same sort of logic three or four different times, like, you know, like if pointer is null return null, or, you know, something sort of things like that. People get tempted to abstract things out. And then the FFI code or the unsafe code itself, by introducing abstractions, becomes harder to read and reason about because now I don't just have all of my code in one function, like say it's 40 lines. Now I have to, it's now 10 lines or 15 lines, but I have to like manually inline all the functions that it calls to understand what's going on",Interview P7,Difficulty with Generated APIs,1,,187,187,1,Author 1,8/9/23,Author 1,3/18/24
7:31,¶ 211,,"You see it on the user forums every now and then, like the kind of knee jack reaction. Or like someone's wanting to learn this stuff. So of course, you know, you're wanting to, you're trying to learn how, how do I write this unsafe interface? Or how do I like, I'm writing some code and I need to do like unsafe impulse send or unsafe impulse sync. And then, you know, because I'm, I'm trying to learn as part of that process. And of course, you get a right code to, to learn. And then people kind of jump on that and like, they can be very hard on them, if that makes sense.",Interview P7,Stigma Against Unsafe,1,,211,211,1,Author 1,8/9/23,Author 1,3/18/24
7:32,¶ 215,,"but it is a bit of a culture thing, just because sometimes people take the whole safety thing a bit too far. And don't realize that, you know, sometimes people are learning, sometimes it's for pragmatic reasons. You know, sometimes it's just because I write unsafe because, you know, I didn't know that was a better way or something like that. So there's a bit of a culture thing going on there.",Interview P7,"Preference for Safety, Stigma Against Unsafe",2,,215,215,1,Author 1,8/9/23,Author 1,3/18/24
7:33,¶ 15,,"I've written a couple of like allocators or sometimes you might need it for like a data structure you want to write,",Interview P7,Custom Allocator,1,,15,15,1,Author 1,9/5/23,Author 1,3/18/24
7:34,¶ 39,,"So there's kind of a distinction between, like, items that will be used by users directly and items that will be used by other crates within the project. So it's kind of like, you have to choose, you have to understand what your audience is. So if it's, if my audience is other people working on my projects, like my coworkers, you can kind of be slack there and just, like, leave it undocumented, because we know the code works. And you can talk to someone about it. And generally, you know, like, oh, you know, [name]’s the owner of that area of code. So if I have problems, I talk to them.",Interview P7,Audience-Dependent Documentation,1,,39,39,1,Author 1,9/5/23,Author 1,3/18/24
7:35,¶ 35,,"And a lot of the time you'll only expose, like, really low-level things as unsafe.",Interview P7,Exposing an Unsafe API to Users,1,,35,35,1,Author 1,9/5/23,Author 1,3/18/24
7:36,¶ 67,,I've dabbled with CXX. I like the way it does things.,Interview P7,CXX,1,,67,67,1,Author 1,9/5/23,Author 1,3/18/24
7:37,¶ 83,,"And also, all of this adds to build times. So you, you really want it in your build script, but it's, it's a really painful, like a heavy dependency and it, yeah, and it's, it can be painful to, to use to manage versions. I can't remember what the cross compilation story is like, but knowing, like, native libraries, it's probably, actually no, it wouldn't matter. Yeah. I don't know. Cross compilation can sometimes be a pain, especially when native libraries are involved.",Interview P7,"bindgen, Limitation of Binding Tool",2,,83,83,1,Author 1,9/5/23,Author 1,3/18/24
7:38,¶ 91,," So I, if I had to have a situation like that, I would, I don't know, make a ticket to bindgen or, I don't know, I'd just figure it out.",Interview P7,Engaging with the Rust Community,1,,91,91,1,Author 1,9/5/23,Author 1,3/18/24
7:39,¶ 15,,"I normally don't, you know, I don't bother writing data structures from scratch. I'll just use the library.",Interview P7,Preference for Safety,1,,15,15,1,Author 1,9/5/23,Author 1,3/18/24
7:40,¶ 169,,"Generally, I don't know, I'm sure that they're very helpful. I don't know, I don't really run into the lints to, I don't trigger the lints too often. But I think it's just because like I write lints, the code likes, sorry, I write code that the lints like.",Interview P7,Clippy Doesn't Find Bugs,1,,169,169,1,Author 1,9/5/23,Author 1,3/18/24
7:41,¶ 177,,"Yeah. And because like not everyone has that setup, because like you barely ever have to use debuggers in Rust, like that can be annoying, because then you've got to look up the documentation or copy from someone else.",Interview P7,Engaging with the Rust Community,1,,177,177,1,Author 1,9/5/23,Author 1,3/18/24
7:42,¶ 181,,"So there is a crate called, I think it's like safer FFI, and which is really helpful because it gives you like derived macros. So I can write the safe code, the code safely, and then it will like wrap it in unsafe into argument transformation. ",Interview P7,safer-ffi,1,,181,181,1,Author 1,9/5/23,Author 1,3/18/24
7:43,¶ 199,,"So there's a Actix web a couple of years ago. So the original author of Actix web kind of did a couple of dodgy things with unsafe. And, and then people saw like people made tickets about it. And like the whole thing turned into a bit of a witch hunt. And so the original author of Actix web basically abandoned the whole community. ",Interview P7,Stigma Against Unsafe,1,,199,199,1,Author 1,9/5/23,Author 1,3/18/24
8:1,¶ 5,,I guess the trigger was I saw it was always the most loved language in the survey. I thought I'm going to find out at least what this is about. And in time it did actually provide a lot of answers to the problems that have been struggling with for years where concurrency and multithreading have been involved.,Interview P8,Fearless Concurrency,1,,5,5,1,Author 2,8/23/23,Author 1,1/17/24
8:2,¶ 33,," I bumped the number of worker threads to 10 or whatever number it was, ran these tests concurrently, all tests passed, and I immediately shipped this version to the client. And it worked flawlessly. There was not a single concurrency bug or anything that you'd kind of, in C and C++, you'd kind of expect that someone's down the road to report funny issues that were impossible to debug. There was none of that.",Interview P8,Fearless Concurrency,1,,33,33,1,Author 2,8/23/23,Author 1,1/17/24
8:3,¶ 29,, large amount of seismic data that we wanted to process change another format,Interview P8,Data Processing & Serialization,1,,29,29,1,Author 2,8/23/23,Author 1,1/17/24
8:4,¶ 41,,"So this seismic thing did work on both the data acquisition hardware, which was STM-based, just microcontroller collecting data",Interview P8,Operating & Embedded Systems,1,,41,41,1,Author 2,8/23/23,Author 1,1/17/24
8:5,¶ 41,,". And so I'd always be in there debugging the code, finding bugs that other people couldn't really pinpoint. It was a usual suspects, forgetting to take a mutex, that kind of thing, or using the wrong locking or not using any locking at all. All the stuff that Rust would prevent you from doing.",Interview P8,"Concurrency Bug, Data Races",2,,41,41,1,Author 2,8/23/23,Author 1,1/17/24
8:6,¶ 41,,"And so a lot of the unsafe uses, just because of the ecosystem on embedded, sometimes not all the hardware stuff is implemented. So like the most common use case is that there's some particular memory map device that I need to do, configure in a certain way. And the available hardware abstraction layer doesn't provide that functionality.",Interview P8,"Interacting with hardware, No Other Choice",2,,41,41,1,Author 2,8/23/23,Author 1,1/17/24
8:7,¶ 63,,"Yeah, this is really low level stuff where you're actually writing into the re allocating a vector table for the CPU. What's going on here. I'm not enabling a DMA for some reason. Reboot magic. So this microcontroller, it will, it doesn't erase the RAM during reboot. So then I have certain sequences that okay, say you want to update you want to flash other firmware or you want to go into sleep mode. And this handle is just write a magic value to RAM. And then when I boot up by check, okay, what is this this magic value. So I just use this maybe on in it. I guess you need unsafe to access that. ",Interview P8,"Contract or Invariant, Interacting with hardware",2,,63,63,1,Author 2,8/23/23,Author 1,1/17/24
8:8,¶ 67,,"I'm not happy with writing unsafe code. You know, I try and I try to keep it at a minimum but it just like, you know, certain things tend to be unavoidable.",Interview P8,"Local, Minimal Unsafe, Preference for Safety",2,,67,67,1,Author 2,8/23/23,Author 1,1/17/24
8:9,¶ 67,," in general, it's cases where you're interfacing with the hardware on a level where I mean, once you start writing magic. The hardware abstraction layer should be, you know, in some cases the hardware abstraction layer is unfinished. And so I just go around it. ",Interview P8,No Other Choice,1,,67,67,1,Author 2,8/23/23,Author 1,1/17/24
8:10,¶ 67,,"In other cases, even if it is in the and you can use your hardware abstraction layer it is kind of unsafe what you're doing so putting it in an unsafe block I think is entirely appropriate.",Interview P8,As Documentation,1,,67,67,1,Author 2,8/23/23,Author 1,1/17/24
8:11,¶ 75,,"So, so for instance, you know, I have a microcontroller, it's got a bunch of pins and say I want to put a serial port, configure it to certain pins. If I do that incorrectly, I'm going to get a compilation at her. You can't use those pins for this combination of, you know, I can show, let me just show it to you how, how amazing",Interview P8,"If it compiles, it works",1,,75,75,1,Author 2,8/23/23,Author 1,1/17/24
8:12,¶ 75,," It's just a game changer, complete game changer for embedded development, how they've really been very carefully thinking about how, how you can enforce expectations of the hardware into the type system",Interview P8,Fanboyish,1,,75,75,1,Author 2,8/23/23,Author 1,1/17/24
8:13,¶ 83,,"No, it just neatly encapsulates all the, all the hardware so that and if it's done correctly, it just gives you pretty strong guarantees that you are using the hardware correctly.",Interview P8,"""Safe"" API",1,,83,83,1,Author 2,8/23/23,Author 1,1/17/24
8:14,¶ 93,,"So you're so typically you have macros with these tables here that defines and so this one defines sort of the legal combination of the, of the IO pins that you can use if you want to do a you are to and if you do anything illegal with just not going to compile.",Interview P8,Macros,1,,93,93,1,Author 2,8/23/23,Author 1,1/17/24
8:15,¶ 101,,"Now, why is that does that need to be unsafe. That's memory mapping a file. So, gotcha. Why? I'm not sure maybe I'm kind of puzzling that you can't have a safe abstraction for that.",Interview P8,Exposing an Unsafe API to Users,1,,101,101,1,Author 2,8/23/23,Author 1,1/17/24
8:16,¶ 101,," Oh yeah, I guess if you encoded the structure of the mapping in your type system. This might be, you know, I'm not, I'm not sure all all my unsafe are really necessary",Interview P8,When to Encapsulate?,1,,101,101,1,Author 2,8/23/23,Author 1,1/17/24
8:17,¶ 101,,"So in this case, there was a performance critical piece of code that I managed to speed up by using AVX to intrinsics on on the Intel.",Interview P8,"Increase Performance, Intrinsics",2,,101,101,1,Author 2,8/23/23,Author 1,1/17/24
8:18,¶ 105 – 109,,"And then all of that is unsafe. And, and it's even, you know, it's even I have a warning here. This is this thing is going to read with 31 bytes out of power just because your data size isn't bigger than.

InterviewerYeah, yeah.

ParticipantSo sort of it's, it's unavoidable in that case.",Interview P8,No Other Choice,1,,105,109,5,Author 2,8/23/23,Author 1,1/17/24
8:19,¶ 105,,it's even I have a warning here. This is this thing is going to read with 31 bytes out of power just because your data size isn't bigger than.,Interview P8,Documented Contract or Invariant,1,,105,105,1,Author 2,8/23/23,Author 1,1/17/24
8:20,¶ 121,,"Yeah, it's all these, it's all these Intel intrinsics, but there are rates out there that are supposed to do SIMD.",Interview P8,"SIMD Intrinsics, Volatile Intrinsics",2,,121,121,1,Author 2,8/23/23,Author 1,1/17/24
8:21,¶ 129,,his looks like the one. And that's kind of just a transportation of data types.,Interview P8,Transmute,1,,129,129,1,Author 2,8/23/23,Author 1,1/17/24
8:22,¶ 133,," Yeah, so it's you say it's it's easier to Just use a solution you know is performant, even if it is unsafe versus spending extra effort to invest in some framework that might give you a nice encapsulation but Might not this is also so this is also you know several years old so the ecosystem has was less mature at this time you know",Interview P8,Difficult to Encapsulate,1,,133,133,1,Author 2,8/23/23,Author 1,1/17/24
8:23,¶ 137,,"This way okay I don't, I don't like writing unsafe code. Just gives you doesn't give you good vibes. ",Interview P8,Stigma Against Unsafe,1,,137,137,1,Author 2,8/23/23,Author 1,1/17/24
8:24,¶ 137,,Just I try and avoid it and a lot of my libraries and stuff I'll explicitly do deny unsafe. If I'm writing a library and I don't really see any need for this to be unsafe or I wanted. ,Interview P8,Exposing a Safe API,1,,137,137,1,Author 2,8/23/23,Author 1,1/17/24
8:25,¶ 145,, PyO3,Interview P8,PyO3,1,,145,145,1,Author 2,8/23/23,Author 1,1/17/24
8:26,¶ 165,,"And let me see. Should be unsafe in here. Or have I used bind might have used bind again for this. Let me see. No unsafe here. How did I do this? Yeah, awful transmute. Gotcha.",Interview P8,Transmute,1,,165,165,1,Author 2,8/28/23,Author 1,1/17/24
8:27,¶ 169,,I'm being passed a void pointer to a rust. ,Interview P8,Opaque Pointer,1,,169,169,1,Author 2,8/28/23,Author 1,1/17/24
8:28,¶ 181,,"Uh, you know, what you typically have and see, but it looks good. Compiles, runs. ",Interview P8,"If it compiles, it works",1,,181,181,1,Author 2,8/28/23,Author 1,1/17/24
8:29,¶ 181,,". I think maybe once I had a problem where, uh, there was some alignment issue, but that was tied to this. And that was tied to the, the AVX code. And so there were just certain data structures that had some, I don't know if I could do that safer, but I think I had to explicitly align, uh, data so they would. And that was a bit, bit random, you know, because you don't know the, you, uh, you're not always sure about what alignment your data is going to get when it's allocated.",Interview P8,"Allocation & Alignment Bug, Improper Alignment",2,,181,181,1,Author 2,8/28/23,Author 1,1/17/24
8:30,¶ 187,,"Uh, as, uh, what I find it most, uh, what I really like about clippy, now I'm trying to catch up on, on new features and, uh, they come with a different compiler releases, but I guess that don't have the capacity to do a deep dive in every release, but clippy kind of helps me to catch up with it.",Interview P8,"Clippy for Learning Rust, Shifting Ground",2,,187,187,1,Author 2,8/28/23,Author 1,1/17/24
8:31,¶ 192,,"But when I've done a project like that and I have a, you know, I'm near to completion or feature complete, then I will also add some tests in Valgrind.",Interview P8,"Dynamic Analysis Safety Net, Valgrind",2,,192,192,1,Author 2,8/28/23,Author 1,1/17/24
8:32,¶ 194,,"Recently started using a fuzzing cargo fuzz, which I just had to say is amazing.",Interview P8,Fuzzing,1,,194,194,1,Author 2,8/28/23,Author 1,1/17/24
8:33,¶ 206,,"And I even, even got my hand at, uh, playing with Kani. Uh, the formal, uh, just to see if that could help me because it was, uh, and the particular problem, the problem there was I, uh, there's some data that needs to be processed in an interrupt handler",Interview P8,Formal verification,1,,206,206,1,Author 2,8/28/23,Author 1,1/17/24
8:34,¶ 206,,Kani,Interview P8,Kani,1,,206,206,1,Author 2,8/28/23,Author 1,1/17/24
8:35,¶ 214,,"Now that tells me, uh, that if I can do all of this in, in, uh, where all these instruction instructions are emulated and I don't know how it's done, maybe it should be possible for Miri to check the code because you're not really dependent on having, uh, the hardware instruction, uh, uh, implementation of all of these because there is a emulation.",Interview P8,Wants Solution,1,,214,214,1,Author 2,8/28/23,Author 1,1/17/24
8:36,¶ 13,,"I've been writing C and C++ for decades and I sort of didn't have a lot of memory and safety issues, but where things would sort of fall apart would typically be when multithreading was involved.",Interview P8,C++ is Difficult,1,,13,13,1,Author 1,9/2/23,Author 1,1/17/24
8:37,¶ 17,,I kind of found at that time I was working in seismic data processing.,Interview P8,Data Processing & Serialization,1,,17,17,1,Author 1,9/2/23,Author 1,1/17/24
8:38,¶ 25,,"I had this kind of prolonged search for a better way of doing things, one could say.",Interview P8,C++ is Difficult,1,,25,25,1,Author 1,9/2/23,Author 1,1/17/24
8:39,¶ 37,,"Well, I just had a lot of, I just put a lot of faith in the promises of fearless concurrency. Of course, it wasn't just blind faith because I did have some, I mean, that was the premise of doing this in Rust to begin with was that Rust would allow me to make a multi-threaded implementation with confidence.
",Interview P8,"Fearless Concurrency, Tacit Knowledge",2,,37,37,1,Author 1,9/2/23,Author 1,1/17/24
9:1,¶ 7,, I think with unsafe Rust is there's no actual specification of like an object model.,Interview P9,Shifting Ground,1,,7,7,1,Author 2,8/20/23,Author 1,1/17/24
9:2,¶ 9,,"So like in this little runtime, this IO runtime, I'm writing, it's, it's very hard to know when it's safe to turn the innards of like an UnsafeCell into a mutable reference. Because it's so strict.",Interview P9,UnsafeCell<T>,1,,9,9,1,Author 2,8/20/23,Author 1,1/17/24
9:3,¶ 9,,"And the problem is you can't run a tool like Miri. I don't know if you've heard of that. It's like a little MIR interpreter. Yeah, the problem is you can't run that because you're using FFI because if you're touching real sockets on the system, you know, Miri's not going to work.",Interview P9,"Miri doesn't support this feature, Wants Solution",2,,9,9,1,Author 2,8/23/23,Author 1,1/17/24
9:4,¶ 13,,"So primarily, it's really just been for dealing with the raw system calls. ",Interview P9,System Calls,1,,13,13,1,Author 2,8/23/23,Author 1,1/17/24
9:5,¶ 13,,"So it's like raw allocation, raw deallocation, which is always nice. Pretty much leaking and unleaking the smart pointers. So like RC and Box, stuff like that. Most of it's primarily motivated by FFI other times. It's been simply for performance reasons.",Interview P9,"Arc<T>/Rc<T>, Box<T>",2,,13,13,1,Author 2,8/23/23,Author 1,1/17/24
9:6,¶ 13,,"So like I tried doing a little bit of image processing coding in Rust, too. And I had someone help me do some manual SIMD intrinsics in there. ",Interview P9,"Data Processing & Serialization, SIMD Intrinsics",2,,13,13,1,Author 2,8/23/23,Author 1,1/17/24
9:7,¶ 13,,"It's been simply for performance reasons. So like I tried doing a little bit of image processing coding in Rust, too. And I had someone help me do some manual SIMD intrinsics in there. So I mean, you definitely need unsafe for that.",Interview P9,Increase Performance,1,,13,13,1,Author 2,8/23/23,Author 1,1/17/24
9:8,¶ 13,,"So primarily, it's really just been for dealing with the raw system calls. So it's like raw allocation, raw deallocation, which is always nice. Pretty much leaking and unleaking the smart pointers. So like RC and Box, stuff like that. Most of it's primarily motivated by FFI other times. ",Interview P9,No Other Choice,1,,13,13,1,Author 2,8/23/23,Author 1,1/17/24
9:9,¶ 17,,"But typically I try to avoid that kind of stuff. The benefits really don't outweigh the risks. You're like, Oh, I saved like maybe 10 cycles on an enum match. And then like all like, I was a potential for UB. ",Interview P9,Preference for Safety,1,,17,17,1,Author 2,8/23/23,Author 1,1/17/24
9:10,¶ 25,,"And I don't just mean the sense then then like, because you know how RefCell is, it's like ref counted. So it makes sure you don't create more than one concurrent borrow. I don't really think that's too hard in practice.",Interview P9,RefCell<T>,1,,25,25,1,Author 2,8/23/23,Author 1,1/17/24
9:11,¶ 25,,"Because you know, if you primarily work through the UnsafeCell directly, if you pass around references to that, it's a lot easy. It's very easy to just, okay, I only have one mutable ref here. I'm just going to keep it in the function scope. I'm not going to let it escape. It's pretty easy to like not double borrow, but it's hard to know when it's kind of safe to be like derive a mutable reference from it just in general.",Interview P9,UnsafeCell<T>,1,,25,25,1,Author 2,8/23/23,Author 1,1/17/24
9:12,¶ 25,," It's pretty easy to like not double borrow, but it's hard to know when it's kind of safe to be like derive a mutable reference from it just in general.",Interview P9,Unsafe is Difficult to Understand,1,,25,25,1,Author 2,8/23/23,Author 1,1/17/24
9:13,¶ 33,," I just like copy pasted one little function. I was like, okay, I have like an Rc UnsafeCell. Let's see if, you know, a rough gist of what my code is doing is valid in Miri in the past. So I was like, all right, we're going to spam the server without the code base then.",Interview P9,"Arc<T>/Rc<T>, Running tests through Miri, UnsafeCell<T>",3,,33,33,1,Author 2,8/23/23,Author 1,1/17/24
9:14,¶ 37,," I think I also just did it because I don't know, maybe like the ergonomics of it, because I was like, I'm primarily working mostly with raw pointers when it comes down to it. Because a lot of the stuff is like the C APIs and I'm leaking and I'm unleaking things. So I was like, I could use a RefCell, but it's a lot of ceremony for basic because I was like, you know, the safety RefCell would have added is actually pretty minuscule compared to like, just the sheer complexities of like, am I actually associating the right pointer and the right structures and that getting through in the right way and stuff like that.",Interview P9,"Easier or More Ergonomic, RefCell<T>",2,,37,37,1,Author 2,8/23/23,Author 1,1/17/24
9:15,¶ 37,,"Yeah. Yeah. So I was like, you know, RefCell does add, Yeah, RefCell does add some extra safety. But when it comes like to the big, broad picture of things, I'm just going to be everything's going to be caught by Valgrind, regardless.",Interview P9,"Dynamic Analysis Safety Net, RefCell<T>, Valgrind",3,,37,37,1,Author 2,8/23/23,Author 1,1/17/24
9:16,¶ 41,," And I'm like, so as if I'm not using Valgrind, then I'm iterating through all the sanitizers. Typically, I run everything, if I can help it, like, unless there's a compelling reason not to, you know, it's like, you got to use MemorySanitizer, the AddressSanitizer, the UB one, and then Valgrind. Those are pretty good together.",Interview P9,Dynamic Analysis Safety Net,1,,41,41,1,Author 2,8/23/23,Author 1,1/17/24
9:17,¶ 45,,"So like, if you have a Box and you get the raw pointer to the underlying object, if you relocate the Box, it invalidates accesses to those old pointers. And I was like, well, that's dumb.",Interview P9,Wants Solution,1,,45,45,1,Author 2,8/23/23,Author 1,1/17/24
9:18,¶ 45,,"Because you know, in C++, that's like the bread and butter of all the IO code you'll ever write in your entire life. Like you have a unique pointer in C++, you give the raw pointer of to the interface, and then you relocate the unique pointer, but you still rely on that pointer having valid access tags. But in Rust, for some reason, they took Box and they were like, we're not about that life",Interview P9,Feature Disparity,1,,45,45,1,Author 2,8/23/23,Author 1,1/17/24
9:19,¶ 51,,"Typically, I either am using a vector, because I usually need more than one object at a time. Or I'm using something like Rc. So, you know, Rc insert cell type here.",Interview P9,Arc<T>/Rc<T>,1,,51,51,1,Author 2,8/23/23,Author 1,1/17/24
9:20,¶ 45,,"I think, for me, one of the very subtle things they don't tell you about unsafe rust is, for some reason, they really overengineer Box. So I see all these kids on Discord. I call them kids. It's because I'm [age] and they're like maybe [age] or something. So to me, I'm just like, yeah, I see them talk about how under these like Box rules, it's illegal to, what was it, treat Box like for pointer stability. So like, if you have a Box and you get the raw pointer to the underlying object, if you relocate the Box, it invalidates accesses to those old pointers. And I was like, well, that's dumb. Because you know, in C++, that's like the bread and butter of all the IO code you'll ever write in your entire life.",Interview P9,Box<T>,1,,45,45,1,Author 2,8/23/23,Author 1,1/17/24
9:21,¶ 55,,"But the big thing you don't see C++ steps culturally do is we never leak, we never leak a shared pointer in C++ in the sense that we never go because here's, first of all, with shared pointers, it's two pointers in size, in almost all cases, because you you can accept a raw pointer and participate in the ownership. So you have to have disparate allocations for the for the header where you keep in all the counts, and then for the object itself. But in Rust, you can't ever do that you you only create one allocation, whereas the frame or the header data embedded with the object. So in Rust, you see everyone leaking shared pointers everywhere.",Interview P9,Feature Disparity,1,,55,55,1,Author 2,8/23/23,Author 1,1/17/24
9:22,¶ 55,,"So in general, Boost also has a local shared pointer, which is, you know, a single threaded shared pointer type.",Interview P9,Boost,1,,55,55,1,Author 2,8/23/23,Author 1,1/17/24
9:23,¶ 59,,"So typically that's what I do. I just I RC, you know, some state, and then I leak it to the IOuring runtime itself. And then I just get it back and then I unleak it and everything works great.",Interview P9,Arc<T>/Rc<T>,1,,59,59,1,Author 2,8/23/23,Author 1,1/17/24
9:24,¶ 59,,"And this really has to be done because I would actually argue it's harder to actually author a library in Rust than in C++. Because in Rust, there's no such, I mean, everyone wants a safe interface. You know, no one really wants to go use the unsafe heavy ones. ",Interview P9,"Preference for Safety, Stigma Against Unsafe",2,,59,59,1,Author 2,8/23/23,Author 1,1/17/24
9:25,¶ 59,," But in Rust, what you do is you have to make a sound, it's very hard to make a sound interface around an unsafe thing in Rust, just because if you give up like a handle, like a little ray type in Rust, you have to code around aggressive dropping and aggressive forgetting.",Interview P9,Difficult to Encapsulate,1,,59,59,1,Author 2,8/23/23,Author 1,1/17/24
9:26,¶ 61,,"Because normally in C++, we're like, Hey, we're going to give you a type, its destructor runs, you know, like important code, we need that to run. So if you don't run it, that's UB. But in Rust, you can't rely on that because drop and forget are safe.",Interview P9,C++ is Easier to Use,1,,61,61,1,Author 2,8/23/23,Author 1,1/17/24
9:27,¶ 63,,"I hated that one so badly. Or maybe it was the splicing one, all the iterators were awful to implement. And that's just because they have to be handled, you know, like their drops in the middle of iteration, and it's just all the stability and all the panic safety, you have to add two. And the worst part is the rules around double drop or like double panic. So like if you panic in a drop handler, what happens then, a lot of that stuff isn't nailed down.",Interview P9,Difficult to Encapsulate,1,,63,63,1,Author 2,8/23/23,Author 1,1/17/24
9:28,¶ 65,,"So I was hoping Rust would have learned from that and been like, Hey, if you panic in a drop, we're going to terminate your program. Yeah. I don't know if they've ironed out those rules, but trying to prepare for that kind of stuff is just insane.",Interview P9,Shifting Ground,1,,65,65,1,Author 2,8/23/23,Author 1,1/17/24
9:29,¶ 69,,Yeah. So it's both difficult because you're inherently reasoning reasoning about like a complex memory safety scenario,Interview P9,Unsafe is Difficult to Understand,1,,69,69,1,Author 2,8/23/23,Author 1,1/17/24
9:30,¶ 69,,"And then also the rules about things like drop order or handling of panics are fuzzy. So even if you are attempting to do things safe, it's like there isn't a clear set of guidelines. Is that an accurate kind of something? Yeah. Yeah. So real guidelines for library authors would be very appreciated.",Interview P9,Shifting Ground,1,,69,69,1,Author 2,8/23/23,Author 1,1/17/24
9:31,¶ 73 – 75,," I think it sets a bad precedent for the culture because I remember very distinctly once I was in [forum]. And I was asking, you know, I was still like, I'm still really learning Rust. I've only been doing it for maybe like a year or two. And so I was asking some fellow [users], I was like, you know, do you run your production tests through Valgrind?

ParticipantAnd they were like, why would I use Valgrind? And they were like, I'm using Rust, I don't need Valgrind. And I was like, after having implemented Vector, I was like screaming in my head, I was like, Oh my God, you need Valgrind so badly.",Interview P9,Engaging with the Rust Community,1,,73,75,3,Author 2,8/23/23,Author 1,1/17/24
9:32,¶ 77,,"And so I was like, Oh my God, this culture is dangerous, because you have people who like genuinely believe, because I know it's like, if you're using safe code, your code is supposed to be automatically safe.",Interview P9,Safe Rust is Safe,1,,77,77,1,Author 2,8/23/23,Author 1,1/17/24
9:33,¶ 81,,"Like I don't think enough C++ devs appreciate that. Because it means you can actually have an array of these types and you can treat it as an array of the underlying type. I mean, you can't do that in C++ because when you have a struct, you have the possibility for tail padding and the APIs are different.",Interview P9,"Feature Disparity, MaybeUninit<T>",2,,81,81,1,Author 2,8/29/23,Author 1,1/17/24
9:34,¶ 87,,"eah, I think the ability to represent uninitialized storage via the type system and how they have it work so well is what just makes it so beautifully brilliant.",Interview P9,Fanboyish,1,,87,87,1,Author 2,8/29/23,Author 1,1/17/24
9:35,¶ 99,,"Okay, yeah. I don't trust bindgen at all. I wouldn't even. Also, I'm not wrapping that much FFI.",Interview P9,Generation VS Validation,1,,99,99,1,Author 2,8/29/23,Author 1,1/17/24
9:36,¶ 111,,"Writing stuff manually by hand isn't really that bad. Because I mean, all you're really doing is just copy pasting the declaration and then you switch the types out. I mean, I very sloppily always just use i32 instead of int. I'm like, it's always going to be 32 bits, guys. Show me one platform. I mean, someone probably could, but I don't expect my code to ever go there.",Interview P9,Generation VS Validation,1,,111,111,1,Author 2,8/29/23,Author 1,1/17/24
9:37,¶ 115,," when you start intermixing C++ and Rust, it gets a lot trickier just because of how you want to have those two ABIs communicate with each other. Like in general, I prefer only using the system ABI, you know, like C ABI. And so when you do that, it gets kind of, I don't know, it gets kind of annoying. So I typically only try to go one way, which is consuming C from Rust directly.",Interview P9,"Different FFI Memory Model, Simple FFI",2,,115,115,1,Author 2,8/29/23,Author 1,1/17/24
9:38,¶ 119,,"You know, I kind of just YOLO call them and wait for Valgrind to tell me if I did it wrong.",Interview P9,"Dynamic Analysis Safety Net, Valgrind",2,,119,119,1,Author 2,8/29/23,Author 1,1/17/24
9:39,¶ 127,,"Because like a lot of C interfaces, they really just give you, here's the init function, here's the cleanup function. And basically that's trivial, just wrap with like a drop type, you know. Okay. So I mean, that kind of, once you get that pattern down, it's really, really easy. ",Interview P9,Simple FFI,1,,127,127,1,Author 2,8/29/23,Author 1,1/17/24
9:40,¶ 135,,"So the problem was I, I actually didn't set the user data when I made the submission. So when I got the user data from the corresponding completion, it contained a random pointer. The problem was liburing was giving these random pointers. They were real pointers. They actually pointed to these leaked RCs I had given in the past. So I had this horrible bug where like random co-routines weren't being resumed properly or they were being double resumed just because of how it came in all, how it came in all jumbled from IOuring, you know, completion submission cycle. So that was pretty interesting to debug. And those ones, those ones were like valgrind didn't catch it because technically like the data was set. It was just, it was given random bad values. And it was really funny because I saw the Azio author, he actually had run into the exact same bug I did. I saw the commit where he talked about it and I was like, that hit me too. I was like, oh my God, that's so funny.",Interview P9,"Arc<T>/Rc<T>, Temporal Memory Bug, Uninitialized memory, Using Uninitialized Memory",4,,135,135,1,Author 2,8/29/23,Author 1,1/17/24
9:41,¶ 139,,"So yeah, I finally found it. I was like, oh God, that was awful. That was, it was a lot of print line. It was a lot of printing everything. ",Interview P9,Printf-Style Debugging,1,,139,139,1,Author 2,8/29/23,Author 1,1/17/24
9:42,¶ 139,," I leaked this pointer to this coroutine. You know, I call them coroutines. That's why I call the rust a single way. I know some people get kind of like persnickety, but they're coroutines. So I had this thing where I was like, yeah, I was matching all these pointers to the coroutines. And you know, I finally found it because I was like, wait a minute, that pointer shouldn't be there. I was like, look at the screen. I was like, yeah, that pointer already associated with complete coroutine, you know, we should be good. So that was how I found it.",Interview P9,,0,"To Author 2 This seems like the same wrong-pointer error described earlier in the text, and not a logical error. Response Yeah this makes sense.  I agree it doesn't look like a logical error.  I think I attributed the reason the wrong pointer was there to a logic issue when I shouldn't've.",139,139,1,Author 2,8/29/23,Author 1,1/17/24
9:43,¶ 145,,"But in Rust, that doesn't really exist. Like you can't tell cargo, hey, cargo, run my tests and run it as like a product matrix of all these configurations. You know, you basically have to like, I'm going to write a shell script. And then I'm going to have it vote cargo with, you know, dash C for this one and cargo dash C for this one, you know, so on and so forth. So it's definitely a strict downgrade",Interview P9,Wants Solution,1,,145,145,1,Author 2,8/29/23,Author 1,1/17/24
9:44,¶ 155,," But I've been thinking about translating his work to rust. And then something like that, Miri would be absolutely paramount.",Interview P9,Running tests through Miri,1,,155,155,1,Author 2,8/29/23,Author 1,1/17/24
9:45,¶ 161,,"So they were trying to get the address of a variable. And they did it by binding a const reference, and then they like as casted it to a pointer, very standard stuff, right? Well, fun fact, that's wrong. Because when you cast that pointer, you invalidate the borrow stack. So Miri started screaming at them, like, hey, you're generating a store to this location, but it doesn't have write tags. So stop doing that.",Interview P9,"Borrowing or Provenance Bug, Stacked/Tree Borrows Violation",2,,161,161,1,Author 2,8/29/23,Author 1,1/17/24
9:46,¶ 161,,"Everyone was like, everyone was trying to figure out, well, why is this code wrong? Because we all looked at it, and we were like, well, have you used UnsafeCell? Because we thought, oh, it's complaining about a lack of a write tag. Maybe you just need to tell it, hey, this is interior immutability, you can write to it, go nuts, but the error is still there. And it turns out it was because they were doing that stupid reference binding. And so the fix that someone else caught was just use addrof.",Interview P9,UnsafeCell<T>,1,,161,161,1,Author 2,8/29/23,Author 1,1/17/24
9:47,¶ 217,,"but I guess culturally it's really just like unsafe means unsafe and not unsafe. It's totally safe. So which is why I'm, you know, that's why I'm so perturbed when I hear when I hear the youth say, Oh, I don't need Valgrind or I don't need sanitizers. We need those tools as the author of an IO runtime. I can assure everyone no one knows what they're doing. We're all just trying our best.",Interview P9,Safe Rust is Safe,1,"Author 2 This seems less like a stigma against unsafe, and more of the ""Safe is safe"" code you created. Response I completely agree!  I think I coded this before I made the ""Safe is safe"" code.",217,217,1,Author 2,8/29/23,Author 1,1/17/24
9:48,¶ 47,,"So back in the day, you know, you would have your callbacks that store a unique pointer to all your data. And so you would be moving that guy around everywhere. And you really do expect the pointer stability to come into play. So yeah, with Box is a huge foot gun. And in general, I really don't like Box. And I don't really use it.",Interview P9,Box<T>,1,,47,47,1,Author 1,9/1/23,Author 1,1/17/24
9:49,¶ 7,,"So one of the big things with C++ is you have the decoupling of object storage from object lifetime. So, you know, C++ goes through a lot of wording, like very careful wording to be like, you know, we have the notion of storage and installation and then there's objects whose lifetime live within that storage. And so that's when you have things like placement new and then, you know, in place destructors. And so with Rust, there really is none of that.",Interview P9,Feature Disparity,1,,7,7,1,Author 1,9/1/23,Author 1,1/17/24
9:50,¶ 9,,"So the problem is there's no documentation for that. So all you really do is you kind of just pull up GitHub, you look at what the stdlib is doing.",Interview P9,Shifting Ground,1,,9,9,1,Author 1,9/1/23,Author 1,1/17/24
9:51,¶ 9,,"But just because Miri's limited to the MIR, it's like you just can't use the tool at all. Not well, theoretically, if I was motivated enough, I think I could pull out segments of my code base and run Miri through a subset of the unit tests. But as terms of like a comprehensive, see, the problem with that is it leads to like an awkward constraint design, where sometimes you really just want to call the FFI function right as you're forming a mutable reference. ",Interview P9,Running tests through Miri,1,,9,9,1,Author 1,9/1/23,Author 1,1/17/24
9:52,¶ 23,,"It's just, it's because how you want to have to derive raw pointers from the UnsafeCell. And I guess how it was, I think how Rust does interior immutability is really interesting. I know there's like some pithy C plus plus to have who's kind of like, Oh, it's the same thing as mutable data members. But I think the fact that because of how, you know, I don't think a lot of C plus plus devs in particular understand that rust doesn't have type based aliasing analysis and only has the ability based. And so I think it's very tricky when you're sort of like using the unsafe cell, converting it to its underlying raw pointers and or deriving the mutable pointer from it. When it when it's really permissible to just go ahead and turn it into a hard mutable reference.",Interview P9,UnsafeCell<T>,1,,23,23,1,Author 1,9/1/23,Author 1,1/17/24
9:53,¶ 29,,"You know, that's a good, I think it was just like, I wanted that a hella sick perf, bro.",Interview P9,"RefCell<T>, UnsafeCell<T>",2,,29,29,1,Author 1,9/1/23,Author 1,1/17/24
9:54,¶ 23,,"But I think the fact that because of how, you know, I don't think a lot of C plus plus devs in particular understand that rust doesn't have type based aliasing analysis and only has the ability based. ",Interview P9,Feature Disparity,1,,23,23,1,Author 1,9/3/23,Author 1,1/17/24
9:55,¶ 45,,"But in Rust, for some reason, they took Box and they were like, we're not about that life. So I think in that sense, it's very subtle. And I don't think many C++ developers would ever expect that kind of restriction. Because it's just insane, because it's what we do all day every day, you know, we're like, hey, we have, we need pointer stability, we're going to relocate, or you know, we're going to move the unique pointers we need to. And we expect that pointer we originally gave it to stay valid forever, or at least for the lifetime of the unique pointer, really.",Interview P9,Feature Disparity,1,,45,45,1,Author 1,9/3/23,Author 1,1/17/24
9:56,¶ 63,,"And the worst part is the rules around double drop or like double panic. So like if you panic in a drop handler, what happens then, a lot of that stuff isn't nailed down.",Interview P9,Shifting Ground,1,,63,63,1,Author 1,9/3/23,Author 1,1/17/24
9:57,¶ 69,,"So in some ways, the undefined nature of Rust really, as a library author, it makes you very confused. Like, what should I do? Like, what if I am handling up, you know, what if I am handling up and unwinded my drop? And I panic again, you really don't know what's going to happen.",Interview P9,Shifting Ground,1,,69,69,1,Author 1,9/3/23,Author 1,1/17/24
9:58,¶ 75,,"And they were like, why would I use Valgrind? And they were like, I'm using Rust, I don't need Valgrind. And I was like, after having implemented Vector, I was like screaming in my head, I was like, Oh my God, you need Valgrind so badly. ",Interview P9,Tacit Knowledge,1,,75,75,1,Author 1,9/3/23,Author 1,1/17/24
9:59,¶ 75,,"Because I was like, no library author knows when they're going to trigger UV. Like, you know, we do our best to give you like a sound interface, but God knows if there's a hole in it. So it's one of those things where it's like as a library author, you could try your best, you know, you write tests, you write maybe some fuzzing tests, you get all that stuff going, but you never know when a user is going to stumble like into something you just didn't cover.",Interview P9,"""Safe"" API",1,,75,75,1,Author 1,9/3/23,Author 1,1/17/24
9:60,¶ 77,,"But the culture was like, no, I'm using Rust, it's safe. I don't need to do all these other things.",Interview P9,Safe Rust is Safe,1,,77,77,1,Author 1,9/3/23,Author 1,1/17/24
9:61,¶ 83,,"And I was just like, God, dude, if we had something like this in C++, I mean, you really can't do it in C++ because the complexities they put around containers really prohibits it. So I was very proud of Rust's library team for coming up with that.",Interview P9,Feature Disparity,1,,83,83,1,Author 1,9/3/23,Author 1,1/17/24
9:62,¶ 91,,". And it's also really the only way you can get piecewise construction of objects in Rust to work really, as you have to do it through the MaybeUninit",Interview P9,MaybeUninit<T>,1,,91,91,1,Author 1,9/3/23,Author 1,1/17/24
9:63,¶ 91 – 92,,"Which is one of those things I'm kind of disappointed on, like Rust doesn't have an analog for placement new. Like if you wanted to construct an object directly in some storage, you have to do some weird offset of pointer read write voodoo or you just mem copy an existing type in, which I mean, it's okay, I guess.

",Interview P9,Feature Disparity,1,,91,92,2,Author 1,9/3/23,Author 1,1/17/24
9:64,¶ 107,,"But in general, I don't really like, I don't like the generated code phase of build systems. Like if I can avoid it in general, I'm going to avoid code generation. I know Rust makes it like, you know, somewhat approachable with the build.rs file.",Interview P9,Generation VS Validation,1,,107,107,1,Author 1,9/3/23,Author 1,1/17/24
9:65,¶ 119,,"I mean, specifically, I'm like so well trained as like a C++ dev that I usually always send initialized memory or stuff like that. So it's not really too different.",Interview P9,Tacit Knowledge,1,,119,119,1,Author 1,9/3/23,Author 1,1/17/24
9:66,¶ 119,,"But the problem is, so that was one of those things where I was like, I was glad I wasn't using bindgen, because I'm like, how would bindgen respond to a function that doesn't exist in terms of the compiled library? You know, like would it just reimplement the static functions from the header? Would it have just like skipped them? Like what would it have done?",Interview P9,"bindgen, Limitation of Binding Tool",2,,119,119,1,Author 1,9/3/23,Author 1,1/17/24
9:67,¶ 127,,"But yeah, so it's, there's C libraries that do things like, they'll use long jump or set jump. That's a problem because Rust can't handle that. Yeah. So you have to create an intermediate C function that wraps all that jumping for you. And then you can call that from Rust.",Interview P9,Different FFI Memory Model,1,,127,127,1,Author 1,9/3/23,Author 1,1/17/24
9:68,¶ 131,,"So like the PNG crate, I tried using it in the past. And the problem was it has like a tenth of the features. And I mean, I get it because it's like, there's a lot to code and it's a volunteer effort. So it's whatever the maintainer is willing to put in. I mean, yeah, it can, it can do full reads and writes of PNGs with like an alpha channel and stuff, but it's not going to do like half the features that live PNG actually has. And I was like, well, that's lame because it's kind of a downgrade, but then you use the PNG and then it has like long jump in it. And you're just like, uh, it's so hard.",Interview P9,Rust Rewrite is Incomplete,1,,131,131,1,Author 1,9/3/23,Author 1,1/17/24
9:69,¶ 135,,"And those ones, those ones were like valgrind didn't catch it because technically like the data was set. It was just, it was given random bad values.",Interview P9,Missed a Bug,1,,135,135,1,Author 1,9/3/23,Author 1,1/17/24
9:70,¶ 149,,"So yeah, if CMake had first class Rust support, oh, that'd be beautiful. ",Interview P9,Wants Solution,1,,149,149,1,Author 1,9/3/23,Author 1,1/17/24
9:71,¶ 155,,"And yeah, so there Miri's pretty clutch, as you know, I'm not doing any ffi",Interview P9,Miri doesn't support this feature,1,,155,155,1,Author 1,9/3/23,Author 1,1/17/24
9:72,¶ 165 – 166,,"That was a clairvoyant moment for me because I was like, oh my God, in C++, you have to call address of because some individual may overload the little ampersand operator. But in Rust, you have to call addrof because a reference invalidates your borrow stack. And I was like, oh my God, they're the same language, guys, you have to call address of with both.
 ",Interview P9,Shared Experiences,1,,165,166,2,Author 1,9/3/23,Author 1,1/17/24
9:73,¶ 181,,"There's a new borrowing every week, you know, whatever Miri runs, Miri runs, I guess. So the problem is you don't have all that. So there was someone who was telling me about this project called crab cake, where I guess it's someone who's actually trying to do that. He's trying to, at least I can get the, I might, I might just email you the link, but it was called a crab cake. Yeah.",Interview P9,Krabcake,1,,181,181,1,Author 1,9/3/23,Author 1,1/17/24
9:74,¶ 197,,"Someone came up with crab cake, and it looks like it's just that it's like Valgrind plus Miri stacked borrow checking. And I'm just like, Oh my God, this is everything I've ever needed because it does have, here's the thing. I actually do real networking tests in my Rust code. ",Interview P9,"Krabcake, Valgrind, Wants Solution",3,,197,197,1,Author 1,9/3/23,Author 1,1/17/24
9:75,¶ 197 – 198,,"Oh, also in the ability to run builds as a product matrix, like I want to be able to test, you know, like give it a configuration. Here's the four sanitizer, like here's the three sanitizers you need to use. You know, when I run, when I run cargo test, it'd be nice if you could run, you know, my test suite would just you be saying and then just MSAN and and then just ASAN.

",Interview P9,Wants Solution,1,,197,198,2,Author 1,9/3/23,Author 1,1/17/24
9:76,¶ 227,," Because right now, you know, I've come to view rust as like a sort of like a two tiered language. In rust, you're one of two people you can either be trusted with unsafe or you're the forbid unsafe kind of person. So I think for people who actually write unsafe code, there's just so much work that needs to be done. Like the tooling is okay, you know, like you have sanitizers and whatnot, but it's just without a formally defined spec, it's, you're really just flying by the suit of your pants",Interview P9,Stigma Against Unsafe,1,,227,227,1,Author 1,9/3/23,Author 1,1/17/24
9:77,¶ 227,,"So I think for people who actually write unsafe code, there's just so much work that needs to be done. Like the tooling is okay, you know, like you have sanitizers and whatnot, but it's just without a formally defined spec, it's, you're really just flying by the suit of your pants and more often than not, I'm really just like, well, whatever the stdlib does, I'm going to do too. That's because they can't be wrong. They're too standard to fail.",Interview P9,Shifting Ground,1,,227,227,1,Author 1,9/3/23,Author 1,1/17/24
9:78,¶ 75,,"no library author knows when they're going to trigger UV. Like, you know, we do our best to give you like a sound interface, but God knows if there's a hole in it. ",Interview P9,"""Safe"" API",1,,75,75,1,Author 1,9/23/23,Author 1,1/17/24
10:1,¶ 7,,"Yeah, most recently, like the last year, I have mostly been focused on the Rust compiler itself.",Interview P10,Rust Project Contributor,1,,7,7,1,Author 2,8/20/23,Author 1,1/17/24
10:2,¶ 35,,"I use unsafe Rust for mostly to create new data structures or types that are not really possible to express with safe Rust,",Interview P10,No Other Choice,1,,35,35,1,Author 2,8/20/23,Author 1,1/17/24
10:3,¶ 35,," I've also used unsafe Rust for just for fun, for making something unsafe, learning new things about the language",Interview P10,For Fun,1,,35,35,1,Author 2,8/20/23,Author 1,1/17/24
10:4,¶ 39,,"And it's great because it allows for more efficient code because it's actually only used in one place right now, but it's basically a pointer and then it has two flags and instead of being several bytes because of the point of the pulleys, it's just a single pointer and inside the alignment bits there are the flags and yeah, that makes it more efficient and smaller.",Interview P10,Increase Performance,1,,39,39,1,Author 2,8/20/23,Author 1,1/17/24
10:5,¶ 47,,"Basically you need the extra flag to have the list of bounds and also it's in a const context and you have to store the flag somewhere. So what happens is the bounds are aligned to like four or eight bytes as most types are, which means that the lower three bits of the pointer will always be zero. So you can just use one of these zeros to store the flag. So when you read the pointer, you will mask them all to zero and read it out. And if you want to get the flag, whether it's in a const context, you just read out the Bit.",Interview P10,Contract or Invariant,1,,47,47,1,Author 2,8/20/23,Author 1,1/17/24
10:6,¶ 67,,"Yeah. So generally, you have like 2,000 lines of code file with random type system structures, and then in between you have a tiny bit of sketchy unsafe. ",Interview P10,"Local, Minimal Unsafe",1,,67,67,1,Author 2,8/20/23,Author 1,1/17/24
10:7,¶ 67,,"And at least some of the unsafe data structures, they pass Miri, that's something they didn't use to at some point",Interview P10,Running tests through Miri,1,,67,67,1,Author 2,8/20/23,Author 1,1/17/24
10:8,¶ 67,," some of the more involved unsafe code, those cannot be tested inside Miri because Miri cannot reasonably run the entire Rust compiler because it's very slow.",Interview P10,Miri is slow,1,,67,67,1,Author 2,8/20/23,Author 1,1/17/24
10:9,¶ 71,," And extra types is one of them where basically there's a data structure that's very commonly used in the type system, it also contains unsafe and I don't think it has unit tests whether it passes Miri, although it should pass Miri because it's really simple.",Interview P10,"Local, Minimal Unsafe",1,"Author 2 This isn't necessarily local minimal unsafe, even though the structure is ""really simple,"" that might just be due to the nature of the structure itself, not as an intentional choice for how to implement it. Response I can see why the there might not be enough information to determine whether the implementation has local, minimal use of unsafe.  I just inferred this from the word ""simple"".  But I wasn't aware we were considering intention in this code.  If someone implemented something using minimal unsafe but had no choice in the matter, would we not code it as local, minimal unsafe?",71,71,1,Author 2,8/20/23,Author 1,1/17/24
10:10,¶ 71,,"So it's a list like a normal slice, except instead of storing the length inside the fat pointer, it stores the length in front of the allocation. So it's basically a normal pointer and then the length and then all the elements, which is great because then the slice itself is just eight bytes instead of 16",Interview P10,"Pointer Arithmetic, Unsafe Data Structure",2,,71,71,1,Author 2,8/20/23,Author 1,1/17/24
10:11,¶ 71,,"And it uses an extra type, which is basically, I guess, the proper way to do it, where it's basically saying at first there's a use size and then there's something I don't know about. But I don't think Miri supports that right now because it's a little complicated with M",Interview P10,Miri doesn't support this feature,1,,71,71,1,Author 2,8/20/23,Author 1,1/17/24
10:12,¶ 71,,"Although maybe tree borrows allows it, the new Miri memory model, but the current tree borrows and stacked borrows, stacked borrows is a little older and it's quite strict and there's tree borrows, which is very new and more permissive, probably too permissive. ",Interview P10,"Shifting Ground, Stacked Borrows is too strict",2,,71,71,1,Author 2,8/20/23,Author 1,1/17/24
10:13,¶ 67,,"And now this PR editor macro, it was a follow-up PR editor macro that can do this automatically, basically improving the unsafety. ",Interview P10,Macros,1,,67,67,1,Author 2,8/20/23,Author 1,1/17/24
10:14,¶ 79,,So I would classify bad unsafe as unsafe that's not well encapsulated.,Interview P10,Preference for Safety,1,,79,79,1,Author 2,8/20/23,Author 1,1/17/24
10:15,¶ 79,," I think that's generally the most important thing, just being self-contained, being well isolated, being well encapsulated. And then if you have a small unsafe module, you can clearly document it and document why it's okay and figure out all the reasoning and everything.",Interview P10,"Documented Contract or Invariant, Local, Minimal Unsafe",2,,79,79,1,Author 2,8/20/23,Author 1,1/17/24
10:16,¶ 83,,"For example, there was a semi-recent example where Vec has this splice. I think it was a splice method and splice, you know, it's some kind of iterator and splice and Vec are kind of entangled in some way where I'm not entirely familiar with the code, but I skimmed over it and splice kind of accesses vec's internals in kind of sketchy looking ways. And at some point, the implementation of something deep inside vec's iterator was changed to use something else and it broke splice.",Interview P10,"Requirements Bug, Undefined Behavior",2,,83,83,1,Author 2,8/20/23,Author 1,1/17/24
10:17,¶ 83,,"And there's a cron job every day where Miri checks the standard library and that cron job went off and said, hey, there's something wrong. In this case, it wasn't too bad because LLVM didn't actually exploit the undefined behavior and it was quickly fixed.",Interview P10,It's not a problem,1,,83,83,1,Author 2,8/20/23,Author 1,1/17/24
10:18,¶ 103,,But I wrote one where it doesn't have to have a fixed size. It uses the unstable pointer metadata API,Interview P10,Bit Packing,1,"Author 2 It's unclear to me if this is an example of pointer arithmetic—the unstable pointer metadata API might just be extracting information from the extra bits of a pointer, and not deriving new pointers from others using arithmetic, but I'm unsure. Response. You're right, a better code would be ""bit packing"" what do you think?  I added it tentatively.",103,103,1,Author 2,8/20/23,Author 1,1/17/24
10:19,¶ 103,," I wrote a small library to abstract over storing those inside single users and basically manually doing the enum and tagging and checking. Except the library kind of helps you making sure that you use the strict provenance APIs, which are just generally nicer, better, and not trivial to use. That's another another crate I made.",Interview P10,Unsafe Data Structure,1,"Author 2 Another case where it's somewhat unclear if this is pointer arithmetic. Strict provenance is mentioned, so perhaps, but it doesn't seem quite clear enough here. Response Sure I can agree with that.",103,103,1,Author 2,8/20/23,Author 1,1/17/24
10:20,¶ 71,,"I don't think it has unit tests whether it passes Miri, although it should pass Miri because it's really simple.",Interview P10,Tacit Knowledge,1,"Author 2 This doesn't seem like a violation, since they're indicating that it passes Miri. This would be tacit knowledge though, since they're relying on the subjective judgement of ""simplicity"" to justify that the code is sound. Response I'm not sure where I put violation.  Are you referring to the code a few sentences below this?",71,71,1,Author 2,8/20/23,Author 1,1/17/24
10:21,¶ 119,,"ManuallyDrop the main use case of it. My opinion is basically if you have some kind of data structure and you have a method to insert something into the data structure, generally you can just use like point of right or something to properly move it over. But sometimes you have cases where you cannot just semantically move it over using rust language construct. So basically you have to copy it over, but if you copy it over into the data structure, you now have an element left over. So if that's like a string that's going to cause double free, which is rather bad. So then you first wrap it in a manually drop, then copy it over. And in the end, nothing bad will happen. That's like the way I choose ManuallyDrop.",Interview P10,ManuallyDrop<T>,1,,119,119,1,Author 2,8/20/23,Author 1,1/17/24
10:22,¶ 123,," I think another good use case of MaybeUninit is just if you want to, if you have a type, and you want to convert that type to bytes, you can't convert it to a U8 array. And you can't transmute it because it may have padding bytes. It is padding bytes, maybe uninitialized. So if you have any type whatsoever, you can transmute it to an array of the same size of MaybeUninit U8s. MaybeUninit U8 is basically anything, any byte, everything's allowed.",Interview P10,"MaybeUninit<T>, Transmute",2,,123,123,1,Author 2,8/20/23,Author 1,1/17/24
10:23,¶ 127,,"Yeah, Boxes, I mostly just use Box as an allocate, like allocate and deallocate. So Box new and then immediately into raw",Interview P10,Box<T>,1,,127,127,1,Author 2,8/20/23,Author 1,1/17/24
10:24,¶ 127,,"At some point, I did add at least a few docs. So if you go to the docs today, the docs from, I'm going to go to the current stable docs, I think 1.69.",Interview P10,Documented Contract or Invariant,1,,127,127,1,Author 2,8/20/23,Author 1,1/17/24
10:25,¶ 151,,"But yeah, right now you have to be careful with Box and using Box as an allocator and deallocator is a great way to use Box. It's very simple. It's simpler than the allocator APIs. But yeah, if you have unsafe code, having a Box around is a little sketch, even if it's not undefined behavior, it's still a little sketch.",Interview P10,Box<T>,1,,151,151,1,Author 2,8/20/23,Author 1,3/18/24
10:26,¶ 163,,"Basically when writing unsafe code, I try to run it all through Miri. Try to write a test suit that covers most of the code. You cannot reasonably have a test suit that covers every single branch combination, even though that would be necessary to fully make sure that it doesn't have undefined behavior because Miri just checks what you run and that you still try to have enough tests and then run those through Miri.",Interview P10,Running tests through Miri,1,,163,163,1,Author 2,8/20/23,Author 1,3/18/24
10:27,¶ 163,,"Clippy also has some lints about undefined behavior, although I don't think I've ever really needed those, but they're especially useful if you're learning maybe and have some patterns you think or want to try to do",Interview P10,Clippy for Learning Rust,1,,163,163,1,Author 2,8/20/23,Author 1,3/18/24
10:28,¶ 163,," But Miri is like the main tool because it just finds so much things and it's better than everything else in terms of finding undefined behavior, especially since it's Rust specific. But yeah, it also doesn't hurt, especially if you, if you do FFI, some kind of other, for example, calling a C library, which I haven't really done much. So I can't talk a lot about it, but basically the LLVM sanitizers are great. Like address sanitizer and memory sanitizer and these kinds, they are not as good as Miri, but they're a lot, a whole lot faster. They have only like 30% overhead or something, which is very fast. ",Interview P10,,0,"Author 2 So I think this is definitely a case of using dynamic analysis, but it's missing the ""safety net"" factor, which is the idea that there's some underlying uncertainty about the correctness of code.  Response Yep I agree, that makes sense.",163,163,1,Author 2,8/20/23,Author 1,3/18/24
10:29,¶ 163,," Clippy also has an interesting one for signatures. If you have, if your function takes in a shared reference, but returns a mutable reference, it will lint because generally that's wrong because you can't just return a shared reference mutable reference. There are cases where it's correct. For example, an allocator, if it returns to a mutual reference to a new one. So I've hit those false positives a few times, but I think they're probably useful to include because if someone does hit them, it's great that they're told about it.",Interview P10,Clippy False Positive,1,,163,163,1,Author 2,8/20/23,Author 1,3/18/24
10:30,¶ 171,,". Basically here, that's a false positive because inside the arena allocator, you can turn mut shared references into mutable reference because not really turning them. It's just creating new ones. That's like my classical case where this is false positive,",Interview P10,Clippy False Positive,1,,171,171,1,Author 2,8/20/23,Author 1,3/18/24
10:31,¶ 187,,"But also very recently, as of like one or two weeks ago, Felix from the Rust compiler team and AWS announced a new tool, CrabCake. It's very experimental and not really released and ready. I cannot find anything about it. I think it was written CrabCake.",Interview P10,Krabcake,1,,187,187,1,Author 2,8/20/23,Author 1,3/18/24
10:32,¶ 187,,"Which is a Valgrind implementation of stacked borrows. Implementing stacked borrows instead of inside of the compile time function evaluation interpreter of Rust C, like Miri, which is very slow. It's implemented inside Valgrind, which is slow, but a lot faster. ",Interview P10,Valgrind,1,,187,187,1,Author 2,8/20/23,Author 1,3/18/24
10:33,¶ 199,,"I think the biggest issue with Rust unsafe isn't necessarily the tools, but just the spec or rather the absence of the spec. If you write unsafe code today, you write it against the void. Isn't it how we have like stack borrows and three borrows and you can write it against three borrows or you can write it against stack borrows or neither or both or just address sanitizer or whatever. You don't really know what's allowed and what isn't.",Interview P10,Shifting Ground,1,,199,199,1,Author 2,8/20/23,Author 1,3/18/24
10:34,¶ 199,,"Like again, some things are currently disallowed, like the Box aliasing, but maybe it's allowed in the future. ",Interview P10,Box<T>,1,,199,199,1,Author 2,8/20/23,Author 1,3/18/24
10:35,¶ 199,,"But if you, for example, call FFI, you can't use Miri. So nothing will save you",Interview P10,Wants Solution,1,,199,199,1,Author 2,8/20/23,Author 1,3/18/24
10:36,¶ 127,,"And this was just added like seven, eight more years ago at some point, because basically why not was like the comment roughly. And then people hit this sometimes. And I don't think there was any documentation whatsoever about this. It was just something you had to know.",Interview P10,Shifting Ground,1,,127,127,1,Author 1,9/1/23,Author 1,1/17/24
10:37,¶ 127,,"Box has some rather strange and strict aliasing semantics. So if you store a Box and store a pointer into the Box and then move the Box, the pointer will be invalidated, which is not very useful. It's also funny because it's like, it's also exploited by LLVM to some degree. ",Interview P10,Box<T>,1,,127,127,1,Author 1,9/1/23,Author 1,1/17/24
10:38,¶ 123,,"MaybeUninit is just, for example, if you have an array that may be uninitialized for performance, if you have like a one kilobyte array on the stack, like in practice, it probably won't be too bad if I just initialize it and you should initialize it. But if you realize that it's too slow to initialize it, you can just use an array of MaybeUninit bytes, initialize them with uninitialized. So not initialize them and then fill it up as needed, which make it better performance. ",Interview P10,"Increase Performance, MaybeUninit<T>",2,,123,123,1,Author 1,9/1/23,Author 1,1/17/24
10:39,¶ 35,,"generally when I reach for unsafe code, I do it because safe Rust can't express something I would want to express.",Interview P10,No Other Choice,1,,35,35,1,Author 1,9/3/23,Author 1,1/17/24
10:40,¶ 79,,"if you have some weird aliasing around, that's some weird non-standard aliasing requirements, for example, several things that point to things. And if you use references for that, it's kind of bad. Sometimes it's undefined behavior with the references, because, for example, you have aliasing with references.",Interview P10,Code Smells,1,,79,79,1,Author 1,9/3/23,Author 1,1/17/24
10:41,¶ 103,,"One cool example, for example, is I wrote the Vec with a T, a normal Vec, basically, except for Vec, the T has to be sized. The value has to have a fixed size. But I wrote one where it doesn't have to have a fixed size. It uses the unstable pointer metadata API, and it's quite funny.",Interview P10,Unsafe Data Structure,1,,103,103,1,Author 1,9/3/23,Author 1,1/17/24
10:42,¶ 107,,"But yeah, when I write unsafe, it's usually that kind of thing. It's just things that are fundamentally impossible with safe Rust. Like with junk, it kind of splits the metadata at the pointer in weird ways, which just cannot be expressed to see safe Rust because the borrow check has no idea what you're doing.",Interview P10,No Other Choice,1,,107,107,1,Author 1,9/3/23,Author 1,1/17/24
10:43,¶ 111,,"Yeah, it's too strict because it can't support extern types, which is just something that is important. More generally, that's the problem. If you have a reference to something, then stacked borrows only gives you permission to read as much as the type of the reference covers. ",Interview P10,Stacked Borrows is too strict,1,,111,111,1,Author 1,9/3/23,Author 1,1/17/24
10:44,¶ 111,,"So say I had a struct with two fields, like repr(C), laid after each other. And then I took a reference just to the first field. And then using unsafe code, also access the second field that would not be allowed on stack borrows, but it's generally regarded as something that should be allowed. There's an issue on the unsafe code guidelines. It's also called the ref header problem because basically you have a reference to a header. And yeah, there's a lot of discussion here.",Interview P10,Shifting Ground,1,,111,111,1,Author 1,9/3/23,Author 1,1/17/24
10:45,¶ 143,,"How it's kind of a foot gun because you would expect, especially for example, if you're from C++, you would just, you would just expect it to, for Box to just be a pointer that deallocates on drop.",Interview P10,Feature Disparity,1,,143,143,1,Author 1,9/3/23,Author 1,3/18/24
10:46,¶ 143,,"But then suddenly you write some reasonable code. You, you allocate it on the book, on the heap through Box, you create a pointer to it, and then you move the Box around. And if you move the Box, the heap stays constant. That's kind of the point of the whole thing. So we'd assume it to work, but it doesn't, at least in the current implementation of Stacked Borrows and also rustc.",Interview P10,Box<T>,1,,143,143,1,Author 1,9/3/23,Author 1,3/18/24
10:47,¶ 151,,"it's still a little weird to have raw pointers and Boxes around because it may give, it may urge someone to change it in a way that will break.",Interview P10,Code Smells,1,,151,151,1,Author 1,9/3/23,Author 1,3/18/24
10:48,¶ 151,,"So I generally prefer to just avoid Box inside unsafe code. If there are other raw pointers around similarly, that code is just like get unchecked or something. But if there are raw pointers to the thing, it's better to avoid Box.",Interview P10,Box<T>,1,,151,151,1,Author 1,9/3/23,Author 1,3/18/24
10:49,¶ 163,,"And I guess you can kind of run Rust compiler in Miri if you have a lot of time and a lot of RAM and a lot of CPU, but it's not going to be something that's worth i",Interview P10,Miri is slow,1,,163,163,1,Author 1,9/3/23,Author 1,3/18/24
10:50,¶ 179,,"But you're also kind of right, adding some new undefined behavior detection that's slow isn't really controversial because yeah, maybe the detection is generally slow, but it decreases runtime by 1% so no one will care. Yes, that's also true. It's kind of an advantage in some ways because you could just, no one will complain a lot if you make address sanitizer two times as slow. Some people will probably be very angry because they rely on it being so fast. But if you make Miri two times slower, some people may also be angry because Miri is slow already, but probably less angry because Miri is slow already. ",Interview P10,Miri is slow,1,,179,179,1,Author 1,9/3/23,Author 1,3/18/24
10:51,¶ 179,," And I once ran rustc inside Valgrind and it complained about uninitialized memory read somewhere in safe code. And I was pretty sure that it was probably false positives. Also, I did post it on Zulip, the Rust project communication platform, and one of the authors of Valgrind, [name], you may know them. They also came in and basically said they do work on the Rust compiler. It was probably false positive.",Interview P10,Valgrind,1,,179,179,1,Author 1,9/3/23,Author 1,3/18/24
10:52,¶ 199,,"Other things are currently disallowed, but won't cause bad things in LLVM. Maybe they'll be allowed at some point.",Interview P10,It's not a problem,1,,199,199,1,Author 1,9/3/23,Author 1,3/18/24
10:53,¶ 199,,"So basically to validate your unsafe code, you first need to know whether it's correct in the first place. And today you can't really tell whether the unsafe code is correct because there's no correct. ",Interview P10,Shifting Ground,1,,199,199,1,Author 1,9/3/23,Author 1,3/18/24
10:54,¶ 199,,"The absence of any spec, the concrete spec will probably take a few years for that to be finished, but now that we have the operational semantics team, it should slowly improve and get more clear.",Interview P10,Shifting Ground,1,,199,199,1,Author 1,9/3/23,Author 1,3/18/24
11:1,¶ 7,, a lot of the stuff I do is with language and compiler design and databases and such,Interview P11,Databases,1,"For Author 1: shouldn't this also be ""Compilation & Interpretation""?",7,7,1,Author 2,8/20/23,Author 1,1/17/24
11:2,¶ 15,,"I mean, the less safe things, you got to squeeze out the little bit of performance.",Interview P11,Increase Performance,1,,15,15,1,Author 2,8/20/23,Author 1,1/17/24
11:3,¶ 15,," I mean, currently I'm writing a JIT compiler, which involves a lot of unsafe, FFI, that sort of thing. Yeah.",Interview P11,Compilation & Interpretation,1,,15,15,1,Author 2,8/20/23,Author 1,1/17/24
11:4,¶ 23,,"And so, generally speaking, it's backed up by a benchmark of some side.",Interview P11,Profiling,1,,23,23,1,Author 2,8/20/23,Author 1,1/17/24
11:5,¶ 23,,"I'll totally admit that, like, sometimes it's more of a, like, I think this is going to be a hot thing. So I'm going to kind of prematurely optimize. Probably not the best habit, but realistically speaking, it does happen.",Interview P11,Tacit Knowledge,1,"Author 2 This wouldn't be code smells—that indicates a bug or vulnerability. I think this would be more, ""tacit knowledge,"" Response I totally got the two mixed up!",23,23,1,Author 2,8/20/23,Author 1,1/17/24
11:6,¶ 35,,"I end up writing a lot of like arenas and arena style things, because I'm like, you know, for one reason or another, specializing something to address a specific task. And you know, like, indice-based arenas, I've done them plenty, but sometimes you need like a pointer-based one.",Interview P11,"Custom Allocator, Pointer Arithmetic, Unsafe Data Structure",3,,35,35,1,Author 2,8/20/23,Author 1,1/17/24
11:7,¶ 35,," Like another recent data structure I've written was basically like a dynamically dispatched vector. It was like a VEC that held one V-table pointer in heterogeneous elements, and yeah, I mean, yeah, that sort of thing.",Interview P11,Unsafe Data Structure,1,,35,35,1,Author 2,8/20/23,Author 1,1/17/24
11:8,¶ 43,, I end up like having intrinsic functions of sorts that I'm calling from within JIT code,Interview P11,Intrinsics,1,"Author 2 The type of the intrinsic isn't clearly identified as volatile. Response You're right, I guess I'm missing something here-- aren't all intrinsics unsafe?  I'll remove the code, but this is hinting at a difference in understanding here.",43,43,1,Author 2,8/20/23,Author 1,1/17/24
11:9,¶ 55,,"I try to avoid situations like that because it's just kind of setting yourself up for pain and suffering in the, in the longterm",Interview P11,,0,"Author 2 This doesn't seem like a situation where someone's reasoning about unsafe code and finding that difficult, it seems more related to the Simple FFI code nearby. I extended that one, but I think we should remove this code. Response Okay, I agree.",55,55,1,Author 2,8/20/23,Author 1,1/17/24
11:10,¶ 55,,"I try to avoid situations like that because it's just kind of setting yourself up for pain and suffering in the, in the longterm. I mean, truly speaking, I try to keep things as, I guess, limited as possible to where you, you know, like, allocate a Box, call a C function that doesn't like capture the pointer and, and then, you know, deallocate the Box after, you know, that sort of thing, like keeping the scope as, as minimal as possible.",Interview P11,"Allocation in Rust, Simple FFI",2,,55,55,1,Author 2,8/20/23,Author 1,1/17/24
11:11,¶ 55,,"I mean, I definitely have done stuff like I've written LLVM bindings, which was not a fun, not a fun task to where essentially you've got long lived references flying around and it's not fun to deal with. ",Interview P11,Difficult FFI,1,,55,55,1,Author 2,8/20/23,Author 1,1/17/24
11:12,¶ 83,,"Um, you usually threaded this is a big issue because a lot of C code bases are not, or like C and C plus plus code bases are not very transparent about their, their behavior in the presence of threading. Like even, you know, lib C is kind of notorious for how terribly some random, seemingly innocuous functions function in the presence of multi-threading.",Interview P11,Different FFI Memory Model,1,,83,83,1,Author 2,8/29/23,Author 1,1/17/24
11:13,¶ 55,,"you know, like, allocate a Box, call a C function that doesn't like capture the pointer and, and then, you know, deallocate the Box after, you know, that sort of thing",Interview P11,Box<T>,1,,55,55,1,Author 2,8/29/23,Author 1,1/17/24
11:14,¶ 91,,"Well, I mean, really, I guess kind of the core or most of the issues I've had with FFI are trying to figure out or it is the fact that it's really difficult to figure out a lot of the properties of a given code base. Like it can be very difficult to figure out like, you know, are you actually mutating something? Are you retaining pointers to this? You know, like if I give you like some input data, are you going to retain a pointer to that and keep operating on it later? You know, are you referencing it?",Interview P11,"Difficult FFI, Unsafe is Difficult to Understand",2,,91,91,1,Author 2,8/29/23,Author 1,1/17/24
11:15,¶ 105,," I guess I've kind of learned of just like be or learned to kind of be as conservative as possible in regards to bindings to where I'm basically only messing with pointers and like, you know, scalar primitives and pointers, you know, like typed pointers, sure. And like non-null and option non-null. For the most part, it's primarily pointer types across the FFI boundary.",Interview P11,Simple FFI,1,Author 2 Unclear if this is an opaque pointer or if the memory layout is visible across boundaries for struct types. Response I agree.,105,105,1,Author 2,8/29/23,Author 1,1/17/24
11:16,¶ 117,,"And so in terms of total correctness, no, you can't pass a 20 or 128 bit integer across the boundary because, you know, C doesn't support that. You know, some C compilers do, but C does not support that, you know, as a standard, which, you know, is very much the fault of C. But yeah, yeah, yeah.",Interview P11,Different FFI Memory Model,1,,117,117,1,Author 2,8/29/23,Author 1,1/17/24
11:17,¶ 121,,"I wish a lot of them were kind of better maintained, because a lot of them are kind of very much passively maintained. You know, they're not really like or which like, you know, no fault to the maintainers because, you know, we all have lives and it's hard to constantly maintain big code bases. But you know, it is unfortunate that a lot of them are kind of in the state of like, if you want something, you can do it. Because that can be difficult if you aren't familiar with the code base and stuff. ",Interview P11,Limitation of Binding Tool,1,,121,121,1,Author 2,8/29/23,Author 1,1/17/24
11:18,¶ 125,,"Yeah, or if I've just got like two functions that I need from WinAPI, I can just like, you know, manually write the binding. It's not that big of a deal. But yeah, yeah.",Interview P11,Generation VS Validation,1,,125,125,1,Author 2,8/29/23,Author 1,1/17/24
11:19,¶ 137,,"PY03, like it's a pretty defined interface that they're making",Interview P11,PyO3,1,,137,137,1,Author 2,8/29/23,Author 1,1/17/24
11:20,¶ 153,," this is another, I guess, custom data structure, like I wrote a thin string a while ago that stores like the length and capacity on the heap along with the data. And so like, you know, you think it's going to act like a normal string, but you have to be really careful in regards to pointer invalidation because it's very, you know, like, if the operation reallocates the pointer you previously had is completely invalid. That sort of thing.",Interview P11,"Contract or Invariant, Unsafe Data Structure",2,,153,153,1,Author 2,8/29/23,Author 1,1/17/24
11:21,¶ 149,,". So they're the kind of the constraints that they have, like, you know, you need to not, you know, write past the end of an array because you didn't, or a vector because you didn't allocate enough memory, you know, you need to be mindful of like what operations reallocate or could possibly reallocate that sort of thing, you know, like, are your pointers going to be invalidated? ",Interview P11,Contract or Invariant,1,"Author 2 This doesn't seem like an example of a bug that was encountered by the person, just an example of a bug that can be found, so I think we should just label this as contract or invariant. Response Makes sense!",149,149,1,Author 2,8/29/23,Author 1,1/17/24
11:22,¶ 165,,Couple data races. Some little like fun memory ordering bugs with atomics.,Interview P11,"Atomic Intrinsics, Concurrency Bug, Data Races",3,,165,165,1,Author 2,8/29/23,Author 1,1/17/24
11:23,¶ 178,,"Usually it's like reference and validation to where you, you know, like, like, or calling like as mut or as a mutable pointer or getting a mutable pointer to a vector and storing it and then calling the vectors length, ",Interview P11,"Borrowing or Provenance Bug, Stacked/Tree Borrows Violation",2,,178,178,1,Author 2,8/29/23,Author 1,1/17/24
11:24,¶ 178,,like that's like a a kind of debated case at the moment because the memory model isn't fully decided.,Interview P11,Shifting Ground,1,,178,178,1,Author 2,8/29/23,Author 1,1/17/24
11:25,¶ 178,,"Even though like in practice, it's not actually an issue. It's like a kind of a model issue. Yeah. Or an issue on a model level.",Interview P11,It's not a problem,1,,178,178,1,Author 2,8/29/23,Author 1,1/17/24
11:26,¶ 182,," all of the interaction with the JIT or like, I guess the produced code is, is basically just one big un-safe block. So like, not great, because it's really hard to express that kind of thing. And like inherently when you've got like, you know, when you're taking random pointers, quote unquote, out of nowhere, turning in the function pointers that are also unsafe to call, you know, you're just going to inherently interact with a lot of unsafety.",Interview P11,"Extensive, Non-local Unsafe, Unsafe is Difficult to Understand",2,,182,182,1,Author 2,8/29/23,Author 1,1/17/24
11:27,¶ 190,,"The JIT? That's very difficult. Yeah. I mean, it's a very abnormal case, for like kind of the non-JIT side of the code base. Everything definitely is encapsulated where in safety is involved. And I try to make it as easy to reason about as possible, but it's just like a very atypical case to where it's kind of a pervasive, like trust me kind of thing.",Interview P11,"""Safe"" API, Exposing a Safe API",2,"Author 2 This doesn't feel difficult to encapsulate necessarily. At least, it's possible that it was quite easy for this person to mark everything as safe. It's more that they don't have a perfect guarantee of safety. This is a great example of ""Safe API."" Response Okay, I can see that.  I already coded a part of this as Safe API, I'll remove that too to avoid duplicates.",190,190,1,Author 2,8/29/23,Author 1,1/17/24
11:28,¶ 194,,"Well, it's, it requires non-local knowledge, you know, like you can't just look at a given unsafe block and be like, yeah, based on, you know, the context of which this is called in, this is correct. It's, you know, you have to know the innards of the JIT compiled function. So you have to, you know, you just have to have external knowledge outside of that specific unsafe block, which is, you know, so it's just not encapsulated.",Interview P11,"Extensive, Non-local Unsafe, Unsafe is Difficult to Understand",2,,194,194,1,Author 2,8/29/23,Author 1,1/17/24
11:29,¶ 210,,"Yeah, I mean, Miri is incredibly helpful, you know, like it's a great diagnostic tool. Usually for a lot of them, I end up or I guess more of the the checkers, you know, like all the sanitizers, Miri, that sort of thing. I usually run those as part of CI or usually part of my or for some things part of my test suite, if it's, you know, like it specific enough.",Interview P11,Running tests through Miri,1,,210,210,1,Author 2,8/29/23,Author 1,1/17/24
11:30,¶ 210,," A lot of I do wish that some of the checkers were, I guess, more detailed in the reports, because a lot of times it can be kind of hard to nail down like what's going around where specifically. ",Interview P11,Wants Solution,1,,210,210,1,Author 2,8/29/23,Author 1,1/17/24
11:31,¶ 210,,"But I'm a Clippy advocate. I'm a Rust FMT advocate. I use them extensively. I think they're fantastic tools. I think it's great that they help enforce consistent codes, code styles across not just code bases, but entire ecosystems",Interview P11,Clippy for Clean Code,1,,210,210,1,Author 2,8/29/23,Author 1,1/17/24
11:32,¶ 214,," I mean, a lot of times, like, with the JIT stuff, I basically just can't run Miri on them, which sucks. But also, I'm not sure it's really a, I mean, really even possible for Miri to like, circumvent that without Miri also bundling an x86 interpreter, which would not be fun.",Interview P11,Wants Solution,1,,214,214,1,Author 2,8/29/23,Author 1,1/17/24
11:33,¶ 236,,"But in practice, it's just like not an issue as long as it's passing the sanitizers",Interview P11,Dynamic Analysis Safety Net,1,,236,236,1,Author 2,8/29/23,Author 1,1/17/24
11:34,¶ 252,,Kani,Interview P11,Kani,1,,252,252,1,Author 2,8/29/23,Author 1,1/17/24
11:35,¶ 252,,crucible,Interview P11,Crucible,1,,252,252,1,Author 2,8/29/23,Author 1,1/17/24
11:36,¶ 244,,"And it's, I mean, even though it's not exploding now, it will probably explode later or explode if you turn on like, you know, LTO, and LLVM has access to cross function information.",Interview P11,Linking Time Optimization (LTO),1,,244,244,1,Author 2,8/29/23,Author 1,1/17/24
11:37,¶ 252,,"I definitely wish that verification to some extent was more fleshed out in Rust. You know, I've like, I've tried a bunch of the tools, like Kani and crucible, crucible, yeah, I think it's crucible. But a lot of like the kind of contract based proofs layered on top of Rust. And they're really cool. But I wish they were more kind of inherently parts of Rust, because, or in like had the ability to express more, I guess, complicated, this like invariants that were required to be able to turn, like kind of hoist a lot of currently unsafe code into safe code.",Interview P11,Wants Solution,1,,252,252,1,Author 2,8/29/23,Author 1,1/17/24
11:38,¶ 256,,"set length on a vector to be able to have the constraint that, you know, new length must be less than capacity. And all elements up to new length must be initialized to be able to have those two contracts on that function would be able to make it a safe function. And so, you know, that sort of thing would be amazing, in my opinion.",Interview P11,Wants Solution,1,,256,256,1,Author 2,8/29/23,Author 1,1/17/24
11:39,¶ 256,,"And like, I'm also a big fan of refinement types. I think refinement types would be awesome for us.",Interview P11,Wants Solution,1,,256,256,1,Author 2,8/29/23,Author 1,1/17/24
11:40,¶ 260,,Prusti,Interview P11,Prusti,1,,260,260,1,Author 2,8/29/23,Author 1,1/17/24
11:41,¶ 260,, think Prusti is kind of the most complete one that I've used. ,Interview P11,Formal verification,1,,260,260,1,Author 2,8/29/23,Author 1,1/17/24
11:42,¶ 3,,I really enjoy a lot of the ergonomics and the features that it provides. It's the niceness of using a functional programming language without a lot of the baggage that can come along with it.,Interview P11,Rust is ergonomic,1,,3,3,1,Author 1,9/3/23,Author 1,1/17/24
11:43,¶ 11,,Ergonomics plus safety plus speed.,Interview P11,"Memory Safety, Rust is ergonomic, Rust Performs Well",3,,11,11,1,Author 1,9/3/23,Author 1,1/17/24
11:44,¶ 27,,"Yeah. I mean, that's most of the case, or like data structures that you can't really express without it.",Interview P11,No Other Choice,1,,27,27,1,Author 1,9/3/23,Author 1,1/17/24
11:45,¶ 51,,"That's not really my job, but, um, most of my like other language consumption is kind of on my own time because I do it because it interests me. ",Interview P11,For Fun,1,,51,51,1,Author 1,9/3/23,Author 1,1/17/24
11:46,¶ 55,,", that sort of thing, like keeping the scope as, as minimal as possible. ",Interview P11,"Local, Minimal Unsafe",1,,55,55,1,Author 1,9/3/23,Author 1,1/17/24
11:47,¶ 55,,"But that's more of a, I wouldn't necessarily say that's kind of like an inherent rust problem or even really a rust problem at all. That's more of kind of, in my opinion, like a symptom of how C plus plus does memory management.",Interview P11,Different FFI Memory Model,1,,55,55,1,Author 1,9/3/23,Author 1,1/17/24
11:48,¶ 59,,"LLVM is definitely a really, really weird, like, I mean, it does a bunch of incredibly sketchy stuff and runtime type information and yeah, I mean, yeah, I don't know, honestly, um, like, I mean, a lot of sufficiently large C plus plus code bases turn out really kind of cursed editions, but yeah, I don't know. I don't know. Honestly.",Interview P11,"C++ is Difficult, Different FFI Memory Model",2,,59,59,1,Author 1,9/3/23,Author 1,1/17/24
11:49,¶ 67,,"Yeah, kind of, kind of minimizing the liability to some extent.",Interview P11,"Local, Minimal Unsafe",1,,67,67,1,Author 1,9/3/23,Author 1,1/17/24
11:50,¶ 75,,"I mean, there's no way to really automate that check of that a, you know, that an arbitrary C function doesn't capture your pointer. I mean, generally speaking, most bindings or, you know, functions will be relatively sane with that sort of thing, but yeah, there's, I mean, there's no really way to guarantee that unless you're doing some really deep, like, I don't know, you can probably verify it with a live or something.",Interview P11,Difficult FFI,1,,75,75,1,Author 1,9/3/23,Author 1,1/17/24
11:51,¶ 83,,"And so that can be a very difficult thing of trying to ensure like, you know, or trying to even figure out in the first place, like, can I pass this, you know, my like LLVM handle across threads or is it going to behave horrifically if I do that and trying to like actually figure out whether or not that's an okay thing to do in the first place can be really difficult because some like some, or a lot of code bases don't even like say it in the first place.",Interview P11,Difficult FFI,1,,83,83,1,Author 1,9/3/23,Author 1,1/17/24
11:52,¶ 95,,"You know, are you sound in the presence of threads? Do you use thread local variables? Like how do you actually behave? It can be really hard to figure out sometimes, which, you know, is annoying if you're trying to make like a general purpose library or, you know, like kind of a library layer on top of that to where you have an ergonomic Rust interface.",Interview P11,Difficult FFI,1,,95,95,1,Author 1,9/3/23,Author 1,1/17/24
11:53,¶ 99,,"A lot of like reading documentation, trying to ask people things, that sort of thing.",Interview P11,Engaging with the Rust Community,1,,99,99,1,Author 1,9/3/23,Author 1,1/17/24
11:54,¶ 109,,"I mostly avoid like trying to deal with, you know, like arrays and that sort of thing or, you know, non or types with an undefined representation and that sort of thing.",Interview P11,Simple FFI,1,,109,109,1,Author 1,9/3/23,Author 1,1/17/24
11:55,¶ 113,,I'm the person who wrote the randomized layout flag.,Interview P11,Rust Project Contributor,1,,113,113,1,Author 1,9/3/23,Author 1,1/17/24
11:56,¶ 129,,"It's very convenient for like header generation. It's very nice to be able to like automatically keep like, you know, your C headers, like, you know, if you're exporting a C interface from a library, it's very, very convenient to have it just like automatically be updated. Super nice.",Interview P11,Generation VS Validation,1,,129,129,1,Author 1,9/3/23,Author 1,1/17/24
11:57,¶ 133,,"Yeah, yeah. It's incredibly convenient. Yeah.",Interview P11,cbindgen,1,,133,133,1,Author 1,9/3/23,Author 1,1/17/24
11:58,¶ 137,,"I guess, probably the biggest difficulty on that side would be like, how do we translate Rust or like the given Rust documentation into something that's sensible with or for another language? Or how do we give the user the ability to create sensible documentation?",Interview P11,Idiomatic FFI Encapsulation,1,,137,137,1,Author 1,9/3/23,Author 1,1/17/24
11:59,¶ 161,,"They're usually a little bit easier to address because it just means you generally speaking, that means you just forgot something somewhere. Instead of like, oh, I structured this incorrectly, I used this thing after I shouldn't that sort of thing. It's a little less insidious of kind of a bug.",Interview P11,"Memory Leak, Memory Leaks",2,,161,161,1,Author 1,9/3/23,Author 1,1/17/24
11:60,¶ 174,,"I'm like very familiar with the kind of the aliasing rules and everything surrounding that and just aliasing and provenance as a concept because I interact with it a lot in terms of compilers and stuff. And so I think about it a lot. And so because I like, I mean, I mean, I don't want to like try and toot own horn or anything like that. Like just because I think about it a lot and because I've dealt with it a lot, I generally don't run into that sort of issue. ",Interview P11,Tacit Knowledge,1,,174,174,1,Author 1,9/3/23,Author 1,1/17/24
11:61,¶ 174,,"But from my co-workers and stuff, I've definitely fixed plenty of like issues that they've unintentionally written that seem like stupid little nitpicks. But it's, you know, for one reason or another, important to provenance.",Interview P11,"Borrowing or Provenance Bug, Stacked/Tree Borrows Violation",2,,174,174,1,Author 1,9/3/23,Author 1,1/17/24
11:62,¶ 186,,"you are doing something very unsafe to where you're doing something that the compiler cannot possibly check. And so you have to take over the wheel and tell the compiler, I know what I'm doing. This is correct.",Interview P11,Tacit Knowledge,1,,186,186,1,Author 1,9/3/23,Author 1,1/17/24
11:63,¶ 194,,"It's not like a local reasoning, or you can't really locally reason about it. You know, you can't say like, oh, you know, we already checked that the pointer was non-null. Therefore, non-null new unchecked is correct to call here. You know, it's just not a locally encapsulated thing.",Interview P11,"Extensive, Non-local Unsafe",1,,194,194,1,Author 1,9/3/23,Author 1,1/17/24
11:64,¶ 202,,"Yeah, it's [redacted]. Gotcha.",Interview P11,"Compilation & Interpretation, Databases",2,"For Author 1: why is this ""Compilation & Interpretation""?",202,202,1,Author 1,9/3/23,Author 1,1/17/24
11:65,¶ 232,,"Oh, yeah. I mean, I've written like buggy JIT code that I had to run like, like MSAN and ASAN on in order to figure out what was going wrong where, because you just can't comprehend JIT compiled code.",Interview P11,"ASAN, MSAN",2,,232,232,1,Author 1,9/3/23,Author 1,1/17/24
11:66,¶ 236,,"I'm not sure that I'm not necessarily sure how useful Miri on foreign code is in the first place, because I don't think it's very or I don't think it's really correct or even possible in the first place to apply like Rust aliasing rules to other languages. Because I mean, that quickly becomes like a very difficult thing to navigate of like, oh, this pointer or this like char star pointer is actually, you know, a mutable reference. Have fun with dealing with that.",Interview P11,"Different FFI Memory Model, Miri doesn't support this feature",2,,236,236,1,Author 1,9/3/23,Author 1,1/17/24
11:67,¶ 252,,"I've like, I've tried a bunch of the tools, like Kani and crucible, crucible, yeah, I think it's crucible.",Interview P11,Formal verification,1,,252,252,1,Author 1,9/3/23,Author 1,1/17/24
11:68,¶ 284,,"Cause yeah, like, yeah, gradual proofs or a gradual dependent types or refinement types or whatever combination of would be, I mean, that'd be amazing for rust. Yeah, to be able to just prove more non local things. And yeah, yeah, that'd be really cool.",Interview P11,Wants Solution,1,,284,284,1,Author 1,9/3/23,Author 1,1/17/24
12:1,¶ 3,,"Once I learned about Rust, the ownership system and kind of like the whole affine type system based safety and the model surrounding that attracted us for a variety of research purposes.",Interview P12,Memory Safety,1,,3,3,1,Author 2,8/10/23,Author 1,1/17/24
12:2,¶ 3,,"As we used it more, we used it to create a new OS from scratch",Interview P12,Operating & Embedded Systems,1,,3,3,1,Author 2,8/10/23,Author 1,1/17/24
12:3,¶ 11,,"So to be more specific, you know, in operating a system, you know, you need to communicate with the CPU model specific registers on X86. You know, ARM has a similar notion of these various hardware registers and inherently these are unsafe to access because they can have loads of side effects that could completely change the behavior of the system, be it things related to how virtual memory is managed or things related to, you know, bootstrap of the system when you're taking over from a bootloader, right? So, and then on the things like device access, you know, it's the same thing. Ideally, we try to mask all of this unsafety with safer, safe, higher level interfaces, but at some point, right, like in the house somewhere, you need to descend into the low level raw primitive access, you know, like writing bytes to a particular region of some MMIO register. It's just, it's unavoidable to a certain extent.",Interview P12,No Other Choice,1,,11,11,1,Author 2,8/10/23,Author 1,3/21/24
12:4,¶ 11,, like writing bytes to a particular region of some MMIO register,Interview P12,Interacting with hardware,1,,11,11,1,Author 2,8/10/23,Author 1,3/21/24
12:5,¶ 15,," There are definitely some cases where I have considered using unsafety either because it's easier than developing a safe abstraction or because of potential performance issues. I don't know. Okay, actually I can't think of one case where we had intentionally chosen to do something unsafe and that was a heap allocator implementation. ",Interview P12,"Easier or More Ergonomic, Increase Performance",2,,15,15,1,Author 2,8/10/23,Author 1,3/21/24
12:6,¶ 15,,"Okay, actually I can't think of one case where we had intentionally chosen to do something unsafe and that was a heap allocator implementation. ",Interview P12,Custom Allocator,1,,15,15,1,Author 2,8/10/23,Author 1,3/21/24
12:7,¶ 15,,"So you typically store it within the actual memory that has been allocated for a particular purpose, right? You allocate, you know, let's say you allocate eight kilobytes, right? So some tiny part of that eight kilobytes is used for the metadata, right? There is apparently no way to represent this in, say, Rust, right? This is in effect a self-referential data structure, right? ",Interview P12,Multiple / cyclic aliasing,1,,15,15,1,Author 2,8/10/23,Author 1,3/21/24
12:8,¶ 15,,"So that's one aspect of, that's one reason why it's hard to represent this sort of behavior with fully safe code. So you could do it, right? But that would be some performance overhead, right?",Interview P12,Increase Performance,1,,15,15,1,Author 2,8/10/23,Author 1,3/21/24
12:9,¶ 15,,"So you'd have to, and it's also limiting in the very nature of the way that you could use it. So for example, if I only reserve, you know, I don't know, 128 bytes or something for this statically, then I can't, you know, if I change my system to where I need to allocate so many more regions of something before the heap allocator is available, then I can no longer do it without making changes to the code. So it makes it more of a brittle interface",Interview P12,Easier or More Ergonomic,1,,15,15,1,Author 2,8/10/23,Author 1,3/21/24
12:10,¶ 15,,"Just because it was mostly wasteful of memory and then we're passing around all these reference types to make sure that things last as long as they should, so like arcs everywhere. Not great, right?",Interview P12,Arc<T>/Rc<T>,1,,15,15,1,Author 2,8/10/23,Author 1,3/21/24
12:11,¶ 15,,"So because of that, you know, to represent something like this, you're using like kind of a graph of Rc/Arc and weaks everywhere, and it's slower than just assuming, you know, with unsafety and, you know, or requiring rather the implementer of everything internal to that crate to make sure that it's done correctly. ",Interview P12,Arc<T>/Rc<T>,1,,15,15,1,Author 2,8/11/23,Author 1,3/21/24
12:12,¶ 15,,still provides a somewhat safe interface,Interview P12,Exposing a Safe API,1,,15,15,1,Author 2,8/11/23,Author 1,3/21/24
12:13,¶ 43,,"I mean, the, the very interface for the heap is unsafe, but then it's wrapped around higher level types like Box, arc, vec, which have safe constructors. So assuming that you implemented your heap correctly, those will always work.",Interview P12,"Arc<T>/Rc<T>, Box<T>",2,,43,43,1,Author 2,8/11/23,Author 1,3/21/24
12:14,¶ 47,,"That sort of thing, inherently unsafe, because you are writing physical page table entries that the hardware MMU can then know about and understand, and you've got to make sure that you're doing that correctly, that you're calculating the offsets that go into each one of these page table entries correctly. ",Interview P12,"Contract or Invariant, No Other Choice",2,,47,47,1,Author 2,8/11/23,Author 1,3/21/24
12:15,¶ 47,,you are writing physical page table entries that the hardware MMU can then know about and understand,Interview P12,Interacting with hardware,1,,47,47,1,Author 2,8/11/23,Author 1,3/21/24
12:16,¶ 47,," So then we have a bunch of types that atop the underlying unsafe virtual memory implementation, which try to, I mean, in my opinion, they succeed, but the goal of them is to strive to remove unsafety for anybody accessing or using a virtual memory subsystem externally.",Interview P12,"""Safe"" API, Exposing a Safe API, Tacit Knowledge",3,,47,47,1,Author 2,8/11/23,Author 1,3/21/24
12:17,¶ 7,,"it's difficult to determine how state moves and propagates throughout subsystems in an operating system. And ownership seemed, at least on the surface, a better way to clarify that or make it more clearly defined",Interview P12,Memory Safety,1,,7,7,1,Author 2,8/16/23,Author 1,1/17/24
12:18,¶ 51,,"It's not accessible by anybody else. If they mapped it, if they try to access mutably, we check and guarantee that it was mapped in a writable way so you don't get like unexpected page faults. And then the only way to actually access that memory is to borrow it as an instance of a specific type. There are a lot of, you know, restrictions on what that type can be, you know, given by various trait bounds. But we check, you know, the size of that type.",Interview P12,,0,"Author 2 They aren't speaking about some concession or uncertainty about safety here, so it wouldn't be a ""Safe API."" Response Okay, I see what you mean.",51,51,1,Author 2,8/16/23,Author 1,3/21/24
12:19,¶ 51,,"in [os], we have a bunch of sort of unique rules where, you know, a page needs to be globally unique, a frame needs to be globally unique. So you don't have multiple pages aliasing the same frame, mapping the same frame, right? Because that would violate Rust's aliasing XOR mutability guarantees, right?",Interview P12,,0,"Author 2 This doesn't mention the API, only the rules that would be enforced by it, and they seem relatively certain about its correctness. Response I see I see",51,51,1,Author 2,8/16/23,Author 1,3/21/24
12:20,¶ 67,," So, you know, for that reason, we have also embarked upon some formal verification ventures with formal verification tools that can help verify rust code with like pre and post conditions,",Interview P12,Formal verification,1,,67,67,1,Author 2,8/16/23,Author 1,3/21/24
12:21,¶ 71,,"And there are some other ones, the Kani verifier looked at, but haven't ultimately experimented with.",Interview P12,Kani,1,,71,71,1,Author 2,8/16/23,Author 1,3/21/24
12:22,¶ 71,,"I'm involved in it a little bit, but as far as I know, we're using Prusti, Prusti, P-Rust-I, yeah.",Interview P12,Prusti,1,,71,71,1,Author 2,8/16/23,Author 1,3/21/24
12:23,¶ 51,, we check and guarantee that it was mapped in a writable way so you don't get like unexpected page faults. ,Interview P12,Runtime Assertion,1,"Author 2 It's not clear how ""we check and guarantee"" translates to a runtime check; it might be something expressed through static typing as well.  Response I feel like this has to be a dynamic check.  If it was statically done through the type system I'm not sure ""We"" is the correct word since it would be guaranteed by the language, not the developer.  But there is enough ambiguity that I feel you're right and the safest thing to do is not assume.",51,51,1,Author 2,8/16/23,Author 1,3/21/24
12:24,¶ 51,,"we check, you know, the size of that type.",Interview P12,Runtime Assertion,1,"Author 2 It's still not quite clear to what extend this checking is happening through static typing or dynamic assertions. Response I'm convinced here its a dynamic assertion because of the language ""we check"".",51,51,1,Author 2,8/16/23,Author 1,3/21/24
12:25,¶ 51,,"in [os], we have a bunch of sort of unique rules where, you know, a page needs to be globally unique, a frame needs to be globally unique",Interview P12,Contract or Invariant,1,,51,51,1,Author 2,8/16/23,Author 1,3/21/24
12:26,¶ 51,,"There are a lot of, you know, restrictions on what that type can be, you know, given by various trait bounds.",Interview P12,,0,"Author 2 This is a bit too meta to be represented by Contract or Invariant. At least, the invariant would more be that a page must be writeable when accessed mutably. The trait bounds are how that's enforced, but when we mark something as ""Contract or Invariant,"" we want that quote to clearly represent what the invariant it. Response That makes sense",51,51,1,Author 2,8/16/23,Author 1,3/21/24
12:27,¶ 59,,"I think in order to provide a truly bulletproof safe API around this inherently unsafe procedure of mapping and handling memory, it's nice to assert that these invariants are actually proven, enforce these invariants, rather.",Interview P12,,0,"Author 2 Still not quite clear if ""assert"" is a runtime assertion, or an inference that the behavior is correct due to Rust's borrow checking. Response Given the context I think you're right.  This is talking about the borrow checker.",59,59,1,Author 2,8/16/23,Author 1,3/21/24
12:28,¶ 59,," For example, that's why we only allow a user, for example, a device driver, someone who has access to one of these mapped memory regions, to borrow it. You can't create an owned instance of a struct that is actually backed by some underlying memory because then you've divorced them.",Interview P12,,0,"Author 2 No uncertainty here, so not a ""Safe"" API Response Agreed-- I definitely thought ""Safe"" API meant a Safe API.  This was a bad misunderstanding.",59,59,1,Author 2,8/16/23,Author 1,3/21/24
12:29,¶ 75,,"That's just an address. I just have to trust it. I have to jump to that address and I really can't do anything to verify it other than, you know, because I know about memory mappings, I can check that it's like executable and it exists, but I don't know what code, right? There's no way to like frantically know that at that location in memory, those instructions correspond to a drop handler for this type, right? That information is lost during compilation. I'm not saying that it should be there. I'm just giving you an example of something that's fundamentally unsafe and unavoidably",Interview P12,"Difficult to Encapsulate, No Other Choice",2,,75,75,1,Author 2,8/16/23,Author 1,3/21/24
12:30,¶ 95,,"So, yeah, I mean, but implementing the unwinder itself, right. That is inherently unsafe.",Interview P12,No Other Choice,1,,95,95,1,Author 2,8/16/23,Author 1,3/21/24
12:31,¶ 111,,"o I got to Box it up, then use it to raw and then pass that around in the context. And then to access it, I didn't need to unsafely reconstitute it into a Box from raw. So you know, it's just me trusting that the control flow is correct and nobody else tampered with that pointer or the contents of that pointer. ",Interview P12,Box<T>,1,,111,111,1,Author 2,8/16/23,Author 1,3/21/24
12:32,¶ 111,,"But there were some other cases where some of my collaborators were misusing Box from raw for a pointer that did not originally come from a Box. It sort of worked, but I feel like it would have had major problems had we done anything complicated with it. So misuse of the from raw thing in an unsound manner, because it's very easy to mistake that mistake a Box for a generic pointer rather than something that was specifically allocated on the heap and came from a previous Box.",Interview P12,"Box<T>, Box<T> Bug, From Raw, Wrong Pointer",3,,111,111,1,Author 2,8/16/23,Author 1,3/21/24
12:33,¶ 123,,"So typically we'll Box it up, put it in a struct that is tied to some other struct that represents a capability to access that piece of hardware to ensure that it lasts long enough.",Interview P12,Box<T>,1,,123,123,1,Author 2,8/16/23,Author 1,3/21/24
12:34,¶ 127,,"And then when it's shared, oh, you got to put it in an arc",Interview P12,Arc<T>/Rc<T>,1,,127,127,1,Author 2,8/16/23,Author 1,3/21/24
12:35,¶ 143,,"So sometimes you need to go back and forth between virtual and grab it, grab the address that you passed in previously. You know, once the hardware says, hey, there's been a frame received at this point via DMA.",Interview P12,Interacting with hardware,1,,143,143,1,Author 2,8/16/23,Author 1,3/21/24
12:36,¶ 67,,"I don't think it's black and white. And it can be, in cases, it can be quite hard to determine whether or not it's actually safe to expose a safe API. Sorry, I should say whether or not it's sound to expose a safe API to one of these, you know, underlying registers, right? Another example is like, if you're just reading the state of like some interrupt controllers, right? There's nothing wrong with like, you know, getting statistical information, right? That's fine. It's okay for like an unprivileged user to do that or an unprivileged foreign crate. No problem. But in some cases, like reading a status register, it may also clear it or have some other side effect, right? So should that be safe? It depends on the context of how it's being used, right? ",Interview P12,When to Encapsulate?,1,,67,67,1,Author 2,8/16/23,Author 1,3/21/24
12:37,¶ 67,,reading a status register,Interview P12,Interacting with hardware,1,,67,67,1,Author 2,8/16/23,Author 1,3/21/24
12:38,¶ 75,,"So then you, you have another entry point that is, you know, it's past an opaque pointer.",Interview P12,"Opaque Pointer, Transmute",2,Author 2 Not clear that there's a transmutation going on here. Response I put transmute here because they are type casting a void* into some function pointer.  What do you think?,75,75,1,Author 2,8/16/23,Author 1,3/21/24
12:39,¶ 63,,"Yeah, so let me give you an example. Like if you, let's say you have the layout in memory of those, let's use a very simple device like three register timer or something. Let's say you've made a math mistake. You flipped one of them. You put the counter register at offset eight and the frequency register at offset zero and it should be the other way around or something. You're not causing unsafety, you're just incorrect. ",Interview P12,"Contract or Invariant, Logical Error, Requirements Bug",3,,63,63,1,Author 2,8/16/23,Author 1,3/21/24
12:40,¶ 63,," However, if those functions are doing something that could then break another part of the system, like some side effects, for example, accessing configuration registers that dictate how virtual memory works, like the size on ARM, for example, you can set certain system registers that dictate how many bits are used for a virtual address. Well, if we allow someone to change that willy nilly, like all of the other assumptions for the whole memory subsystem, just go out the window. So that is inherently unsafe and there's no way to make that safe. ",Interview P12,No Other Choice,1,,63,63,1,Author 2,8/16/23,Author 1,3/21/24
12:41,¶ 63,," accessing configuration registers that dictate how virtual memory works, like the size on ARM, for example,",Interview P12,Interacting with hardware,1,,63,63,1,Author 2,8/16/23,Author 1,3/21/24
12:42,¶ 55,," a type that represents a range of frames that has been allocated from the frame allocator, right? This is, you know, I want this to be globally unique such that two separate entities cannot allocate and use the same physical memory frame at the same time for two different purposes, right? ",Interview P12,Contract or Invariant,1,,55,55,1,Author 2,8/16/23,Author 1,3/21/24
12:43,¶ 55,," I don't want to allow multiple pages to all map to one same frame. I'm having more internet problems, it says. I don't know if you caught that. Right, so if you have a virtual address, like a page, right? That's a pointer, so you cannot have multiple pointers that could point to the same object concurrently, you know, outside of the bounds of something like Arc that the language already knows about, right? So if you did that, you would be able to create multiple independently owned objects that are seemingly completely separate from one another, but they actually refer to the same underlying data. That violates memory safety.",Interview P12,Contract or Invariant,1,,55,55,1,Author 2,8/16/23,Author 1,3/21/24
12:44,¶ 151,,"So assuming that you set it up and configured it correctly, you know, the address you get back out of that is something that you then reconstitute into a pointer if it's virtual or you figure out which frame, which page was mapped to that frame and grab the virtual address from there. And, you know, it can be complicated to properly handle the transitions to and from the hardware and the software layer when you're talking about going between a safe rust type like a Box and an unsafe type like a pointer.",Interview P12,"Box<T>, Difficult FFI",2,,151,151,1,Author 2,8/16/23,Author 1,3/21/24
12:45,¶ 159,,"So I think in that case, the usage of the unsafe cell is very clear.",Interview P12,UnsafeCell<T>,1,,159,159,1,Author 2,8/16/23,Author 1,3/21/24
12:46,¶ 175,,static variabl,Interview P12,Static Variables,1,,175,175,1,Author 2,8/16/23,Author 1,3/21/24
12:47,¶ 191,,"So you can, instead of locking something with mutex, you can lock it with a ref cell",Interview P12,"Mutex<T>, RefCell<T>, Sync",3,,191,191,1,Author 2,8/16/23,Author 1,3/21/24
12:48,¶ 195,,cell,Interview P12,Cell<T>,1,,195,195,1,Author 2,8/16/23,Author 1,3/21/24
12:49,¶ 199,,You need to use unsafe cell for that. So you need to... It's basically the way that something like once cell works.,Interview P12,OnceCell<T>,1,,199,199,1,Author 2,8/16/23,Author 1,3/21/24
12:50,¶ 212,," But I mean, you use pointers because again, this is something that you have to use to compare and exchange atomic instructions for, and you can't pass in a high level type. You got to pass in an integer. So that becomes a pointer",Interview P12,"Atomic Intrinsics, Transmute",2,,212,212,1,Author 2,8/16/23,Author 1,3/21/24
12:51,¶ 212,," And if it's like a linked list or something, an atomic list, it's all pointers. So the unsafe cell is there surrounding the head or the tail pointer, for example, depending on what data structure you're accessing.",Interview P12,UnsafeCell<T>,1,,212,212,1,Author 2,8/16/23,Author 1,3/21/24
12:52,¶ 216,,"So I don't think we use MaybeUninit but we should. So that is a choice that definitely harms performance. The most common case, again, not unique to this particular domain, but widely known in the Rust community is reads of uninitialized data or sorry, reads of data into an uninitialized array, right? You can't really do that. I know there have been a lot of proposals to make this happen and make it a little safer. But right now you got to do it manually.",Interview P12,"MaybeUninit<T>, Shifting Ground",2,,216,216,1,Author 2,8/16/23,Author 1,3/21/24
12:53,¶ 216,,"nd the other one you said was manually dropped. Definitely. We do use that. I know that we use that more before whatever version of Rust where they had a guaranteed drop order based on the declaration order of fields in a struct. Before that, we had to use manually drop everywhere that we wanted to impose an ordering on how things were dropped. Now, let me see, where do I use it? So now we use it in some synchronization primitives",Interview P12,ManuallyDrop<T>,1,,216,216,1,Author 2,8/16/23,Author 1,3/21/24
12:54,¶ 216,," We have a callback for customizable mutex behavior, and we want to make sure that we drop the guard and then invoke this callback function that allows someone to know when a mutex has been dropped, for example, or something like that. So there isn't a way to represent that as far as I know without manually drop",Interview P12,"ManuallyDrop<T>, No Other Choice",2,,216,216,1,Author 2,8/16/23,Author 1,3/21/24
12:55,¶ 216,,"So the Rust standard library has this ability to catch a panic called catch unwind. So us being the operating system, I also need to implement that. So they use ManuallyDrop, and I correspondingly use mainly drop in the same way, because it goes through an intrinsic called the tri-intrinsic, which is basically what will result in the compiler creating an unwind trampoline such that you can actually catch and unwind. ",Interview P12,"Intrinsics, ManuallyDrop<T>",2,"Author 2 Probably not an instance of volatile intrinsics, just intrinsic use overall. Response Gotcha",216,216,1,Author 2,8/16/23,Author 1,3/21/24
12:56,¶ 216,,"Oh, we could avoid it. Okay, here's how we could avoid it. So MainlyDrop has this API called take, right? You could wrap it in an option, but then you have a panic possibility, which is technically wrong. So in this case, what we're doing is we're preferring unsafety over the ability of a panic that should never happen. So I guess that's another classification of use cases there. I'm preferring unsafety over a place where I could use an option, but it would be logically invalid for that option to ever not exist. So we don't use an option.",Interview P12,"Easier or More Ergonomic, Option<T>",2,,216,216,1,Author 2,8/16/23,Author 1,3/21/24
12:57,¶ 220,,"I will say a lot of the places where we descend into raw pointers is usually just obtaining a raw pointer, for example, from say a Box or from some other struct field, right? The pointer to that struct field and then we're passing it into hardware",Interview P12,Box<T>,1,,220,220,1,Author 2,8/16/23,Author 1,3/21/24
12:58,¶ 244,,"In my view, Rust is generally supposed to relieve me from the obligation of running that stuff, although we do use Unsafe, so it's maybe not true",Interview P12,Tacit Knowledge,1,,244,244,1,Author 2,8/16/23,Author 1,3/21/24
12:59,¶ 244,,"This is not related to Unsafe, but we have encountered deadlock before, and that is always very difficult to debug, especially with spinlocks, which are required in the early or lowest level parts of the system before we have a task management subsystem",Interview P12,"Concurrency Bug, Deadlock",2,,244,244,1,Author 2,8/16/23,Author 1,3/21/24
12:60,¶ 244,,"This is not related to Unsafe, but we have encountered deadlock before, and that is always very difficult to debug, especially with spinlocks, which are required in the early or lowest level parts of the system before we have a task management subsystem. So a tool for that would be helpful, but that's not technically unsafe. It's just really obnoxious.",Interview P12,Wants Solution,1,,244,244,1,Author 2,8/16/23,Author 1,3/21/24
12:61,¶ 248,,"But yeah, formal verification is a whole issue. It's just really tedious. So I don't know if there was something easier, like on the Clippy integration level difficulty that would for sure be welcome. I could use it. ",Interview P12,Wants Solution,1,,248,248,1,Author 2,8/28/23,Author 1,3/21/24
12:62,¶ 248,," Yeah, I feel like Miri is tricky because it has limited support for code that is not Rust.",Interview P12,Wants Solution,1,,248,248,1,Author 2,8/28/23,Author 1,3/21/24
12:63,¶ 3,,"So as you can imagine, lots of unsafe opportunities. As we used it more, we became more enamored with the ownership system and the general benefits of linear typing. So I think we've explored a great deal of Rust, not just Rust, but the power of language as it can pertain to improving the safety and reliability of operating systems.
",Interview P12,Operating & Embedded Systems,1,,3,3,1,Author 1,9/2/23,Author 1,1/17/24
12:64,¶ 11,,"Ideally, we try to mask all of this unsafety with safer, safe, higher level interfaces,",Interview P12,Exposing a Safe API,1,,11,11,1,Author 1,9/2/23,Author 1,3/21/24
12:65,¶ 11,,"you know, you need to communicate with the CPU model specific registers on X86.",Interview P12,Interacting with hardware,1,,11,11,1,Author 1,9/2/23,Author 1,3/21/24
12:66,¶ 15,,"Ah, yes. It's the vast majority in my specific case is the former where, so part of, I think part of like the charter of this project is to see to what, like, what's the fullest extent to which we can avoid unsafety, right? ",Interview P12,Preference for Safety,1,,15,15,1,Author 1,9/2/23,Author 1,3/21/24
12:67,¶ 15,,"This is in effect a self-referential data structure, right? So that's, as you probably know, that's a very hot topic in Rust and how to represent them safely is kind of an ongoing issue. ",Interview P12,Shifting Ground,1,,15,15,1,Author 1,9/2/23,Author 1,3/21/24
12:68,¶ 15,,"So we attempted to use those in the heap themselves. So it's basically like we're allocating memory and tracking those applications using heap allocated data structures, like a vector or a linked list or something like that. And then underneath that is the actual heap memory that's stored in that is then backed by the underlying memory that was allocated. So it's another weird cycle, right?",Interview P12,Multiple / cyclic aliasing,1,,15,15,1,Author 1,9/2/23,Author 1,3/21/24
12:69,¶ 15,,"We have, in these case, we have a variety of different types, high level types that represent a safely allocated and, you know, always actively mapped to real existing physical memory, regions of virtual memory that you can access. There's some types that represent that. So we attempted to use those in the heap themselves. ",Interview P12,Unsafe Data Structure,1,,15,15,1,Author 1,9/2/23,Author 1,3/21/24
12:70,¶ 15,,"And of course, the very nature of the global allocator interface in Rust, the trait for the allocator itself provides two unsafe functions. So you have to use unsafe to implement them, because Rust wants to be sure that you're implementing them correctly.",Interview P12,No Other Choice,1,,15,15,1,Author 1,9/2/23,Author 1,3/21/24
12:71,¶ 23,,"So there's, there's a cycle, but if you have, if you introduce unsafety, you're basically, you know, of course, as you know, promise into the compiler, that the place that you're writing this metadata to has already been allocated. It's a real memory that exists, right? It's not going to cause like a page fault or user space aside fault. And you know, it's, it's memory that you own and is available for your usage, right? There's no real way to communicate that to the compiler.",Interview P12,Contract or Invariant,1,,23,23,1,Author 1,9/2/23,Author 1,3/21/24
12:72,¶ 47,,"Again, we try to make it as safe as possible at certain levels of the interface.",Interview P12,Exposing a Safe API,1,,47,47,1,Author 1,9/2/23,Author 1,3/21/24
12:73,¶ 47,,"So I can actually speak about our memory management subsystem itself, which underlies the heap. And that is also riddled with unsafety.",Interview P12,"Extensive, Non-local Unsafe",1,,47,47,1,Author 1,9/2/23,Author 1,3/21/24
12:74,¶ 47,,"So then we have a bunch of types that atop the underlying unsafe virtual memory implementation, which try to, I mean, in my opinion, they succeed",Interview P12,"""Safe"" API, Tacit Knowledge",2,,47,47,1,Author 1,9/2/23,Author 1,3/21/24
12:75,¶ 51,,"Another thing, so what we try to do is to use the Rust type system and, you know, the power of affine types and the borrow checker to kind of integrate what it means to be safely accessing memory into the compiler and express it in terms that the compiler can understand.",Interview P12,Leveraging the Borrow Checker,1,,51,51,1,Author 1,9/2/23,Author 1,3/21/24
12:76,¶ 51,,"So another example is if you allocate a, sorry, if you like map a region of memory, right, let's say it's a region that represents some DMA for some device, something like that, or like a register for a device, right? Like a hardware timer device has three registers that you can read the period, the counter and set up an interrupt or something, right? You want to make sure that you're representing those correctly, but it's not necessarily unsafe if you don't represent them correctly. It's just, you know, wrong, right?",Interview P12,Contract or Invariant,1,,51,51,1,Author 1,9/2/23,Author 1,3/21/24
12:77,¶ 51,,"So we have a memory, let's say you have, you know, a representation of a timer and it has three, three MMIO registers. And you want to make sure that, you know, when you're accessing those MMIO registers, someone's not going to yank out the memory underneath you, or you're not going to allow a reference to one of those MMIO registers to persist longer than that of the actual underlying mapping, which would be a problem.",Interview P12,Contract or Invariant,1,,51,51,1,Author 1,9/2/23,Author 1,3/21/24
12:78,¶ 59,,"For example, that's why we only allow a user, for example, a device driver, someone who has access to one of these mapped memory regions, to borrow it. You can't create an owned instance of a struct that is actually backed by some underlying memory because then you've divorced them. You've separated them such that there's no relationship between the lifetime of that instance of the struct and the lifetime of the underlying memory mapping. So that's one of the clever ways in which we use Rust. But it's also theoretically somewhat limiting. So yeah, I would say that's a great example of taking something that's unsafe inherently and then kind of wrapping it up in a safe abstraction, using the power of Rust to do the borrow checking for us.",Interview P12,"Contract or Invariant, Leveraging the Borrow Checker",2,,59,59,1,Author 1,9/2/23,Author 1,3/21/24
12:79,¶ 63,,"So that's, you know, restricted behind public private APIs or it's, you know, if you wanted to expose it, which we don't, but you would have to do so unsafely.",Interview P12,Preference for Safety,1,,63,63,1,Author 1,9/2/23,Author 1,3/21/24
12:80,¶ 67,,"Only, you know, a good application designer, and I'm sure every developer will tell you this, anyone that's worth their salt will tell you that you shouldn't just, you know, wrap, uh, safe APIs around a bunch of unsafe stuff without doing a lot of due diligence. ",Interview P12,When to Encapsulate?,1,,67,67,1,Author 1,9/2/23,Author 1,3/21/24
12:81,¶ 67,,"So of course, you know, you typically just err towards the side of unsafely being somewhat viral and that it affects all of the interfaces surrounding it.",Interview P12,"Extensive, Non-local Unsafe, Local, Minimal Unsafe",2,,67,67,1,Author 1,9/2/23,Author 1,3/21/24
12:82,¶ 71,,"some of, you know, some of the things like, you know, these properties in the virtual memory subsystem about like global uniqueness of a given page or friend, you know, ensuring that you're mapping, you're actually creating the mapping correctly in the hardware page tables from a given page to a given frame. Like these are things that we are trying to use Prusti to verify, right? ",Interview P12,"Contract or Invariant, Formal verification",2,,71,71,1,Author 1,9/2/23,Author 1,3/21/24
12:83,¶ 71,,"Because I assert that they're sound and they're done correctly, but you know, that's me just manual inspection. So it's, it could be, you know, more formal.",Interview P12,Tacit Knowledge,1,,71,71,1,Author 1,9/2/23,Author 1,3/21/24
12:84,¶ 79,,"So that's another unsafe entry point, you know, and there's nothing I can do about that. I just have to trust that I parsed all of the unwinding information.",Interview P12,Tacit Knowledge,1,,79,79,1,Author 1,9/2/23,Author 1,3/21/24
12:85,¶ 87,,"But, you know, this is okay because, you know, assuming that you got all that right, the there's no, like, there's no way to access this, right? Like from a user's perspective or a foreign crate, you can't like jump directly to a drop handler for a type, unless you're doing something inherently unsafe. You have to use unsafe code for that. So nobody would do that.",Interview P12,It's not a problem,1,,87,87,1,Author 1,9/2/23,Author 1,3/21/24
12:86,¶ 111,," So because it's a C style of API, you just get one integer value. ",Interview P12,Simple FFI,1,,111,111,1,Author 1,9/2/23,Author 1,3/21/24
12:87,¶ 115,,The other cases where we have this sort of thing is where we're passing something to hardware. Like I have a virtual address or I have a piece of hardware where I need to write a virtual address into a register.,Interview P12,Interacting with hardware,1,,115,115,1,Author 1,9/2/23,Author 1,3/21/24
12:88,¶ 119,,"And of course, I got to get an unsafe. I have to get a pointer. Now it's not unsafe to obtain a pointer, as you know.",Interview P12,No Other Choice,1,,119,119,1,Author 1,9/2/23,Author 1,3/21/24
12:89,¶ 123,,"But then you need to make sure that it's sort of like any FFI interface. In the FFI, you have to make sure that thing actually lasts for however long the hardware is using that pointer.",Interview P12,Contract or Invariant,1,,123,123,1,Author 1,9/2/23,Author 1,3/21/24
12:90,¶ 147,,"And, you know, that's sort of another just, I got to trust it type thing.",Interview P12,Tacit Knowledge,1,,147,147,1,Author 1,9/2/23,Author 1,3/21/24
12:91,¶ 163,,"You basically spin on an atomic lock and then if you're successful, you know, in the compare exchange, then you can return a reference to that data. And of course, that's unsafe.",Interview P12,"Atomic Intrinsics, No Other Choice, UnsafeCell<T>",3,,163,163,1,Author 1,9/2/23,Author 1,3/21/24
12:92,¶ 203 – 204,,"And then the other place that we use it is for a lock 
free queues.",Interview P12,Unsafe Data Structure,1,,203,204,2,Author 1,9/2/23,Author 1,3/21/24
12:93,¶ 212,,"But nothing too crazy. I really strive. Like I said, part of the charter of the project is to not use unsafe. So we're not going to opt for UnsafeCell if we can use like an Rc/Arc and a mutex potentially more cost in 99%. It makes sense.",Interview P12,"Arc<T>/Rc<T>, Mutex<T>, UnsafeCell<T>",3,,212,212,1,Author 1,9/2/23,Author 1,3/21/24
12:94,¶ 220,,"Rare are the scenarios where we're actually obtaining a raw pointer from somewhere else and then up converting it back into a safe type, right? That does happen and unwinding, but it's rare, especially for hardware. Typically, it's just unidirectional from safe to the raw pointer such that hardware can then use that as a virtual address, right? That's the vast majority of what we're doing. ",Interview P12,Different FFI Memory Model,1,,220,220,1,Author 1,9/2/23,Author 1,3/21/24
12:95,¶ 220,,"But yeah, we should probably use Miri. I guess I just don't know exactly how to apply it. In an OS, there's umpteen entry points, so it's not clear how I would do. I'd give Miri the address of an interrupt handler and say start from here and give me any soundness errors that could occur from code reachable from that point. If that's how it works, yeah, I could do it. I just haven't bothered, I guess.",Interview P12,Unaware of Tools,1,,220,220,1,Author 1,9/2/23,Author 1,3/21/24
12:96,¶ 244,,"And there's not really Unsafe code in the allocator itself, but the implementation needs to be correct such that when we bridge the Safe allocator code to the Safe higher-level type code, like Box and the alloc types that use the allocator in the middle, which itself is Unsafe, the allocator interface, that we're abiding by that contract and not, for example, duplicately allocating the same memory twice or something that would be invalid",Interview P12,Contract or Invariant,1,,244,244,1,Author 1,9/2/23,Author 1,3/21/24
12:97,¶ 248,,"Everything we write is in Rust. I mean, there's some inline assembly here and there. ",Interview P12,Inline Assembly,1,,248,248,1,Author 1,9/2/23,Author 1,3/21/24
12:98,¶ 55,,"That's a pointer, so you cannot have multiple pointers that could point to the same object concurrently, you know, outside of the bounds of something like Arc that the language already knows about, right? ",Interview P12,Arc<T>/Rc<T>,1,,55,55,1,Author 1,9/21/23,Author 1,3/21/24
13:1,¶ 3,," So basically, I was motivated to learn Rust. I was just interested in language at the time, but interested in a language that solved problems that I was running into like member safety, but also having a nice performance in the level of NSFC.",Interview P13,"Memory Safety, Rust Performs Well",2,,3,3,1,Author 2,8/17/23,Author 1,3/18/24
13:2,¶ 7,,"wadays I work on [tool], which is a WebAssembly engine for written in Rust",Interview P13,Compilation & Interpretation,1,,7,7,1,Author 2,8/17/23,Author 1,3/18/24
13:3,¶ 7,,We're doing funky things like we're compiling code and then actually executing it. ,Interview P13,Compilation & Interpretation,1,,7,7,1,Author 2,8/17/23,Author 1,3/18/24
13:4,¶ 7,," So we have, one of the primary reasons we're using Rust, for example, is that the API that we give to users for the, for the [tool] is 100% safe",Interview P13,Memory Safety,1,,7,7,1,Author 2,8/17/23,Author 1,3/18/24
13:5,¶ 11,,a major one is that we are generating machine code and then executing it.,Interview P13,Interacting with hardware,1,"Author 2 I feel like interacting with hardware is more in line with specific devices, not just generating native code. The way I'm thinking about this is, you could JIT compile ""print!(""hello world"")"", which would fit here, but that doesn't seem like a hardware-related thing.",11,11,1,Author 2,8/17/23,Author 1,3/18/24
13:6,¶ 7,,"and that's very, very valuable where even not only internally can we use safe code, but externally everyone using us can also rely on all the safe code.",Interview P13,Preference for Safety,1,,7,7,1,Author 2,8/17/23,Author 1,3/18/24
13:7,¶ 11,,"Quite a few things internally. So I've done a lot of unsafe for us historically, but at least currently with [tool], a major one is that we are generating machine code and then executing it. So unsafe is obviously required there just because you're asserting the output of the compiler is correct",Interview P13,No Other Choice,1,,11,11,1,Author 2,8/17/23,Author 1,3/18/24
13:8,¶ 11,,"but we're also doing quite a lot on the runtime side of things in terms of just kind of pointer tricks. Like we've got a lot of aliasing, a lot of things that are not really modeled very well and strict safe, like we can't just use Rc, we can't just use Box, things like that. So that's like the runtime speed kind of low levelness",Interview P13,"Arc<T>/Rc<T>, Box<T>, Increase Performance, Multiple / cyclic aliasing",4,,11,11,1,Author 2,8/17/23,Author 1,3/18/24
13:9,¶ 19,," I mean, that's just unsafe operation is just cast bytes to a function pointer and call it.",Interview P13,Transmute,1,,19,19,1,Author 2,8/17/23,Author 1,3/18/24
13:10,¶ 23,,"So basically, we have tons of pointers pointing to everything else all over the place. So there is no sense of like, there is a unique owner sitting in one particular location. It's rather, well, each of your imports came from this instance, which has this pointer, but each of those imports came from that instance, which has those pointers. So kind of lots of like internal pointers here and there.",Interview P13,Multiple / cyclic aliasing,1,,23,23,1,Author 2,8/17/23,Author 1,3/18/24
13:11,¶ 23,," We still maintain like a very high level embedding layer. We can say like there's a unique point of ownership, nothing there, but internally kind of doing all that, the representations just to have a very low level representation. ",Interview P13,"""Safe"" API",1,"Author 2 This code relates to situations where you expose a safe API, but there's some known situation under which there could be undefined behavior, or there's a defined suspicion that there could be situations where UB could occur. Even though there's a mess of pointers here, it's unclear what the specific issue would be under the hood, at least not yet, so I feel like this might not fit here.",23,23,1,Author 2,8/17/23,Author 1,3/18/24
13:12,¶ 23,,"but like one example is we effectively have our own custom arc, which Rc/Arc in the standard library works perfectly fine. There's no reason to not use it. But for us, we have JIT code, which is generated by [generator], which is actually interacting with it. So the JIT code, for example, is incrementing and decrementing the reference count. And we can't rely on the in memory layout of the Rc/Arc in the standard library for very good reasons. We kind of effectively have our own version of arc, which is a slightly different in a few words, but primarily we know the in memory representation. So we know where reference count is and we know how to write JIT code to modify it.",Interview P13,"Arc<T>/Rc<T>, Unsafe Data Structure",2,,23,23,1,Author 2,8/17/23,Author 1,3/18/24
13:13,¶ 27,,"So you have exactly if it defined, for example, that like the first the pointer pointed to an atomic reference count, which was this wide, and that was it, then we could do that. But then there's also stuff like with weak pointers in the standard library. So that's just like, basically, because the standard library doesn't do that, we ended up rolling our own check.",Interview P13,No Other Choice,1,,27,27,1,Author 2,8/17/23,Author 1,3/18/24
13:14,¶ 31,,". But according to Miri, whenever you move a Box, you're invalidating all pointers that you derived from the Box. And so that was, it's not like a perfect example, like the Arc/Rc example, but it's one where we did want the property where we can move the pointer owner without invalidating previous ones.",Interview P13,"Borrowing or Provenance Bug, Stacked/Tree Borrows Violation",2,"For Author 1: shouldn't this be ""Box<T> Bug""?",31,31,1,Author 2,8/17/23,Author 1,3/18/24
13:15,¶ 31,,"t's interesting because we, as of like just this week, we started running some of our tests in Miri, which is I'd like to try and verify some of the unsafe code",Interview P13,Running tests through Miri,1,,31,31,1,Author 2,8/17/23,Author 1,3/18/24
13:16,¶ 31,,"And that was actually very much motivated by last week, we had a CVE, just we had undefined behavior, one of our functions, which actually surfaced in real user behavior. So anyway, long story short, we were using Box of T for some data structures. We would say like, basically, we would put in a Box, which we would assume would heap allocated, we would then put the Box in the store, but then we retained pointers to it all over the place. So we wouldn't actually use the Box pointer. We just kind of like keep that rooted in a sense. But according to Miri, whenever you move a Box, you're invalidating all pointers that you derived from the Box. And so that was, it's not like a perfect example, like the Arc/Rc example, but it's one where we did want the property where we can move the pointer owner without invalidating previous ones. So we effectively made our own little Box lookalike style thing. ",Interview P13,"Box<T>, No Other Choice",2,,31,31,1,Author 2,8/17/23,Author 1,3/18/24
13:17,¶ 31,," But I know that the, the unsafe code rules are a little influx there at that point. So it's one where Box might be providing too many guarantees that we don't actually want to give, or those are also under debate. So I don't know whether that's the correct thing. I won't pass judgment on that. ",Interview P13,Shifting Ground,1,,31,31,1,Author 2,8/17/23,Author 1,3/18/24
13:18,¶ 35,," imagine a graph data structure where on the outside you have just an owned API. It's all perfectly safe for us, but internally everything's just got pointers to everything else, kind of like a double link list of a sense of like, you just got pointers to your next to your pre they've got pointers to you. Someone else has pointers to you. That's sort of like kind of what our internal data structures look like.",Interview P13,"Extensive, Non-local Unsafe, Multiple / cyclic aliasing, Unsafe Data Structure",3,,35,35,1,Author 2,8/17/23,Author 1,3/18/24
13:19,¶ 35,,". There's not really a like statically safe paradigm here. It's more of like, we just kind of got to guarantee everything internally.",Interview P13,Runtime Assertion,1,"Author 2 It's unclear if by ""guarantee everything internally"" they mean insert runtime checks, or just audit for correctness underneath the encapsulation.",35,35,1,Author 2,8/17/23,Author 1,3/18/24
13:20,¶ 51,,"And this is one where like, we don't actually do a great job of organizing this right now, which is that ideally there's like a very clear boundary of you can, I mean, the theory is every single time you write an unsafe block, you can have a nice little comment above it saying like, this is obviously correct and you as the reader can verify it because you can just kind of like check a couple of variants. But for us, I think we checked recently, we have like 500 unsafe blocks and like 1500 uses of the word unsafe. So it's a very much all ends up being kind of interrelated to everything else. And it's very difficult to reason about one unsafe block in isolation.",Interview P13,"Difficult to Encapsulate, Unsafe is Difficult to Understand",2,,51,51,1,Author 2,8/17/23,Author 1,3/18/24
13:21,¶ 59,," But there's, there's, there are like some kind of prevailing architectural design decisions, which if you don't understand them, most of them, most of [tool] would not make sense. ",Interview P13,Audience-specific Reasoning,1,,59,59,1,Author 2,8/29/23,Author 1,3/18/24
13:22,¶ 59,,"So like, I mentioned the store earlier, where like a store is an own thing. If you don't understand that like everything, like once you put something in a store, it just lives for the entire lifetime of the store and it had never been deleted. That's a very critical lifetime invariant, which we have across every single component, but it's very easy to miss that. ",Interview P13,Contract or Invariant,1,,59,59,1,Author 2,8/29/23,Author 1,3/18/24
13:23,¶ 67,,It's just a lot of our motivations now are more like kind of in the list of priorities prioritizing like new features or bug fixes or other forms of fuzzing or things like that.,Interview P13,Fuzzing,1,,67,67,1,Author 2,8/29/23,Author 1,3/18/24
13:24,¶ 67,," we invest in areas such as fuzzing, such as Miri, such as, I think we're, we're trying to get an audit from, I think it's [redacted] or something like that. So there are other strategies where we're basically trying to do, which is not trying to make everything safe because we've sort of, we just don't know how to do it and try and invest in other places instead. Not sure.",Interview P13,,0,"Author 2 This isn't dynamic analysis, I think they're reaching out to UT Austin for a manual audit of their code base. Response I see, my bad my bad",67,67,1,Author 2,8/29/23,Author 1,3/18/24
13:25,¶ 67,,"And so this is where like, we also very much acknowledge that like our own understanding is obviously not sufficient. ",Interview P13,Unsafe is Difficult to Understand,1,,67,67,1,Author 2,8/29/23,Author 1,3/18/24
13:26,¶ 71,,"It's mostly the other other, we mostly use a bunch of other types per se. So let me rephrase our usage of UnsafeCell is when we sort of inherently only have &T, or we're too scared to give out &T or to have &T. So maybe it's, maybe it's fine. Maybe it's not. We just kind of err on the safe side and we just say it's UnsafeCell.",Interview P13,Exposing a Safe API,1,"Author 2 There was a typo here; I corrected it—it seems like they're intentionally choosing UnsafeCell to avoid pointer errors, and they're uncertain if it's correct but are doing it anyway. So I don't think they're avoiding an unsafe API here, they're choosing it out of a concern for safety.",71,71,1,Author 2,8/29/23,Author 1,3/18/24
13:27,¶ 75,,"We definitely use that wherever we can. Like that's just, I mean, why we, why use UnsafeCell, Cell suffices and that primarily works for like copy types. ",Interview P13,"Cell<T>, UnsafeCell<T>",2,,75,75,1,Author 2,8/29/23,Author 1,3/18/24
13:28,¶ 75,," So like, for example, when you hit a trap, you will collect some data with the trap like some backtrace and some information like that. And we store that in a data structure, but the data structure is like, it literally only exists to store the trap and then not have a trap when it goes out. And so we store that as an UnsafeCell of a manually drop. And so that way, if you don't hit a trap, you don't pay the cost for running the destructor because otherwise you would have to like check an option, ",Interview P13,"Increase Performance, ManuallyDrop<T>, UnsafeCell<T>",3,,75,75,1,Author 2,8/29/23,Author 1,3/18/24
13:29,¶ 75,,"So that sort of paradigm can't really be captured with a Cell or a RefCell, or it can be captured with a RefCell, but we don't want to pay the cost of every single time we invoke WebAssembly, we check the RefCell flag as we exit because it's got a destructor associated with the, because we know that the dynamic guarantee is zero is only returned if someone filled in that data. And so that's sort of like the UnsafeCell ManuallyDrop style stuff.",Interview P13,"Contract or Invariant, Increase Performance, ManuallyDrop<T>, RefCell<T>, UnsafeCell<T>",5,,75,75,1,Author 2,8/29/23,Author 1,3/18/24
13:31,¶ 91,,"we wrote the CAPI manually, we wrote the C headers manually, and then we wrote all of the bindings and everything which manually, we don't actually have auto-directed, I think like that. ",Interview P13,Generation VS Validation,1,,91,91,1,Author 2,8/29/23,Author 1,3/18/24
13:32,¶ 91,," We've definitely made mistakes there, which is that we had like the wrong size integer in the C header file versus the Rust code. So we, we don't do a great job of agreeing between our header files and our Rust code. So I wish we could do better there",Interview P13,Bindings are a Fiddly Mess,1,,91,91,1,Author 2,8/29/23,Author 1,3/18/24
13:33,¶ 91,," So we ended up, I ended up just writing all the manual bindings on top of that. There, I wrote a tiny script to, like, go from the C header file to typed Python CFFI stuff. So, like, it would take the C header file and say that here's this function that takes two integers and returns a pointer or whatever. And then so given that, it was like kind of like a basis to build on. And then I built like a nice high level Python library, which is the same idea of, like, you can't cycle to use it, ideally.",Interview P13,Generation VS Validation,1,,91,91,1,Author 2,8/29/23,Author 1,3/18/24
13:34,¶ 95,,"in Rust, you can trivially say, I'm going to return to you a thing, which just borrows my memory, and then you just can't access me while you're using that, like an iterator while you're iterating a vector, you can't push on it. Like, that's just trivial. Like, you expect to be able to do that, but this is not very easily mappable into a C API, or rather you could do it, but then you have to read all this documentation of like, please don't mutate the vector while you're iterating over it, and that that has to mirror to Python saying, and Python, please don't do it",Interview P13,Different FFI Memory Model,1,,95,95,1,Author 2,8/29/23,Author 1,3/18/24
13:35,¶ 95,,"And basically what we settled on here is that, like, we're not going to have any borrows at all. We're just going to try and maintain everything as a nice own data structure. Some things are copyable around as is, and this is where like our store, like our store is the canonical, like you malloc some data, everything's inside there, and that's it.",Interview P13,Simple FFI,1,,95,95,1,Author 2,8/29/23,Author 1,3/18/24
13:36,¶ 103,, So all of this was unsafe code because all of this is like we're just writing it a memory beyond our length and like it's in the VM context region. So there can't be anything safe about that,Interview P13,"No Other Choice, Writing beyond a boundary",2,Author 2 It's unclear to me that this is uninitialized memory; it seems like it's just referring to the fact that you have a different concept of length depending on how you're interpreting the structure. Response Thats right.  I considered the memory beyond the length to be uninitialized-- but this is not the interesting part of the sentence we want to capture.  Should this be transmute then?  Since it talks about interpreting data in an unsafe way?,103,103,1,Author 2,8/29/23,Author 1,3/18/24
13:37,¶ 103,,"And so our write, which was crucial for correctness and just the validity was optimized out, which then meant we had use after frees, which then turned into a segfault in the fuzzer, ",Interview P13,Use After Free,1,"Author 2 Though this is a use-after-free, the main bug seems to be the provenance issue mentioned above; the use-after-free is just a symptom of it. Response Should we not capture the use-after-free even if it is just a symptom?",103,103,1,Author 2,8/29/23,Author 1,3/18/24
13:38,¶ 103,," So LVM thought that this pointer was read only and noalias, which meant that nothing else was like pointing to it's all pointers. Basically, it was basically a certain LLVM were not going to write through this pointer, but then we wrote to the pointer. So because it was undefined behavior, it just optimized it out, deleted it, all that good stuff. So anyway, all of that was based on safe, based on safe assumptions, based in like various abstractions we had internally. So the fix for all of this was actually literally changing ampersand ampersand self to ampersand mute self. That was literally all we had to do.",Interview P13,"Borrowing or Provenance Bug, Stacked/Tree Borrows Violation",2,,103,103,1,Author 2,8/29/23,Author 1,3/18/24
13:39,¶ 103,,"But it turns out we have a lot of tests which are purely exercising the embedded API, so like create a table and then grow it and that's it. And all of that is like pure Rust code so can easily run at Miri. So our goal was to effectively run a couple of like some subset of our tests in Miri and sure enough, if you go run it on the vulnerable [tool], it instantly spots this bug.",Interview P13,Running tests through Miri,1,,103,103,1,Author 2,8/29/23,Author 1,3/18/24
13:40,¶ 107,,ASAN is practically worthless to us because we never found any bugs in ASAN. ,Interview P13,,0,"Author 2 It's unclear if they actually had a bug that was missed by ASAN, or if they just never detected any bugs at all. At least, X Missed Bug should be used when they're speaking positively about a bug that was missed. Response You're right, I think I misread this.",107,107,1,Author 2,8/29/23,Author 1,3/18/24
13:41,¶ 107,,"fuzzing, however, fuzzing is an absolute godsend. We, I mean, basically, we put a huge amount of time and effort into maintaining our fuzzers, keeping them running well, fixing bugs in the fuzzers. ",Interview P13,Fuzzing,1,,107,107,1,Author 2,8/29/23,Author 1,3/18/24
13:42,¶ 111,,"it occasionally finds issues of like this lowering is a little buggy. Like when you have this kind of weird shape of module, it just has a compiler panic or it produces the wrong results.",Interview P13,"Logical Error, Requirements Bug",2,,111,111,1,Author 2,8/29/23,Author 1,3/18/24
13:43,¶ 115,,"Miri is very new, but the way it's done so far is I ran the entire test suite in Miri that took like 10 hours and then I filtered all the tests that did transmutes from pointers to, like from a Rust compiled function pointer to a function and then that left me a set of tests, which is this basically all of these run in Miri. So we filtered that down to run in Miri. ",Interview P13,Miri is slow,1,,115,115,1,Author 2,8/29/23,Author 1,3/18/24
13:44,¶ 119,,"Well, I mean, the biggest one facing us right now is we would love to run Miri, but actually run the Tbizom test suite. Like, WASM has spec tests, we would love to run the spec tests in Miri, but we don't know how to do that right now",Interview P13,Miri doesn't support this feature,1,,119,119,1,Author 2,8/29/23,Author 1,3/18/24
13:45,¶ 7,,"I mean, I guess there's escape hatches, but by default, 100% safe,",Interview P13,Exposing an Unsafe API to Users,1,,7,7,1,Author 1,9/2/23,Author 1,3/18/24
13:46,¶ 43,,"So this means that my instance VM context, which has pointers, which has FuncRef inside of it, are all self-pointers. So all of those are pointing to the VM context itself. So you got self-pointers going back and forth. And then additionally, whenever I take my FuncRef and give them to a different VM context or like a different instance, they're going to point back to me. And so they've got pointers over to me. I've got pointers to myself. I've got a pointer to myself. And then additionally, I can also have pointers back to you if you hand FuncRef to me, because everything can be cyclic once you actually get into like the runtime semantics of all this. So we end up having this soup of just every instance can have pointers to other instances.",Interview P13,"Extensive, Non-local Unsafe, Multiple / cyclic aliasing",2,,43,43,1,Author 1,9/2/23,Author 1,3/18/24
13:47,¶ 51,,"So the official embedding API has no unsafe code in it or rather you can use it without unsafe code. So you can call wasm, you can instantiate wasm, you can compile wasm, nothing unsafe there at the top level. So that's been our guarantee the entire time is like, when you talk to it and when we give it to you, we are giving to you a hundred percent safe API. But then once you get into the internals, everything kind of all bets are off. We got lots and lots of unsafe code.",Interview P13,Exposing a Safe API,1,,51,51,1,Author 1,9/2/23,Author 1,3/18/24
13:48,¶ 51,,"We give you an API which we claim is safe. It's kind of tough to verify that. It's kind of the question of like, how do you prove that Vec is safe? I mean, like given it's safe API. So, but like, I mean, that's our theory that we've done that. But then internally, there's honestly not a ton of organization. There's a lot of really implicit guarantees that are just kind of carried around between, between everywhere and you, it's really unfortunate, but you do have to understand a huge amount of the system to mutate part of the system to note, to note that something messed up unfortunately.",Interview P13,"""Safe"" API, Unsafe is Difficult to Understand",2,,51,51,1,Author 1,9/2/23,Author 1,3/18/24
13:49,¶ 59,,"So it's one of those where like, like the communities, like just general idea here of like, encapsulated on safety, perfect. That's exactly what we want to have. We very much agree with that, but we just have not found a great way to manage that. ",Interview P13,Preference for Safety,1,,59,59,1,Author 1,9/2/23,Author 1,3/18/24
13:50,¶ 59,,"And it's very difficult to have like the one location, which is like, okay, by producing this, we are like giving you a safe type, or the safe type can only be dereferenced in the context of the store. Like we could in theory do something like that, but then it ends up a little adding extra runtime overhead. And so once we're in the internals, we don't want to add runtime overhead. So I guess to answer your question, we have not figured out a way without runtime overhead to encapsulate the unsafety in the last time, even more than it already is.",Interview P13,Increase Performance,1,,59,59,1,Author 1,9/2/23,Author 1,3/18/24
13:51,¶ 63,,"We are pretty constrained in the sense that we are generating dynamically code from like [generator] to interact with the actual runtime data structures we have as well. So the interactions are not only what we wrote in Rust, but also we are generating code to interact with. So for example, these VM context pointers that are kind of sitting all over the place, if that was actually an index within the store, then the layout of the store would have to be known to the JIT code. So it would say like the JIT code itself, when it access the store would do the bounds check would then index and do everything manually. So it's like, we couldn't write necessarily safe Rust code for that. Or rather, if we had Rust code, we'd have to like duplicate it in like [generator] machine code",Interview P13,No Other Choice,1,,63,63,1,Author 1,9/2/23,Author 1,3/18/24
13:52,¶ 63,,"We're like, number one, the runtime overhead is like very, very, very, very, very particular as to whatever strategy you want to choose in terms of making stuff safe. But then the constraint that we have of JIT code is modifying all this. It kind of constrains us as well.",Interview P13,"Increase Performance, No Other Choice",2,,63,63,1,Author 1,9/2/23,Author 1,3/18/24
13:53,¶ 67,,"A lot of us understand it and we don't have any like huge problems. We know with it. So given all those constraints and the fact that our embedding API is safe, so users don't have to worry about it. We're talking about purely an internal problem. That's only for us developers and all of us currently understand it and none of us know how to kind of like easily move it somewhere else. ",Interview P13,Audience-specific Reasoning,1,,67,67,1,Author 1,9/2/23,Author 1,3/18/24
13:54,¶ 71,,"Um, unsafe cell is like, it's kind of a little loose and I think we're not really entirely certain we use correctly. I love the place, but like probably the one example is that we do have something which is stored in thread local storage. And so that once you access the local storage, you can really only get a shared reference because at any point in the stack, you can just reacquire it. So you can't get a mutable reference unless you're dynamically check. So we don't want to do have a dynamic dynamic check. So we just put it, we give you &T, but we want to mutate &T. And then sometimes we don't want to pay the overhead of like unsafe cell or RefCell, just because like a lot of these are, these can be hot paths. And so we use UnsafeCell instead.",Interview P13,"RefCell<T>, UnsafeCell<T>",2,,71,71,1,Author 1,9/2/23,Author 1,3/18/24
13:55,¶ 71,,"Another option is like, we use this to model some data with the JIT. So like, we make sure there's an UnsafeCell for data, which is mutated by both the JIT and by [tool] to make sure that we can't like accidentally hold an mut across a JIT call by accident, because the JIT could modify it and the Rust compiler doesn't know about that. ",Interview P13,UnsafeCell<T>,1,,71,71,1,Author 1,9/2/23,Author 1,3/18/24
13:56,¶ 91,," And that's just one we haven't really invested any time to, to improve that. But otherwise for each native language, it tends to be that like the idiom we desire in each native language just really isn't well supported by some sort of automatic binding generation or automatic thing.",Interview P13,Idiomatic FFI Encapsulation,1,,91,91,1,Author 1,9/2/23,Author 1,3/18/24
13:57,¶ 91,,"I think Python six extensions, you always compile per Python version. So we're not Python experts and we don't really want to invest the time to do that. So I decided to not do that. I decided that the way we were going to do it was instead via the CFFI module. And so that's just because I didn't want to compile. I wanted to use the pre-compiled C API libraries from less than time. I didn't want to redo them, recompile them, make up CI for all that, have different architectures, different Python versions. It just seemed like a pain to do all that.",Interview P13,Bindings are a Fiddly Mess,1,,91,91,1,Author 1,9/2/23,Author 1,3/18/24
13:58,¶ 95,,So ensuring that you are not crafting an API where the types you're using will that are implicit in Rust will then turn into documentation in other languages that users have to rely on. So having a set of assumptions where you're just minimizing the burden on the user when they consume that API from another language.,Interview P13,Simple FFI,1,,95,95,1,Author 1,9/2/23,Author 1,3/18/24
13:59,¶ 95,,"So basically, it's a very long winded way of saying we had to reconcile this that the API design layer was a very much, much higher layer than like kind of dealing with models or anything like that, because we wanted a nice kind of an a ergonomic API in all languages. Like, I think we've gotten like .NET, go Python and C++ of the main ones.",Interview P13,Idiomatic FFI Encapsulation,1,,95,95,1,Author 1,9/2/23,Author 1,3/18/24
13:60,¶ 103,,"So we discovered we've never run our code in Miri because we've assumed that we are a JIT and Miri can't run JIT code, so therefore it's useless. ",Interview P13,Miri doesn't support this feature,1,,103,103,1,Author 1,9/2/23,Author 1,3/18/24
13:61,¶ 107,,Fuzzing is our number one tool for finding issues. And that's like we lean on that extremely heavily.,Interview P13,Fuzzing,1,,107,107,1,Author 1,9/2/23,Author 1,3/18/24
13:62,¶ 107,,"Like ASAN is generally intended for like C and C. ASAN is typically intended for like C and C plus plus. So if you just have memory pointers everywhere, everything's unsafe. Who knows what? So for us, we actually have never really had any issues with ASAN. We've never had use after frees.. We've never really had dangling pointers in that regard. Not to say, I mean, they have existed occasionally, but like ASAN has been relative to the cost, which ASAN gives you like a 10X-ish cost when we fuzz. It's not really worth it per se",Interview P13,ASAN,1,,107,107,1,Author 1,9/2/23,Author 1,3/18/24
13:63,¶ 111,,"Most of our fuzzing issues tend to be a lot of historical ones have been actually garbage collection related. So this is where extra ref is a data type in WebAssembly, which has just like a data from the host and it can be garbage collected and things like that. So we have a various a scheme for garbage collection and we've had a lot of issues just correctness of the compiler of like it doesn't generate stack maps. It generates incorrect stack maps. It forgets an extra ref here and there. That's just sort of a couple of issues around in the past. So we just kind of had those problems occasionally from time to time. And we've also had some code generator bugs.",Interview P13,"Fuzzing, Logical Error, Requirements Bug",3,,111,111,1,Author 1,9/2/23,Author 1,3/18/24
13:64,¶ 115,,"So one thing I've thought of though, in terms of tools in conjunction with fuzzing RR, I don't know if, have you heard from me with RR as a, as a debugger? Oh, let me tell you about RR. So RR is a, it is sort of a GDB front, it's sort of not. It's a tool from Mozilla, but it supports reverse execution. So the idea is you record a trace and it will, then you can replay that trace and you can go backwards and forwards inside of a debugger. And for debugging most fuzzing related crashes, that is an absolute godsend. ",Interview P13,Debugger,1,,115,115,1,Author 1,9/2/23,Author 1,3/18/24
13:65,¶ 115,,"That's kind of specific to us of like, I mean, it's, it's all JIT code related, but RR and debugging like GDB is only a bit so helpful because like, I mean, Dwarf and Rust is not always the best thing or debugging for, but R, specifically being able to stop, go back, replay it and do that continuously has been extremely helpful",Interview P13,"Compilation & Interpretation, Debugger",2,,115,115,1,Author 1,9/2/23,Author 1,3/18/24
13:66,¶ 119,,"Like our closest approximation is going to be we turn on the [generator] interpreter and then we interpret everything in Miri, but that would probably take about 20 hours of execution.",Interview P13,Miri is slow,1,,119,119,1,Author 1,9/2/23,Author 1,3/18/24
13:67,¶ 119,,"But for us, we're much more interested in kind of like interesting shapes of code. Like, did you consume more stack frames? Did you consume more heap? Did you have like more instructions in various weird shapes here and there? And it's been very difficult. Like a lot of the coverage based heuristics or maintaining test cases have not been sort of like, we don't think they're necessarily perfect for us. Um, there's that.",Interview P13,Wants Solution,1,,119,119,1,Author 1,9/2/23,Author 1,3/18/24
13:68,¶ 119,,"See, I don't know. I mean, we would certainly love for someone to walk in and tell us that like our architecture for [tool] could be so much simpler if we did this one thing, which has like no runtime overhead, so much safer. I don't have no one's ever come forward with that.",Interview P13,Engaging with the Rust Community,1,,119,119,1,Author 1,9/2/23,Author 1,3/18/24
14:1,¶ 19,, was doing game dev and then I worked on a web browser.,Interview P14,"Game Development, Web Browser Development",2,,19,19,1,Author 2,8/18/23,Author 1,1/18/24
14:2,¶ 51,,"Performance, FFI, implementing abstractions that you couldn't do in Safe Rust, like extending the language in ways that wouldn't quite work in Safe Rust. ",Interview P14,"Increase Performance, No Other Choice",2,,51,51,1,Author 2,8/18/23,Author 1,1/18/24
14:3,¶ 51,,"for example, different kinds of syscalls you might talk to the OS with,",Interview P14,System Calls,1,,51,51,1,Author 2,8/18/23,Author 1,1/18/24
14:4,¶ 51,,a little bit of control over data layout and accessing one type as another type,Interview P14,Transmute,1,,51,51,1,Author 2,8/18/23,Author 1,1/18/24
14:5,¶ 55,,"Usually you can get away with, you can avoid the, you don't need to use Unsafe to get away from bound checks because you can use iterators or you can find a way to, like, prove that the bound check is not needed in a way that's, like, safe and exposed by the library. But sometimes, sometimes, and I mean, bound checks are usually pretty cheap because they're correctly branch-predicted almost always. It's more about, like, I guess the most recent time I did some Unsafe would be doing SIMD intrinsics, like, that was earlier today, I did some of that, so, yeah, and that's definitely a performance thing and also, yeah, Unsafe because of target, just me. Not necessarily matching up.",Interview P14,Increase Performance,1,,55,55,1,Author 2,8/18/23,Author 1,1/18/24
14:6,¶ 55,," I guess the most recent time I did some Unsafe would be doing SIMD intrinsics, like, that was earlier today, I did some of that, so, yeah, and that's definitely a performance thing",Interview P14,Intrinsics,1,"Author 2 This wouldn't be volatile intrinsics, which are a specific type of intrinsic—it's unclear what D-intrinsics are. Response Gotcha",55,55,1,Author 2,8/18/23,Author 1,1/18/24
14:7,¶ 63,,"In particular, there's a lot of, like, level of atomic algorithms that you might want to do and having precise control over the, like, data layout allows you to be able to store something in a way that can be accessed in a lock-free manner without causing issues. That's a common one and the compiler can't necessarily prove that.",Interview P14,No Other Choice,1,,63,63,1,Author 2,8/18/23,Author 1,1/18/24
14:8,¶ 63,,"I mean, some cases you can be fine with without Unsafe, but, like, for example, if you put something in an atomic pointer and put a Box in an atomic pointer, you have to put a raw pointer and then when you get that out to use it, you need to either, like, turn that pointer into either a reference or a Box or something else and that is Unsafe. Yeah.",Interview P14,Box<T>,1,,63,63,1,Author 2,8/18/23,Author 1,1/18/24
14:9,¶ 71,,"A lot of the time when I'm doing that, it is for work on the standard library, which is one of the regular contributors to that. ",Interview P14,Rust Project Contributor,1,,71,71,1,Author 2,8/18/23,Author 1,1/18/24
14:10,¶ 83,," And if you're until relatively recently in the scheme of things, there wasn't PIN, and now PIN exists, but it's very hard to use correctly. And especially if you take a reference out of PIN, it no longer is, I mean, it's still PIN'd, but it no longer necessarily could be, you can, either it's immutable or you now use it in a way that violates the requirements of PIN.",Interview P14,Pin<T>,1,,83,83,1,Author 2,8/18/23,Author 1,1/18/24
14:11,¶ 75,,"Like, having access to self-referential data is a big one. ",Interview P14,Multiple / cyclic aliasing,1,,75,75,1,Author 2,8/18/23,Author 1,1/18/24
14:12,¶ 95,,"Oh, yeah. Very common one is like calling into C libraries. And then the other way is exposing Rust code to C or other languages. I did quite a bit of that in the past.",Interview P14,Directionality,1,,95,95,1,Author 2,8/18/23,Author 1,1/18/24
14:13,¶ 103,,"I mean, it can be bidirectional in the sense that I give C a callback and it calls it later. Or it could be, I mean, kind of the fact that it's tricky to do mutually recursive dependencies and have it link all correctly, that kind of stops that. Also, I don't know, usually when I write a program, it's going to be one way or the other.",Interview P14,"Bindings are a Fiddly Mess, Directionality",2,,103,103,1,Author 2,8/18/23,Author 1,1/18/24
14:14,¶ 112,,"Another case is C will often have kind of a bit of a rat's nest of pointers in terms of, like, an object graph. And that doesn't quite, I mean, if you can have, like, one owner of all of the objects, that works fine, but it is kind of like a mutually owned situation that sucks. Or even if you do have one owner of the object, you often would want that to be stored on, like, the same abstract, like, stored in a struct with the object graph and have that be, like, a common abstraction. But then you have a case where, like, that's effectively self-referential because you have the object and then you have on the same type that has, like, data owned by that object.",Interview P14,Different FFI Memory Model,1,,112,112,1,Author 2,8/18/23,Author 1,1/18/24
14:15,¶ 112,,"I've found that while Rust enforces thread safety based on, like, types and, like, this type is send or sink and that means all of the operations on it can behave a certain way. C tends to do it based on functions. So you'll have this function is safe to call on multiple threads and this other function, even if it's within the same type, even if it's like a method or conceptually a method because it doesn't, yeah. And that is a pretty annoying thing to, like, work around in terms of binding because you kind of have to, like, just be like, well, shit, this is not quite thread safe, even though, like, 90% of the functionality is or you just don't expose that function or something because you probably don't want to take a lock even in RwLock.",Interview P14,"Different FFI Memory Model, RwLock<T>",2,,112,112,1,Author 2,8/18/23,Author 1,1/18/24
14:16,¶ 116,," But it also is very hard to, like, put those objects, like, use those objects in a way that's not, like, okay, I just have one function that does all the get to stuff here. And then, like, I throw away all the objects at the end. And then it's hard to keep those objects around for very long unless you want all of your structs to end up with a bunch of lifetimes, which is okay, but is painful for a, you don't want that in a library and a lot of, it'll scare away new programmers for sure.",Interview P14,Difficult FFI,1,,116,116,1,Author 2,8/18/23,Author 1,1/18/24
14:17,¶ 136,,"It's tough because for that, I would say that case should probably use like some sort of weak reference on the font object, maybe because I think, but there's other cases where that's not appropriate where you actually do want the lifetime because it's a short lived object and having it be a reference counted thing would be much more trouble than it's worth, especially if the parent object is send, which is note the case for [library] stuff. ",Interview P14,"Send, Weak<T>",2,,136,136,1,Author 2,8/18/23,Author 1,1/18/24
14:18,¶ 140,,"That's one that I definitely was like, ah man, this is way more effort than I want to put into the fonts. Yeah. So I just made that one static. Transmuted that one to static, which is another use case for unsafe is working around a bad API when you know that you can use it correctly.",Interview P14,"Easier or More Ergonomic, Transmute",2,,140,140,1,Author 2,8/18/23,Author 1,1/18/24
14:19,¶ 160,,"Yeah. Another one that I actually don't have a good solution for is C APIs where they either take a source in a destination and they do allow the destination and the source to be the same light pointer, basically, or like a slice. They do a transformation on something and then they allow it to be in place. That is really hard to model well in Rust,",Interview P14,"Different FFI Memory Model, Difficult FFI, Return Pointers",3,,160,160,1,Author 2,8/18/23,Author 1,1/18/24
14:20,¶ 160,,"Especially if you need a bunch of setup to have... And you don't want it to just be two separate APIs where you boil down to the same underlying pointer operations. It is especially bad to try to re-implement part of that in Rust. I don't know exactly how to... I have an idea of how I would do it, but it sucks because you'd have to use Cells a bunch and would not feel idiomatic.",Interview P14,"Cell<T>, Different FFI Memory Model, Easier or More Ergonomic",3,,160,160,1,Author 2,8/18/23,Author 1,1/18/24
14:21,¶ 168,,"Miri is viable if you're not doing FFI. If you're doing FFI, you just have to hope.",Interview P14,"Miri doesn't support this feature, Wants Solution",2,,168,168,1,Author 2,8/18/23,Author 1,1/18/24
14:22,¶ 172,,"Rather than using a raw pointer to wrap some FFI type, they'll try to make it a reference and just pass that around. The reference is zero size and it's a way of emulating an extern type, which isn't a stable feature yet. And that's actually unsound under our current models. So that bothers me when I see it. There's definitely a little bit of a red flag that the person is getting to. I don't know. They're trying to be too clever with it and I'm a little bit skeptical of the rest of the stuff. ",Interview P14,"Code Smells, Shifting Ground",2,"Author 2 This wouldn't be difficult FFI, more of a code smell. It's definitely shifting ground though, because of ""unsound under our current models."" Response Sounds good.",172,172,1,Author 2,8/18/23,Author 1,1/18/24
14:23,¶ 172,,"Another one is any code that does callbacks into cases where you give a Rust callback to C. It's really tricky to get... I think we've gotten better in the past six months or so, but it's generally really tricky to avoid issues around panicking.",Interview P14,Difficult FFI,1,,172,172,1,Author 2,8/18/23,Author 1,1/18/24
14:24,¶ 176,,"I feel like actually just size and align separately because now that you have layout, it tries to encapsulate all of the safety requirements for passing something to allocation fun for perhaps. And it tries to be somewhat self-consistent in terms of like, well, the size needs to be able to be rounded up by the alignment. Otherwise, it's undefined behavior, but that doesn't quite... It doesn't handle all of those cases and we've had to adjust it a couple of times to tweak the safety requirements, which feels really bad because that makes some code that was written correct when it was written into code that had undefined behavior and I don't know.",Interview P14,"""Safe"" API, Layout, Wants Solution",3,,176,176,1,Author 2,8/18/23,Author 1,1/18/24
14:25,¶ 176,,"but that doesn't quite... It doesn't handle all of those cases and we've had to adjust it a couple of times to tweak the safety requirements, which feels really bad because that makes some code that was written correct when it was written into code that had undefined behavior and I don't know. It's just very easy to accidentally cause integer overflow when trying to compute the size and the alignment or very hard to avoid it in a way that is provable. Also, it doesn't handle some cases of, for example, in Windows allocation APIs, there's the ability to allocate within the C runtime rather than the kernel DLL, but the ability to allocate a three-parameter allocation function, which takes an offset, an alignment in the size, and the offset is where you can have a header where after that many bytes, it is aligned to the thing. And that's a really nice function that you cannot quite express with layout without having a bunch of extra overhead. But I mean, that's not that big, but I don't know. Yeah.",Interview P14,"Difficult to Encapsulate, Layout",2,,176,176,1,Author 2,8/18/23,Author 1,1/18/24
14:26,¶ 188,,"I mean, definitely deallocating with the... If you allocate memory with one layout, it has to be deallocated with the exact same layout. That's a big one that is a real pain in the butt and it's very easy to get wrong and coming from C, which doesn't give a shit at all in terms of... I'm sorry.",Interview P14,"Different FFI Memory Model, Layout",2,,188,188,1,Author 2,8/28/23,Author 1,1/18/24
14:27,¶ 192,,"Definitely making sure that memory that you allocate, perhaps not with Box, but in general, if you're manually allocating stuff and then giving it into Box, making sure it's actually initialized and in general uninitialized memory is something I failed to mention in terms of a case where you use unsafe code. But it is one and it's one that's very easy to get wrong.",Interview P14,"Box<T>, Box<T> Bug, Using Uninitialized Memory",3,,192,192,1,Author 2,8/28/23,Author 1,1/18/24
14:28,¶ 192,,in general uninitialized memory is something I failed to mention in terms of a case where you use unsafe code. But it is one and it's one that's very easy to get wrong.,Interview P14,Uninitialized memory,1,,192,192,1,Author 2,8/28/23,Author 1,1/18/24
14:29,¶ 196,,MaybeUninit,Interview P14,MaybeUninit<T>,1,,196,196,1,Author 2,8/28/23,Author 1,1/18/24
14:30,¶ 196,,"people assuming Boxes just a memory like a heap allocated pointer that's automatically freed rather than something that must be unique. Although that might change soon, but yeah.",Interview P14,Shifting Ground,1,,196,196,1,Author 2,8/28/23,Author 1,1/18/24
14:31,¶ 208,,a lot of the things the compiler is allowed to assume about Box are not that useful because we already get to assume those things about all pointers that get written to or read from because we get no alias as soon as it turns into a mut or shared reference and I don't know. That's almost everything has that happened all the time. So putting it on Box doesn't really help very much and definitely causes a lot of foot guns.,Interview P14,Wants Solution,1,,208,208,1,Author 2,8/28/23,Author 1,1/18/24
14:32,¶ 220,,but it also can be very hard to especially for FFI to actually pin down the safety requirements. ,Interview P14,Difficult to Encapsulate,1,,220,220,1,Author 2,8/28/23,Author 1,1/18/24
14:33,¶ 220,,"definitely for my own stuff, I find often will be like, well, this is an internal function. It's like just gets a line or something. I see. But yeah, I mean, it definitely helps because it makes it a lot easier to audit",Interview P14,Documented Contract or Invariant,1,,220,220,1,Author 2,8/28/23,Author 1,1/18/24
14:34,¶ 220,,"Like the [library], for example, there's this VFS extraction, which is literally the whole interface to all memory allocation and the OS and everything. And like, I don't know, I was trying to come up with a way to describe explain the safety requirement and it's really just don't fuck it up if you try to write one of these. ",Interview P14,"Difficult to Encapsulate, Documented Contract or Invariant, Exposing an Unsafe API to Users",3,,220,220,1,Author 2,8/28/23,Author 1,1/18/24
14:35,¶ 228,,"But then there's also that can be the worst case scenario. It can also actually the worst case scenario is if it's the document is there and not isn't complete and gives you like kind of or is straight up wrong, I guess. But usually it's, it's more often not complete rather than wrong.",Interview P14,No Docs > Incorrect Docs,1,,228,228,1,Author 2,8/28/23,Author 1,1/18/24
14:36,¶ 236,,". Yeah, or you're only doing this once or something although that's something you could enforce but Yeah, so that's, but then it might not be the most efficient way to do it and then I'll do give access to either like low level details or a more performant option with unsafe",Interview P14,"Exposing an Unsafe API to Users, Increase Performance, No Other Choice",3,,236,236,1,Author 2,8/28/23,Author 1,1/18/24
14:37,¶ 236,,"And like, in particular, handing out the C objects that I won't give that as an unsafe function but I will give that give them the raw pointer to the C object and like, they're going to have to use unsafe to use that. ",Interview P14,Exposing an Unsafe API to Users,1,"Author 2 It's unclear if this is an opaque pointer (layout not visible to Rust) or just a typical pointer, where you know the layout of the object being pointed to. Response I see, I forgot raw pointers still carry type information lol.",236,236,1,Author 2,8/28/23,Author 1,1/18/24
14:38,¶ 236,,"There's a few ways I have ideas for doing that but it doesn't come up enough for me to really worry about it much. Yeah, so definitely performance is like the number one reason for having like an unsafe API like the best reason to have like, this is the same function but without checks.",Interview P14,"Exposing an Unsafe API to Users, Increase Performance",2,,236,236,1,Author 2,8/28/23,Author 1,1/18/24
14:39,¶ 236,,"But yeah, the other one is probably like, I don't know, just just accessing functionality that you can't really find a way to expose safely or you just don't have time to expose and it's just like hey, yeah, use the C API.",Interview P14,Easier or More Ergonomic,1,,236,236,1,Author 2,8/28/23,Author 1,1/18/24
14:40,¶ 240,, The worst case for this is something like a garbage collector where the implementation is correctness depends on the algorithms correctness itself. Like that kind of thing seems like a nightmare to audit because you have this huge thing and you need to implement like make sure the whole algorithm is implemented correctly. ,Interview P14,Unsafe is Difficult to Understand,1,,240,240,1,Author 2,8/28/23,Author 1,1/18/24
14:41,¶ 240,,"That's exactly the thing that it needs to check or like this is turning a slice of the U32s into a slice of U28. It's like, yep, go for it. Yeah. I don't know that kind of stuff. I don't think I don't worry about it all anymore",Interview P14,Transmute,1,,240,240,1,Author 2,8/28/23,Author 1,1/18/24
14:42,¶ 244,,"CXX kind of is a pain in the ass to use. In general, I kind of think that's an inherent problem with talking to C++ and I don't know. I almost am on the side of just like writing a small little C library just early like a C header and like C++ implementation file to like just call into stuff.",Interview P14,CXX,1,,244,244,1,Author 2,8/28/23,Author 1,1/18/24
14:43,¶ 244,,"But yeah, bind gen I think is a little bit it for a certain type of it library. It's really the only option, but I also don't think it's that good. Like it gets a lot of stuff. It's very easy to to misuse. It's very easy to think that you're generating bindings for that you can like check into your repository and reuse. And it's so easy to get that wrong if you don't know C like for a long time it actually would generate size T that depended on your platform rather than just using U size. And so a lot of code had checked in bindings that were just wrong on Windows 32 or Windows 64 where long is not the size of a pointer 32 bits. And so like you would have size T equals C long or something. It's like, well, that's wrong.",Interview P14,Limitation of Binding Tool,1,,244,244,1,Author 2,8/28/23,Author 1,1/18/24
14:44,¶ 248,,PyO3,Interview P14,PyO3,1,,248,248,1,Author 2,8/28/23,Author 1,3/18/24
14:45,¶ 248,," Java can be okay if you use JNA, not JNI. I would definitely not use JNI for it because it's a nightmare now.",Interview P14,JNA,1,,248,248,1,Author 2,8/28/23,Author 1,3/18/24
14:46,¶ 252,, The biggest issue with it is it doesn't support fences. And so you have to like rewrite your atomics in terms of like loads on the atomic object rather than an offense,Interview P14,Wants Solution,1,,252,252,1,Author 2,8/28/23,Author 1,3/18/24
14:47,¶ 256,,"I mean, it'd be really cool if somehow Miri could also have the sanitizers back end for having every syscall implemented. Not every syscall, but having a large amount of libc implemented in terms of you could just call in to see libraries because it does interposing and stuff like that.",Interview P14,"Miri doesn't support this feature, Wants Solution",2,,256,256,1,Author 2,8/28/23,Author 1,3/18/24
14:48,¶ 268,," Or a lot of them are just like, oh, there's a really hard threading issue where I just got the ordering wrong or like didn't realize that as soon as like there's a reader still around holding onto this like no object when I freed it because... Yeah",Interview P14,"Concurrency Bug, Data Races",2,,268,268,1,Author 2,8/28/23,Author 1,3/18/24
14:49,¶ 47,,I've done a lot of database stuff since then.,Interview P14,Databases,1,,47,47,1,Author 1,9/2/23,Author 1,1/18/24
14:50,¶ 47,, I also worked on a end-to-end messaging library for a place,Interview P14,Networking & Distributed Systems,1,,47,47,1,Author 1,9/2/23,Author 1,1/18/24
14:51,¶ 51,," I don't know, accessing global variables.",Interview P14,Static Variables,1,,51,51,1,Author 1,9/2/23,Author 1,1/18/24
14:52,¶ 67,,", Queue node, nodes in a lock-free queue, it's very simple.",Interview P14,Unsafe Data Structure,1,,67,67,1,Author 1,9/2/23,Author 1,1/18/24
14:53,¶ 71,,"One of them would be the yoke-able crate that allows self-restructural data. One of them might be, there's a lot of failed versions of that, but ByteMuck allows safely transmuting different data, viewing one type as another type, in some cases, in a lot of cases, you can't really use ByteMuck, and so you're still off to using unsafe. But, yeah, yeah, that kind of stuff, like, a new fundamental operation that, you know, the language doesn't necessarily provide.",Interview P14,"Data Processing & Serialization, No Other Choice",2,"For Author 1: this feels more like the munch crate someone else mentioned above, which would make it ""Data Structures, Primitives, and Operations"" instead of ""Data Processing & Serialization"".",71,71,1,Author 1,9/2/23,Author 1,1/18/24
14:54,¶ 75,,Yeah. Or there's a lot of more operation-shaped things that you can implement a lot of stuff in inline assembly.,Interview P14,Inline Assembly,1,,75,75,1,Author 1,9/2/23,Author 1,1/18/24
14:55,¶ 132,,"Because you can't then put like, be like, Oh, this is the thing that holds all the font stuff and it has the font context and then the font, which you probably want to do in a lot of cases. Because I don't know, you probably don't want your whole program to now have a lifetime for font stuff. Yeah.",Interview P14,Difficult FFI,1,,132,132,1,Author 1,9/2/23,Author 1,1/18/24
14:56,¶ 136,,"As soon as you have like a reference on it, you now need to track, as soon as you're doing reference counting where you have like the child object, not containing a lifetime to the parent. And you have to like make sure that one is not used on a different thread than the other, just a huge pain.",Interview P14,Difficult FFI,1,,136,136,1,Author 1,9/2/23,Author 1,1/18/24
14:57,¶ 168,," If you're doing FFI, you just have to hope.",Interview P14,Tacit Knowledge,1,,168,168,1,Author 1,9/2/23,Author 1,1/18/24
14:58,¶ 172,," Another place that I look out for is any code dealing with manual allocation. That's super hairy to get right in Rust for whatever reason. I feel like our layout struct, it's neat conceptually, but it's very easy to misuse and very hard to use correctly. I don't feel like it was the right abstraction, but it's there and we can't get rid of it now.",Interview P14,"Code Smells, Layout",2,,172,172,1,Author 1,9/2/23,Author 1,1/18/24
14:59,¶ 268,,"I mean, a lot of these are fixed now, but like the handling panics, it took so long for me to figure out how to handle like wrap a function and catch a panic and then not have a case where that function could panic with a payload that itself when it was dropped panics again. Which is a really ridiculous case to worry about because who is trying to like really hard to hone their own program, but... ",Interview P14,Panic Safety,1,,268,268,1,Author 1,9/2/23,Author 1,3/18/24
14:60,¶ 252,,"AddressSanitizer, I've never actually really had it catch anything that was a big bug, but I don't know. It's nice to like run it on CI and be like, yeah, great. I definitely have that on several of my libraries. ",Interview P14,ASAN,1,,252,252,1,Author 1,9/2/23,Author 1,3/18/24
14:61,¶ 248,," For like weird languages for like, I would definitely use it for PyO3 over handwriting Python bindings.",Interview P14,Generation VS Validation,1,,248,248,1,Author 1,9/2/23,Author 1,3/18/24
14:62,¶ 244,,"Yeah, other than that, Uniffi was cool…But it, I mean, you got to buy into like writing a separate IDL for it. And so like it's a very limited use case. But it's cool. I can generate like a bunch of different bind it like bindings for a bunch of different languages.",Interview P14,"Idiomatic FFI Encapsulation, Uniffi",2,,244,244,1,Author 1,9/2/23,Author 1,3/18/24
14:63,¶ 240,,"And then in terms of the implementation, if, yeah, I don't worry about the amount of unsafe and the implementation particularly and I do worry about the way I think about it is I want each like thing I'm doing the unsafe to be easy to verify on its own.",Interview P14,"Local, Minimal Unsafe",1,,240,240,1,Author 1,9/2/23,Author 1,1/18/24
14:64,¶ 240,,"Yeah, and I mean, ideally the safe version has very little overhead. It's pretty rare for there to be none. I mean, somewhere you're going to access an array and it's going to have a bounce check and that's just how it is. Or a slice but yeah. But that's very cheap and not worrying about that took me a long time. ",Interview P14,Preference for Safety,1,,240,240,1,Author 1,9/2/23,Author 1,1/18/24
14:65,¶ 216,,I mean RefCell is pretty panic prone in practice. But that's not that big of a foot gun. I don't know. I definitely prefer people use the cell types and use like global mutables and stuff like that. Yeah. I think the cell like sell itself is probably a little bit underused because you often want like just a counter or something. Or the atomic types. If you need to be. Yeah.,Interview P14,"Cell<T>, RefCell<T>",2,,216,216,1,Author 1,9/21/23,Author 1,1/18/24
15:1,¶ 3,,"What happened was, I realized I needed to do something in, in WebAssembly, because we want some, again, this is, I'm going to, this is what I, it would be so much easier if I could talk about the details of what I'm working on. What happened was, an application we needed to build, had to be in WebAssembly, had to use C++ libraries, and had to run in the web browser.",Interview P15,Web Application Development,1,,3,3,1,Author 2,8/19/23,Author 1,1/18/24
15:2,¶ 11,," I will say I spent about a month figuring out how to get the C++, that particular library and other libraries to successfully link with WebAssembly.",Interview P15,Bindings are a Fiddly Mess,1,,11,11,1,Author 2,8/19/23,Author 1,1/18/24
15:3,¶ 25,,"We only support WASM unknown under WASM32-unknown-unknown. We don't like Wasi, whatever. And what I ended up doing is I figured out how to compile. I used the Wasi tools to compile the C plus plus libraries. I linked them. I told, I used the target option to say target wasm32-unknown-unknown. And because I did not have the standard C plus plus libraries available, I had to reimplementing a subset of the standard C library in unsafe Rust so that I could successfully link to this stuff.",Interview P15,Limitation of Binding Tool,1,,25,25,1,Author 2,8/19/23,Author 1,1/18/24
15:4,¶ 25,," And because I did not have the standard C plus plus libraries available, I had to reimplementing a subset of the standard C library in unsafe Rust so that I could successfully link to this stuff.",Interview P15,"No Other Choice, Rewrite it in Rust",2,,25,25,1,Author 2,8/19/23,Author 1,1/18/24
15:5,¶ 25,,"I tried to get things like Wasi and the Emscripten targets to work and, you know, I actually like found a few bug reports against the WESem, things like wasm-bindgen and got a big, you know, flows immediately.",Interview P15,"WASI, wasm-bindgen",2,,25,25,1,Author 2,8/19/23,Author 1,1/18/24
15:6,¶ 53,,"I was going to be calling these open source libraries like a hundred times went and crossing the Wasm Web Assembly JavaScript boundary way more than I thought it was going to be acceptable. And I was like, this is unacceptable. We can't do this. And I want to, I'm going to need to rewrite a lot more of my logic in something that lives on the web assembly side so that I can have a more of a heavy duty chatty interaction with these C++ libraries and cross the Web Assembly JavaScript boundary a bit more,",Interview P15,Increase Performance,1,,53,53,1,Author 2,8/19/23,Author 1,1/18/24
15:7,¶ 69 – 70,,"And it has the unsafe keyword on this. You pass a slice of something, I get the pointer and then the 
length and then pass it to this a C++ wrapper generated with I forget the name of the thing, bindgen something.",Interview P15,"rust-bindgen, Simple FFI",2,,69,70,2,Author 2,8/19/23,Author 1,1/18/24
15:8,¶ 94,,"I just looked at that as a caveat of how I'm using these libraries. And when I started writing my real business logic in Rust, there's just this one little caveat, a big comment saying, don't you better make sure that this thing survives longer than this thing or else you'll crash.",Interview P15,Documented Contract or Invariant,1,,94,94,1,Author 2,8/19/23,Author 1,1/18/24
15:9,¶ 90,,I had to have a foo which wrapped this library and then a bar that wrapped this library with some references between them. And I could not completely express the semantics to the Rust. ,Interview P15,No Other Choice,1,,90,90,1,Author 2,8/19/23,Author 1,1/18/24
15:10,¶ 90,,I had to have a foo which wrapped this library and then a bar that wrapped this library with some references between them. And I could not completely express the semantics to the Rust. I,Interview P15,Multiple / cyclic aliasing,1,,90,90,1,Author 2,8/20/23,Author 1,1/18/24
15:11,¶ 94,,"So it's like, I did not create wrappers that are fully kosher from a Rust perspective, but then I just looked at that as a caveat of how I'm using these libraries. And when I started writing my real business logic in Rust, there's just this one little caveat, a big comment saying, don't you better make sure that this thing survives longer than this thing or else you'll crash. ",Interview P15,"Contract or Invariant, Documented Contract or Invariant",2,"Author 2 It's unclear to me whether wrappers that are not ""fully kosher"" involve unsafe types, or if they're just ""safe"" APIs, so I'd hesitate to use ""exposing an unsafe API to users"" here. There's definitely a contract or invariant on lifetimes here though. Response Okay, I'll remove the code, but I think this shows I am not certain about the distinction between exposing an unsafe API and ""safe"" API.",94,94,1,Author 2,8/20/23,Author 1,1/18/24
15:12,¶ 69,,"Essentially, I just wrote wrappers for these C++ libraries in unsafe Rust that provided and that just provided a Rust that just provided a Rust safe wrapper. And honestly, it wasn't that hard. ",Interview P15,Exposing a Safe API,1,"Author 2 I think that local minimal unsafe is generally related to situations where unsafe is implementing some functionality, where that functionality is its 1st-order purpose. In this situation, the unsafe is serving as FFI glue between safe Rust and C++, and since the extent to which the unsafe is ""minimal"" is a little unclear, it's not the best fit for this code. Response I completely agree, I think this was a typo.  I meant to put Exposing a Safe API.",69,69,1,Author 2,8/20/23,Author 1,1/18/24
15:13,¶ 96 – 97,,"And to clarify the situation, it's, is it that you have one parent struct, and then you have these two members and each reference 
each other.",Interview P15,Unsafe Data Structure,1,,96,97,2,Author 2,8/20/23,Author 1,1/18/24
15:14,¶ 104,,"You have a situation where you want to do this and, and the sort of the correct answer that, you know, someone that that was a really good Rust developer said is, this is just something that you just avoid in Rust and you, and you just, you just stay away from",Interview P15,Preference for Safety,1,,104,104,1,Author 2,8/20/23,Author 1,1/18/24
15:15,¶ 108,,"I look at this and I'm just like, okay, I just need to have my bar exist as long as the foo exists. And since they're in the same structure, that's fine. And, and to me, it's just small potatoes. I mean, C plus plus, you do this all the time. And, and I'm just like, like, I know this is not a problem. ",Interview P15,"It's not a problem, Tacit Knowledge",2,,108,108,1,Author 2,8/20/23,Author 1,1/18/24
15:16,¶ 94,,"And given that I'm an old school CC plus plus developer where this where you do this stuff all the time, I'm having this one little caveat in this piece of code that I wrote and then probably ignored for like, the next year was just not that big a deal.",Interview P15,Audience-specific Reasoning,1,"Author 2 It's unclear what the audience is here. Maybe audience-specific documentation instead? Response I think this quote captures an interesting difference in how former C++ devs approach unsafe code vs a lot more dogmatic rust people do.  Here the audience is ""old school CPP devs"" and the reasoning is letting little caveats and holes slide by without encapsulation.",94,94,1,Author 2,8/20/23,Author 1,1/18/24
15:17,¶ 108,,"And I'll say that one of the things I've seen on, you know, the Rust forms on Reddit that I start, there's this sort of phobia of undefined behavior that goes on. And it's almost at the degree of you have even the slightest concession to undefined behavior, and you've committed a crime against humanity. And, you know, and I'm kind of like, you know, and I honestly roll my eyes at this, like I've been in the C and C plus plus world, I know why I don't want to do it.",Interview P15,"Stigma Against Unsafe, Tacit Knowledge",2,,108,108,1,Author 2,8/20/23,Author 1,1/18/24
15:18,¶ 120,,"And in some cases, those wrappers themselves had caveats. And I just put big comments on them and said, when you use these wrappers, here are some caveats. Again, you know, compared to the C++ world, this is nothing",Interview P15,"C++ is Difficult, Documented Contract or Invariant",2,,120,120,1,Author 2,8/20/23,Author 1,1/18/24
15:19,¶ 128,,"And there's a notion of fonts and then there's also a notion of faces and a font, indirectly references the face it was based on and when an app happening is that my logic that where I had to work with these fonts and faces got put into another object that then was, I put an Arc around. Okay. So it's just by the time I got to either Rc/Arc or bot, like the wrapper code I wrote does not have a single Rc/Arc or Box in it.",Interview P15,"Arc<T>/Rc<T>, Box<T>",2,,128,128,1,Author 2,8/20/23,Author 1,1/18/24
15:20,¶ 132,,"So, and the code that actually used those wrappers itself does not have an Rc/Arc or Box on it. But that latter object is often referenced with an Rc/Arc or Box",Interview P15,"Arc<T>/Rc<T>, Box<T>",2,,132,132,1,Author 2,8/20/23,Author 1,1/18/24
15:21,¶ 152,,bindgen,Interview P15,bindgen,1,,152,152,1,Author 2,8/20/23,Author 1,1/18/24
15:22,¶ 168,," I, I mean, it's a well-crafted C and C plus plus API just gives you opaque pointers and like, I don't, and for the same reason, you wouldn't want to be as a C developer though and, you know, reaching into some instructors. ",Interview P15,"Opaque Pointer, Simple FFI",2,,168,168,1,Author 2,8/26/23,Author 1,1/18/24
15:23,¶ 176,,"I spat out a bunch of printfs and, and then found out that, and that found out from the perspective of those libraries, the standard C library was misbehaving.",Interview P15,Printf-Style Debugging,1,,176,176,1,Author 2,8/26/23,Author 1,1/18/24
15:24,¶ 180,,and saw some classic C++ memory thrashing. ,Interview P15,,0,"Author 2 This doesn't seem like a bug; more of a symptom of the bug, which was an incorrectly implemented function. Response Okay",180,180,1,Author 2,8/26/23,Author 1,1/18/24
15:25,¶ 184,,"ike I'm doing, grabbing a pointer and then doing an offset on it,",Interview P15,Pointer Arithmetic,1,,184,184,1,Author 2,8/26/23,Author 1,1/18/24
15:26,¶ 200,,"I don't know why it's going on and I'm going to throw down some print f's and I'm, I'm kind of, maybe I'm kind of a Luddite, but it just didn't occur to me that there was something out there that might have helped me find this. ",Interview P15,"Printf-Style Debugging, Unaware of Tools",2,,200,200,1,Author 2,8/26/23,Author 1,1/18/24
15:27,¶ 208,," Okay, I'm looking at my comments. Um, yeah, I just did not, I did not understand the semantics of the layout, the std, std alloc layout object and exact, and the pre and post conditions for, um, for like how I use that and, and in the traditions of, of unsafe code, um, when I first wrote it, it mostly worked until I had a bug.",Interview P15,,0,"Author 2 This doesn't seem like shifting ground, in that the Layout API had clearly defined preconditions and postconditions. I think this person just didn't understand how to use it correctly. Response I see.  You're right.",208,208,1,Author 2,8/26/23,Author 1,1/18/24
15:28,¶ 212,,"I think it had to do with me passing the alarm, reporting the alignment and passing it.",Interview P15,"Allocation & Alignment Bug, Improper Alignment",2,,212,212,1,Author 2,8/26/23,Author 1,1/18/24
15:29,¶ 240,,"I just remember Googling for MaybeUninit and then seeing a lot of discussions about when it's appropriate to use that and when it's not appropriate to use that and why this reserve and, and I don't even remember the unsafe resize in the vector was like the proper way to go about it.",Interview P15,MaybeUninit<T>,1,,240,240,1,Author 2,8/26/23,Author 1,1/18/24
15:30,¶ 252,," A little piece of commentary that the Rust in general is, I love it. I love being able to successfully reduce the, you know, unsafe stuff to this extremely small amount. I love it, changing it from something I have to deal with 100% of the time to something I have to deal with 1% of the time.",Interview P15,"Fanboyish, Local, Minimal Unsafe, Memory Safety",3,,252,252,1,Author 2,8/26/23,Author 1,1/18/24
15:31,¶ 252,,". I do not understand in the community about the obsession of getting that down to zero, because it's like, like one thing I tried to do, because I was like, hey, you would be really nifty. I could probably save a few bytes on my web assembly if I go and, if I go and find an option to make all panics be undefined behavior.",Interview P15,Stigma Against Unsafe,1,,252,252,1,Author 2,8/26/23,Author 1,1/18/24
15:32,¶ 252,," Because, hey, like, I'm telling the compiler, you see a panic, you can optimize the hell out of this. And I was just like, hey, I can save a few dozen bytes. I was amazed that there's not an option to do so. ",Interview P15,Increase Performance,1,Author 2 What does low-level access represent here? I'd usually associate that with hardware. Response I'm honestly not sure why I put Low-Level Access here.,252,252,1,Author 2,8/26/23,Author 1,1/18/24
15:33,¶ 252,," I think on [forum] a few months ago, I got a lot of, like, it was like I was proposing slaughtering children or something like this. It's like this phobia of undefined behavior is like so great that I'm like, and I'm thinking in my mind, like, I'm running in web assembly, I'm running in an environment hardened against malware. If I could go and get rid of my panics and save a few bytes, then I want to do so. And I get the benefit when I run my stuff on native code, which I'm doing anyway. And I just find it weird that there's this allergy to that out there.",Interview P15,Stigma Against Unsafe,1,,252,252,1,Author 2,8/26/23,Author 1,1/18/24
15:34,¶ 120,,"So I guess what happened is I created a bunch of wrappers for C++ code, just so that I'm not just randomly calling unsafe, you know, like get pointer, get length, and calling this other stuff.",Interview P15,Preference for Safety,1,,120,120,1,Author 2,8/26/23,Author 1,1/18/24
15:35,¶ 3,,"And then I was like, I just immediately realized that JavaScript calling Emscripten C++ libraries was not going to cut it. It's like, I was not going to go and marshal things across a boundary all the time.",Interview P15,Emscripten,1,,3,3,1,Author 1,9/2/23,Author 1,1/18/24
15:36,¶ 11,,"There's a thing called Rusty Buzz out there, which is an attempt to rewrite it. And it says, Oh, this is great because we rewrote it in Rust. It runs 98% of the benchmarks correctly. And I was like, I don't want 98%. I want 100%. And furthermore, I use half buzz. I know that I'm using the industry standard library out there that everybody and their mother uses. And there's in that I never have to doubt that this thing is this Rusty Buzz thing is off to snuff.",Interview P15,Rust Rewrite is Incomplete,1,,11,11,1,Author 1,9/2/23,Author 1,1/18/24
15:37,¶ 49,,"Like, I'm going to be honest. I hate it. That was one of the most miserable months of my life, just figuring out, like, I'm good at getting tools and things to build, but I hate it. And that's maybe that's why I'm good at it.
",Interview P15,Bindings are a Fiddly Mess,1,,49,49,1,Author 1,9/2/23,Author 1,1/18/24
15:38,¶ 108,,"But I'm sort of like, hey, I can go in, if I write a dozen lines of code that maybe not doesn't have this caveats, I mean, and that doesn't line the code and then as opposed to, you know, 50,000 lines of code application, and to me, it's just not a big deal.",Interview P15,"Local, Minimal Unsafe",1,,108,108,1,Author 1,9/2/23,Author 1,1/18/24
15:39,¶ 120,,"So I sort of feel, so for me, using Rust was not so much about eliminating 100% of undefined behavior from my code, but it's rather the ability to coordinate to this 2% of my code base or whatever, that, you know, that where I'm dealing with this stuff, whether it's in the wrappers that directly access it, or some of some caveats based on those wrappers and from those wrappers themselves.",Interview P15,"Local, Minimal Unsafe",1,,120,120,1,Author 1,9/2/23,Author 1,1/18/24
15:40,¶ 148,,"And this is just because PowerFuzz and these other libraries that I'm working with, like they have an API and they don't, and just like a well-crafted C and C++ API, they don't generally like, like, this is an API that's been around for a while and they don't want you go, and I don't have to do that for the same reason that when you build a C API, you don't necessarily have to do that when calling that or, or even things like, you know, the Zlib libraries or anything like that.",Interview P15,Simple FFI,1,,148,148,1,Author 1,9/2/23,Author 1,1/18/24
15:41,¶ 158,,"I mean, I just ran the thing and it spat out a bunch of wrappers and I feel I spent more time just messing with the compiler and getting it to link and the getting, and getting a, getting a version of these libraries building with WebAssembly and then, and, and just getting things to link. So I feel any problems I had with bindgen were, were completely drowned out by just general build system stuff.",Interview P15,Generation VS Validation,1,,158,158,1,Author 1,9/2/23,Author 1,1/18/24
15:42,¶ 220,,"And because there's literally like only one place in my code base where I was doing that, it's like, it just, like, I feel it's something like that in practice would not be useful because it's like, hey, I'm doing this thing once. And, and then once I get this code working right, it's I ignore it and for the rest of my life. And it's not this, I have a feeling that the way I might be a weirdo for you is that in the code base I've written, the unsafe Rust is this, like, I got it working and then, and then moved on. It's not this pervasive theme in my development. ",Interview P15,"Local, Minimal Unsafe",1,,220,220,1,Author 1,9/2/23,Author 1,1/18/24
15:43,¶ 228,," Like, I'm used to met in the C++ in the C world, I'm used to malloc and free. And you don't have to go and like, you know, and when you deallocate memory, you don't necessarily have to go and, you know, have this information like the information that is around that, when when you allocated memory, in fact, I'm like, did I'm when you free memory? Yeah, it's like, I see I'm looking at my implementation of free. And it's like, I have to go in. Yeah, I have to pass in the layout object that I used to create the memory at the beginning. And I guess, and it better be the same and I ended up in just my wrappers just caching out along with everything else.
",Interview P15,Feature Disparity,1,,228,228,1,Author 1,9/2/23,Author 1,1/18/24
15:44,¶ 232,,"And I think, and I will say I found the blog entries about why you have to do that and not memory on the to be pretty interesting because it went into pretty, into pretty in-depth details about the assumptions that, the assumptions that you're allowed to make and the ones that you're not allowed to make.
",Interview P15,Engaging with the Rust Community,1,,232,232,1,Author 1,9/2/23,Author 1,1/18/24
15:45,¶ 240,,"Again, coming from the C++ world, this was all like, I mean, the material itself was like not something that I was, it's not, I wasn't saying da too, but it's like, I get it. Like, I know, I, I know about, I've worked with undefined behavior and C++ and I get it.",Interview P15,Shared Experiences,1,,240,240,1,Author 1,9/2/23,Author 1,1/18/24
15:46,¶ 86,,"And since these libraries are well established, heavily used open source things, I think that from a rust-bindgen perspective, they were probably the easiest things to add. And I think I'm pretty sure rust-bindgen is used to wrap the LLVM libraries for the Rust compilers. And I'm on the bet that compared to that, like, this was like, this was small potatoes.",Interview P15,rust-bindgen,1,,86,86,1,Author 1,9/3/23,Author 1,1/18/24
16:1,¶ 3,,So it's performance when it comes to critical code. ,Interview P16,Rust Performs Well,1,,3,3,1,Author 1,8/10/23,Author 1,1/19/24
16:2,¶ 3,,"And also when dealing with writing sometimes low-level code, I just like to use it ",Interview P16,Low-Level Access,1,,3,3,1,Author 1,8/10/23,Author 1,1/19/24
16:3,¶ 40,,"Okay. I would say maybe for example, when writing a low-level code, such maybe an operating system would be running device drivers or embedded systems, I can use, I mostly use unsafe Rust because I feel like it's necessary to use it. And maybe especially the scenarios when they maybe want to infer things like memory manipulation, interacting with hardware, or maybe performing operations that are not covered by other safety guarantees of the language. ",Interview P16,No Other Choice,1,,40,40,1,Author 1,8/10/23,Author 1,1/19/24
16:4,¶ 44,,"Okay. Let's say maybe when I'm dealing with some kind of unsafe abstractions, when you say I'll say this can go maybe, you know, writing some kind of safe API when it's actually surrounded by some kind of unsafe implementation. So in such sense, then I would just use unsafe Rust.",Interview P16,Easier or More Ergonomic,1,,44,44,1,Author 1,8/10/23,Author 1,1/19/24
16:5,¶ 69,,"So maybe, or when maybe dealing with the performance critical code, certain performances, then, you know, I have to look at the critical sections of my code and then it's key for me to, you know, to look for the unnecessary or necessary points where I can use unsafe for us just to achieve fine-grained control over memory allocation or maybe do the occasional perform low-level optimizations. So it's important to profile and benchmark your code to ensure that, you know, the performance gains outweigh the risk associated with unsafe code just because it's unsafe, that's it. ",Interview P16,"Increase Performance, Profiling",2,,69,69,1,Author 1,8/10/23,Author 1,1/19/24
16:6,¶ 90,,"Some of the instructions, like, just telling them about the, for example, I mentioned from them about the security vulnerabilities that that code has, or maybe the level of compatibility or some kind of talk about compilers and everything. So it matters really how I have confirmed the code and maybe how I think it's better for somebody to better use it. So I just can lay out in a kind of a way that it's easy to understand it doesn't be a problem to maybe the next user. So just to make it as easy and communicating, of course.",Interview P16,Documented Contract or Invariant,1,,90,90,1,Author 1,8/10/23,Author 1,1/19/24
16:7,¶ 102,,"And also I think, you know, especially when you're sharing unsafe Rust to maybe colleagues or maybe people you're working with, maybe a particular project, you know how it is, you just don't take, sometimes you're working as a group of people, particular project. And so when you share it, some people are having trouble trying to understand the code and also maintenance of the code is also kind of, it's complex and it's harder to reason about compared to safe code, you know. And also, you know, the movement of low level operations, raw pointers and intricate memory manipulations. I think those are some maybe points that I can highlight and say they are quite a challenge.",Interview P16,Unsafe is Difficult to Understand,1,,102,102,1,Author 1,8/10/23,Author 1,1/19/24
16:8,¶ 102,,"So when you are using unsafe rust, you'll be sure to get problems like low buffer overflows, or some memory corruption, or maybe you'll be sure to be able to collect a lot of external resources, or maybe you can run into maybe careless or maybe incorrect usage of unsafe rust, it can compromise your security system. I actually compromised one of the processes, we had to work for [redacted] and we had to run unsafe rust and it was totally compromised. So we had to like work it for about 72 hours to recover it, it was so hectic.",Interview P16,"Integer Bounds & Overflow Bugs, Security Vulnerability",2,,102,102,1,Author 1,8/10/23,Author 1,1/19/24
16:9,¶ 164,,"So when it comes to C++, when it comes to, in reference to memory, I think it lacks safety guarantees and also some features of Rust is more modern than C++. So that's just like of, I'll say C++ is more for kind of analog. So when it comes to when you're using modern language features of, you know, like presenting Rust currency, then it leads to more bugs and vulnerabilities if you're not careful.",Interview P16,Feature Disparity,1,,164,164,1,Author 1,8/10/23,Author 1,1/19/24
16:10,¶ 182,," So and also, I can maybe, I guess, or maybe be sure about it, is when it comes to building configurations, it's also where you can get some, some challenges in building configurations. Also things like compile time errors, it's also a problem that I deal with. ",Interview P16,Bindings are a Fiddly Mess,1,,182,182,1,Author 1,8/10/23,Author 1,1/19/24
16:11,¶ 182,,"Sometimes it takes longer time to compile, and especially with a larger code bases, or maybe projects with many dependencies, the process is, is too slow. And I feel like it's too slow, like you need some work to be done.",Interview P16,Limitation of Binding Tool,1,,182,182,1,Author 1,8/10/23,Author 1,1/19/24
16:12,¶ 228,,"I just use unsafe Rust when it's necessary. And I will say that I have maybe much confidence when using unsafe Rust, I just use it when it's necessary. So it's something that I can see the tool that I use, it's a language that I like using as much. So I'm very cautious when using it, and I make sure that I do some moderating just to make sure that in case of problems, I would have a bigger problem.",Interview P16,No Other Choice,1,,228,228,1,Author 1,8/10/23,Author 1,1/19/24
16:13,¶ 85,,"So I just leave it like instructions just because I am considerate that, also I benefit from resources online from other programmers. I just leave instructions there for, just for anybody else who might want to use the unsafe, unsafe Rust. So I just leave it for maybe other users.
",Interview P16,Engaging with the Rust Community,1,,85,85,1,Author 1,9/5/23,Author 1,1/19/24
16:14,¶ 106,," but to do with memory manipulations, yeah, it's been a sort of issue. And also it makes it difficult to detect and fix bugs, so yeah.",Interview P16,Unsafe is Difficult to Understand,1,,106,106,1,Author 1,9/5/23,Author 1,1/19/24
16:15,¶ 190,,"I think once you're done, that's it. I have never made, or maybe have post, maybe post challenges or maybe first errors, I think so it just works.",Interview P16,Generation VS Validation,1,,190,190,1,Author 1,9/5/23,Author 1,1/19/24
16:16,¶ 198,,"And so actually the best thing is that for example, the UBSan is able to detect potential bugs, potential bugs even without them occurring. So you can be able to fix that even before the actual bug happen.",Interview P16,UBSAN,1,,198,198,1,Author 1,9/5/23,Author 1,1/19/24
16:17,¶ 216,,"And I think unsafe Rust should be used in a very cautious way, or maybe when it's necessary, because it can cause problems sometimes.",Interview P16,Preference for Safety,1,,216,216,1,Author 1,9/5/23,Author 1,1/19/24
16:18,¶ 228,,"So I'm very cautious when using it, and I make sure that I do some moderating just to make sure that in case of problems, I would have a bigger problem.",Interview P16,Preference for Safety,1,,228,228,1,Author 1,9/5/23,Author 1,1/19/24
17:1,¶ 7,,"Well, it started with small command line applications just to automate some tasks that I like. ",Interview P17,Personal Tools & Toy Projects,1,,7,7,1,Author 1,8/10/23,Author 1,1/18/24
17:2,¶ 7,,I did a chess engine and chess website in Rust.,Interview P17,Web Application Development,1,,7,7,1,Author 1,8/10/23,Author 1,1/18/24
17:3,¶ 11,, I found I was able to get more performance by using enums for the rank and file because it limited to the zero to seven index of rank and file. And also for a combined rank and file is like a square. Right. And that's zero to sixty four. So as opposed to I guess more I was using unsafe to constrain my types to enums. And then the unsafe bit here is that the casting to enums knowing the discriminant of it.,Interview P17,"Contract or Invariant, Increase Performance",2,,11,11,1,Author 1,8/10/23,Author 1,1/18/24
17:4,¶ 19,,"There's no more bounds checks on fixed size arrays of squares because the compiler is smart enough to figure out this enum has... Its discriminants are zero to sixty three, so no need for a bounds check.",Interview P17,Compiler Eliding Bounds Checks,1,,19,19,1,Author 1,8/10/23,Author 1,1/18/24
17:5,¶ 23,,"I've also written little boot loaders for like x86 computers. And that's just lots of unsafe there interacting with like IO ports, raw pointers in memory and stuff like that.",Interview P17,Operating & Embedded Systems,1,,23,23,1,Author 1,8/10/23,Author 1,1/18/24
17:6,¶ 27,," And I find that's probably a better solution to get rid of the bounds checks than just to unsafely get rid of the bounds checks at the point where you're indexing. If you can prove that this type can only be zero to sixty three, then the compiler removed the bounds checks for me.",Interview P17,Compiler Eliding Bounds Checks,1,,27,27,1,Author 1,8/10/23,Author 1,1/18/24
17:7,¶ 31,,"I mean, ergonomics also was a factor.",Interview P17,Easier or More Ergonomic,1,,31,31,1,Author 1,8/10/23,Author 1,1/18/24
17:8,¶ 47,,And then using a small amount of global assembly to set up like an initial stack,Interview P17,Inline Assembly,1,,47,47,1,Author 1,8/10/23,Author 1,1/18/24
17:9,¶ 51,,The unsafe there is this little bit of assembly at the start. Any inline assembly for it to call the BIOS disk functions use interrupts and those are inherently kind of unsafe and to do so you use some inline assembly.,Interview P17,"Inline Assembly, No Other Choice",2,,51,51,1,Author 1,8/10/23,Author 1,1/18/24
17:10,¶ 23,,"And that's just lots of unsafe there interacting with like IO ports, raw pointers in memory and stuff like that.
",Interview P17,"Interacting with hardware, No Other Choice",2,,23,23,1,Author 1,8/10/23,Author 1,1/18/24
17:11,¶ 55,,"But then it's still unsafe to just write to some random memory locator you have no operating system to tell you to give you memory protections at this stage right. So, you're just writing to the raw RAM.",Interview P17,"Interacting with hardware, No Other Choice",2,,55,55,1,Author 1,8/10/23,Author 1,1/18/24
17:12,¶ 63,,"Luckily, global assembly, so the global assembly you can actually assign these registers values, mark them as an input or an output and continue on that way and then these safe abstractions around them would simply just be a function that it takes those parameters the normal way and returns the results normally.",Interview P17,"Inline Assembly, Interacting with hardware",2,,63,63,1,Author 1,8/10/23,Author 1,1/18/24
17:13,¶ 63,,"So, like, and especially with BIOS stuff you need to have registers, be very specific values. One of those values will actually be decides what operation the BIOS will perform for you and then like other ones will be like parameters for the operation and then the BIOS, when returns, when it returns control to you will have set a bunch of those things to different stuff for like return values of status and that kind of stuff. ",Interview P17,Contract or Invariant,1,,63,63,1,Author 1,8/10/23,Author 1,1/18/24
17:14,¶ 67,,"Yeah, one case especially that uses that is getting the memory layer computer. So, one of the BIOS interrupt calls will like what's called the E820 memory layout and it basically you don't pass it a pointer, you receive a pointer from it and make sure you don't overwrite all that memory that it gave you. It's supposed to be done very early on, it's in some special BIOS area of memory.",Interview P17,MaybeUninit<T>,1,,67,67,1,Author 1,8/10/23,Author 1,1/18/24
17:15,¶ 71,,"one of the things that LLVM will do when performing optimization passes is pre-fetch reads or completely negate the need to have a read of memory because it already knows what the value is or thinks it does. But those assumptions could be broken by the BIOS when performing this call. So it's very careful to say, like, I need a stack to belong here, this thing could touch memory that you don't know about and those kind of markers are present in Rust inline assembly.",Interview P17,"Contract or Invariant, Inline Assembly",2,,71,71,1,Author 1,8/10/23,Author 1,1/18/24
17:16,¶ 82,," certainly you wouldn't want to violate the mutable aliasing properties, you can't, if, like, straight up when you have two mutable pointers that's undefined behavior, right, so even if some BIOS function lets you get around that that would be bad. I certainly wouldn't, I didn't run into any cases where I had to try and skirt around Rust borrowship rules in that case. ",Interview P17,It's not a problem,1,,82,82,1,Author 1,8/10/23,Author 1,1/18/24
17:17,¶ 86,,"But the way to get around that, though, is to not take mutable pointer to perform volatile writes using using a raw pointer. So Rust has just SCDPTR write volatile, right?",Interview P17,Volatile Intrinsics,1,,86,86,1,Author 1,8/10/23,Author 1,1/18/24
17:18,¶ 106,,"So, you know, writing C wrappers for some of my libraries or consuming C libraries with Rust. And in that case, just Boxing and leaking a pointer and passing the pointer to Rust. And then the unsafe part then is when you receive that pointer back to drop it, you need to convert it to a Box, right? Unsafely.
",Interview P17,"Allocation in Rust, Box<T>",2,,106,106,1,Author 1,8/10/23,Author 1,1/18/24
17:19,¶ 127,,"Although if it's some structure you have in Rust and it's going to be passed back to you to free it up, you might as well use Box.",Interview P17,"Allocation in Rust, Box<T>",2,,127,127,1,Author 1,8/10/23,Author 1,1/18/24
17:20,¶ 143,,"I mean, certainly if you're calling into some C code, you have no idea whether it's going to keep that pointer or get rid of it, right? So you can't make the guarantees. You just have to kind of verify trust.",Interview P17,Difficult FFI,1,,143,143,1,Author 1,8/10/23,Author 1,1/18/24
17:21,¶ 147,,"JavaScript has complete control over the Wasm memory. In fact, it's just some buffer to JavaScript, and it can read and write freely. I've never, usually you control both sides of the interface, so you never really run into cases where that's an issue.",Interview P17,It's not a problem,1,,147,147,1,Author 1,8/10/23,Author 1,1/18/24
17:22,¶ 156,,"Yeah, it was [tool], which is a Django tool that runs a kernel driver and then has a library to interact with that driver and use it to communicate with PCI and USB devices.",Interview P17,Operating & Embedded Systems,1,,156,156,1,Author 1,8/10/23,Author 1,1/18/24
17:23,¶ 172,,I was scared to because it was very long. ,Interview P17,Generation VS Validation,1,,172,172,1,Author 1,8/10/23,Author 1,1/18/24
17:24,¶ 168,,"I found actually there was no issues with bindgen. It did some weird stuff for anonymous unions and structs that are in the C header, but nothing strange, nothing you couldn't change with just the bindgen options to rename those anonymous ones to something more sensible. I never had any issues with the layout of those types.",Interview P17,Generation VS Validation,1,,168,168,1,Author 1,8/10/23,Author 1,1/18/24
17:25,¶ 185,,"I've certainly seen lots of cases in libraries that I just, I'll choose not to use the library if I see something that I know that's immediately undefined behavior. Some programs still using, like some libraries still using std mem uninitialized, which should have been phased out in the 2018 edition, but it was only deprecated instead. It's just immediately undefined behavior to call that function.",Interview P17,Code Smells,1,,185,185,1,Author 1,8/10/23,Author 1,1/18/24
17:26,¶ 210,,"Well, using old idioms. Like there's some people that still want to try and use the 2015 edition of Rust. I mean, it's just a non-maintained library, so I'm not going to use it.",Interview P17,Code Smells,1,,210,210,1,Author 1,8/10/23,Author 1,1/18/24
17:27,¶ 218,,"For example, I didn't have any bugs with it, but to write this one for chess that did this transmuting to enums,",Interview P17,Transmute,1,,218,218,1,Author 1,8/10/23,Author 1,1/18/24
17:28,¶ 218,,"I've never run into bugs because of my unsafe, but even if I have bugs around my unsafe, run it through Miri or Valgrind or something, right?",Interview P17,Dynamic Analysis Safety Net,1,,218,218,1,Author 1,8/10/23,Author 1,1/18/24
17:29,¶ 218,,I verified it with Miri afterwards. I used the tooling that's available to verify stuff and write tests.,Interview P17,Running tests through Miri,1,,218,218,1,Author 1,8/10/23,Author 1,1/18/24
17:30,¶ 226,,"One of the bugs I had with this was an off-by-one thing. My maximum or minimum was off-by-one because I didn't understand how this Rust internal attribute worked, whether it was off-by-one. It's a classic one.",Interview P17,"Off-by-one, Requirements Bug",2,"For Author 1: shouldn't this be ""Integer Bounds & Overflow Bugs""?",226,226,1,Author 1,8/10/23,Author 1,1/18/24
17:31,¶ 234,,"I've never, I don't think I've built anything that would really need the tree borrows and stacked borrows.",Interview P17,It's not a problem,1,,234,234,1,Author 1,8/10/23,Author 1,1/18/24
17:32,¶ 242,,"Hypothetically, if it was there, it would be useful, but I don't think... I tended not to not do too many pointer manipulations that would pointer to reference, reference to pointer, and that's the kind of thing where Miri would come in handy there, I guess.",Interview P17,It's not a problem,1,,242,242,1,Author 1,8/10/23,Author 1,1/18/24
17:33,¶ 264,,"Most of the unsafe I use, it's very often that I leave an exposed unsafe function that... I don't know, it's very infrequent that I leave invariants just up to like a consumer to worry about.",Interview P17,Exposing a Safe API,1,,264,264,1,Author 1,8/10/23,Author 1,1/18/24
17:34,¶ 276,,The pointer that you pass in is a slice of some type that I've made up that has 512-byte alignment.,Interview P17,Contract or Invariant,1,,276,276,1,Author 1,8/10/23,Author 1,1/18/24
17:35,¶ 284,,"Well, Clippy's helped me catch unnecessary clones. There's just some patterns that are probably bad that Clippy catches and warns you about. Can't think of any off the top of my head. I've had it complained to me before.",Interview P17,Clippy for Clean Code,1,,284,284,1,Author 1,8/10/23,Author 1,1/18/24
17:36,¶ 288,,"Yeah, honestly, the Rust, the ecosystem around Rust tooling is just so fantastic. It's one of the reasons I love it. And if there's something missing, I'd just make it.",Interview P17,Rust Has Great Tooling,1,,288,288,1,Author 1,8/10/23,Author 1,1/18/24
17:37,¶ 292,,"Wasm-bindgen is pretty great, but doesn't yet cover all use cases. Part of the reason for that is the specs for the web stuff aren't ready. The Wasm code that you write can't access the memory of the JavaScript VM. It can only be the other way around. So you need to, if you want to read some JavaScript memory, you need to have JavaScript tell you that it has a pointer ready for you. Rust has to return a pointer to its own memory that JavaScript can then write to you and then call back into Rust. And then Rust can finally read it. Wasm bindgen handles all that pretty smoothly, but there's some limitations.",Interview P17,"Different FFI Memory Model, Limitation of Binding Tool, wasm-bindgen",3,,292,292,1,Author 1,8/10/23,Author 1,1/18/24
17:38,¶ 300,,But it probably needs to be some restructuring and create renaming. I'd love to see create namespaces. And protections against name squatting and stuff like that.,Interview P17,Wants Solution,1,,300,300,1,Author 1,8/10/23,Author 1,1/18/24
17:39,¶ 15,,"OK, so I know the discriminant of my square enum, which is like sixty four variants is zero to sixty three. And I know the discriminant of my rank and file are zero to seven each. So I shift one of them over three bits and add them together and use a transmute to get my square enum.",Interview P17,Transmute,1,,15,15,1,Author 1,9/5/23,Author 1,1/18/24
17:40,¶ 39,,"The same thing for pieces, pieces made of color and a kind combine them into a single piece type. You could store them in a struct with like two fields, piece and color. But this one's more for space efficiency. Why store them in two bytes when you can store them in one?",Interview P17,Increase Performance,1,,39,39,1,Author 1,9/5/23,Author 1,1/18/24
17:41,¶ 47,,and then jump into some Rust code that communicates with the BIOS disk drivers to read the next stage and then jump to that.,Interview P17,Interacting with hardware,1,,47,47,1,Author 1,9/5/23,Author 1,1/18/24
17:42,¶ 55,,And then make some safe abstractions around that. ,Interview P17,Exposing a Safe API,1,,55,55,1,Author 1,9/5/23,Author 1,1/18/24
17:43,¶ 67,,"Yeah, certainly, like reading from the disk, you pass it a pointer to a structure that then that structure has whatever so, like, and even modifies that structure and then you're expected to read through like the result written there",Interview P17,Return Pointers,1,,67,67,1,Author 1,9/5/23,Author 1,1/18/24
17:44,¶ 74,,"And, yeah, and that doesn't make it very hard to optimize the code but yeah. There's some great resources out there for the documents, a bunch of different behaviors for BIOS calls. I was using those during the time.",Interview P17,Engaging with the Rust Community,1,,74,74,1,Author 1,9/5/23,Author 1,1/18/24
17:45,¶ 180,,"So, for example, setting up. Oh, geez. Probably more about x86 program than it is about Rust, but setting up the global, setting up memory protections using a global descriptor table, GDT, has to have a certain layout, certain bit flags in places. That's one that I struggled with for probably a week. And all around unsafe Rust. So, it wasn't so much an issue with Rust, but just my understanding of x86.",Interview P17,"Logical Error, Requirements Bug",2,,180,180,1,Author 1,9/5/23,Author 1,1/18/24
17:46,¶ 180,,I don't think I've broken enough rules with unsafe Rust to get an error because I've broken the rules.,Interview P17,It's not a problem,1,,180,180,1,Author 1,9/5/23,Author 1,1/18/24
17:47,¶ 226,,"There's an RFC for this, and it's not yet ready for comments or anything. If using a nightly compiler, you can use some flags in Rust to... I think they're called like Rust-C layout minimum or maximum, and you can set the minimum and maximum types, and this just gets passed down to LLVM. ",Interview P17,Shifting Ground,1,,226,226,1,Author 1,9/5/23,Author 1,1/18/24
17:48,¶ 230,,"Using Miri helped me find what the issue was there because Miri verifies those types when you assign something to them. It verifies their bounds. So then it was able to tell me, oh, the reason why your compiler is making bad assumptions is because you constructed an invalid value here. You told me it was between this and this and it was actually one over.",Interview P17,Miri found a bug,1,,230,230,1,Author 1,9/5/23,Author 1,1/18/24
17:49,¶ 250,,"Yeah, because I'm going to be the next one to read it, and I won't forget it.",Interview P17,Audience-Dependent Documentation,1,,250,250,1,Author 1,9/5/23,Author 1,1/18/24
17:50,¶ 254,,"See, usually I also come up with a safe interface around it, so it's hard to break the invariants, I guess. ",Interview P17,"""Safe"" API",1,,254,254,1,Author 1,9/5/23,Author 1,1/18/24
17:51,¶ 260,,"But I think in that case, so there's some alignment guarantees that need to be upheld there, but I think I was able to express that in the type system.
",Interview P17,"Contract or Invariant, Exposing a Safe API",2,,260,260,1,Author 1,9/5/23,Author 1,1/18/24
18:1,¶ 3,,"Early work was in like binary exploitation stuff. I feel like that gives you a very good appreciation for the importance of memory safety. So I think very early on, like that promise alone made me interested in looking at Rust.",Interview P18,Memory Safety,1,,3,3,1,Author 1,8/10/23,Author 1,1/19/24
18:2,¶ 3,,"And a friend of mine had a project that seemed like a particularly good fit, which is a game that he's been running for a really long time. It's an ancient C, C++ code base. And so it was kind of a neat opportunity to slot Rust in, make it a nice three binary or three language binary and go from there. So I really started playing with it for that purpose and then kind of spent a couple of years working on that with him in addition to some other projects.",Interview P18,Game Development,1,,3,3,1,Author 1,8/10/23,Author 1,1/19/24
18:3,¶ 7,,"Just kind of my own personal tooling. I use some Rust tooling just to manage databases of personal information, bookmarks, a little link shortener. Just kind of toy web backend services that I can use for my stuff just to keep the muscles strong.",Interview P18,Web Application Development,1,,7,7,1,Author 1,8/10/23,Author 1,1/19/24
18:4,¶ 15,,"Big on CLI, but served over HTTP. And then just a couple maybe static pages being generated. I store all my images in B2, it's like an S3 compatible object storage. I just have a hundred line Rust program that loops through and renders a template and small static site gen type stuff.",Interview P18,Personal Tools & Toy Projects,1,,15,15,1,Author 1,8/10/23,Author 1,1/19/24
18:5,¶ 19,,"So the game is a MUD, I don't know if you're familiar with these. So MUD is multi-user dungeon. They're old telnet text-based MMORPGs effectively. If you've played World of Warcraft or something, you can really think of it as having all the same mechanics. You're walking around in the world, you've got gear, you're fighting mobs, you've got quests with a bunch of stuff to go on, different regions you can travel to. Really just think World of Warcraft mechanics, but text-based and scaled down. But so single server where a bunch of people are all online and interacting, persistent online game world.",Interview P18,Game Development,1,,19,19,1,Author 1,8/10/23,Author 1,1/19/24
18:6,¶ 19,,"They're starting to have some performance issues, which was a little bit confusing for them because this game has been going for over 20 years and hardware has gotten much, much faster and they've still managed to end up having performance problems. So I think we set out with the goal of fixing a few performance problems and getting a bunch of the core data and data structures into a more usable format.",Interview P18,"Rust is ergonomic, Rust Performs Well",2,,19,19,1,Author 1,8/10/23,Author 1,1/19/24
18:7,¶ 19,,"So I think the first big thing that we did in Rust was basically move the definitions of all the core games data structures from the C headers into Rust headers. There's very little C++, so we can kind of ignore the C++ aspect, but moved those, did bindgen first, moved those from C headers into Rust headers, wrapped them all with some procedural macros and basically kept the ABI level stability. ",Interview P18,"bindgen, Macros",2,,19,19,1,Author 1,8/10/23,Author 1,1/19/24
18:8,¶ 23,,"And so the tricky part of this whole thing has been coordinated like when Rust code is running, like when is it safe to get a reference to this thing based on the rest of the code base that's in C knowing that it could be doing anything at any time.",Interview P18,Difficult FFI,1,,23,23,1,Author 1,8/10/23,Author 1,1/19/24
18:9,¶ 31,,"As far as I can tell, I have not had like aliasing based undefined behavior. But like I fully believe that there exists some somewhere in this code base and it's been impossible to, well, like luckily I haven't had any kind of heisenbugs that point to the kind of pointer aliasing or anything like that. But it's huge, like it's, you know, there's 30 plus gigs of content in memory. So it's like, and mostly small objects and strings, like there's tons of stuff I did to pull that down, like the string interner and stuff. So like there's just a lot of stuff there. And if we break the aliasing guarantees and like, you know, had a torn write or something, it would probably take me quite a while to find it if it did happen.",Interview P18,Unsafe is Difficult to Understand,1,,31,31,1,Author 1,8/10/23,Author 1,1/19/24
18:10,¶ 39,,I've got like one microcontroller that has some unsafe Rust in it.,Interview P18,Operating & Embedded Systems,1,,39,39,1,Author 1,8/10/23,Author 1,1/19/24
18:11,¶ 39,,"I think there's maybe one pattern that I commonly use unsafe for or previously did before OnceCell was stabilized. Now that OnceCell is stabilized, I feel less inclined to use that pattern all over the place.",Interview P18,Preference for Safety,1,,39,39,1,Author 1,8/10/23,Author 1,1/19/24
18:12,¶ 39,,"And so like occasionally I do the thing where you just like put the static and leak it and unsafe it into a static mute and then access it the rest of the time. But you know, it's like on one hand the canonical example of unsafe in the book, it's like here's an example of when you need to use unsafe and like it shows exactly that. So like I have high confidence that that pattern is right",Interview P18,"Engaging with the Rust Community, Tacit Knowledge",2,,39,39,1,Author 1,8/10/23,Author 1,1/19/24
18:13,¶ 39,,"So like I have high confidence that that pattern is right, but like it feels weird to use unsafe because it's like we do have OnceCell and like unless you can prove that you're wrecking performance with it, you probably shouldn't.",Interview P18,Preference for Safety,1,,39,39,1,Author 1,8/10/23,Author 1,1/19/24
18:14,¶ 39,,"I'm going to initialize something one time at program startup, leak it and put it into like static memory and just like you can assume for the rest of the lifetime of the program that it's going to be there without actually doing a check, which that extra check you can't dodge with like lazy static or whatever else. They're always doing the check to see like, have I initialized this to be safe? And so like occasionally I do the thing where you just like put the static and leak it and unsafe it into a static mute and then access it the rest of the time.",Interview P18,"Increase Performance, Static Variables",2,,39,39,1,Author 1,8/10/23,Author 1,1/19/24
18:15,¶ 43,,"I mean, for my personal stuff, it's like there's very little risk. So I'm kind of fine leaving it. ",Interview P18,Audience-specific Reasoning,1,,43,43,1,Author 1,8/10/23,Author 1,1/19/24
18:16,¶ 47,,"So really for each of these types, there's kind of a layer that is meant to hide the unsafe from everyone else because I think, you know, this game, the team working on it is full of not programmers. It's mostly folks who were interested in the game 15 years ago and have kind of been involved. So a lot of the C is kind of copy pasted and cargo colted. There's not really, there's no sense of like programming fundamentals there. So like, I didn't want anyone else to ever have to touch unsafe Rust.",Interview P18,Exposing a Safe API,1,,47,47,1,Author 1,8/10/23,Author 1,1/19/24
18:17,¶ 47,,"And so on the Rust side, like there's kind of a layer that exposes standard guard objects. Like you get from a Mutex or RwLock that contains all of the logic to protect those accesses versus the rest of the C code kind of thing.",Interview P18,"Exposing a Safe API, Mutex<T>, RwLock<T>",3,,47,47,1,Author 1,8/10/23,Author 1,1/19/24
18:18,¶ 51,,"I actually just keep a set of the addresses that are valid and have been allocated and associate those with like the type of the object. And so internally the, the kind of methods that get you a guard object are able to check, like, is this pointer actually valid? By saying like, is it one that we allocated and do the types match? ",Interview P18,Unsafe Data Structure,1,,51,51,1,Author 1,8/10/23,Author 1,1/19/24
18:19,¶ 51,,"So you can't alias. And if that lock is not held, then we kind of fall back to like RwLocks or Mutexes that, that allow you granular locking to the objects on the Rust side. So that the Rust stuff can actually do multi-threaded parallel stuff by like doing granular locking and the C can just not worry about locking at every individual object, it just locks the global thing and blocks all the Rust for that time. ",Interview P18,"Different FFI Memory Model, Fearless Concurrency, Mutex<T>, RwLock<T>",4,,51,51,1,Author 1,8/10/23,Author 1,1/19/24
18:20,¶ 51,,"Unless you're kind of in the stack of the C main program, in which case you're allowed to kind of do whatever, I just expose a guard with UnsafeCells so that you're allowed to alias.",Interview P18,UnsafeCell<T>,1,,51,51,1,Author 1,8/10/23,Author 1,1/19/24
18:21,¶ 51,,"So when the main C engine's code is running, it obtains like a global lock. And that's like the hint that like the C could be holding any of the pointers and doing stuff right now. So you can't alias. And if that lock is not held, then we kind of fall back to like RwLocks or Mutexes that, that allow you granular locking to the objects on the Rust side. ",Interview P18,Different FFI Memory Model,1,,51,51,1,Author 1,8/10/23,Author 1,1/19/24
18:22,¶ 59,,"That flipped relatively recently. I think main is now in Rust where it was previously in C. I think I moved the main in Rust because we have like there's a tokio runtime doing some stuff in there like the game now connects to Discord and so like the in-game chat is mirrored to Discord and so like we've got a tokio runtime on the side with some channels that we use to like throw stuff back and forth. So I just moved, like I took the C main, oh well also like I redid the config system so like put the config in Rust instead of whatever was the nasty C like parsing of get up stuff",Interview P18,Rewrite it in Rust,1,,59,59,1,Author 1,8/10/23,Author 1,1/19/24
18:23,¶ 67,,Yeah I think Box is really just like at kind of the core of the allocator for all of these game objects like none of them ever live on the stack. They're all kind of heap allocated game objects so mostly those are actually just like Box new and immediately leak because we're just going to keep the raw pointers around and we just keep raw pointers as well as the like locks or whatever on top of them. So really the allocator is basically Box new and leak and the the deallocation is just you know Box from and let the normal drop implementation handle it.,Interview P18,"Allocation in Rust, Box<T>",2,,67,67,1,Author 1,8/10/23,Author 1,1/19/24
18:24,¶ 71,,when we allocate I basically I do the nasty thing and I cast the pointer to an integer and store it in a set of integers that represent the pointers that are allocated for that type and so on deallocate you just you know cast the pointer back make sure that it's still in that set and then you can you know know that you can safely do the Box from for for deallocating kind of thing you clean up from that set at that time.,Interview P18,"Box<T>, Pointer Arithmetic",2,,71,71,1,Author 1,8/10/23,Author 1,1/19/24
18:25,¶ 75,,I throw an error message it's like I don't know how you did this but you did or like if you call free and the pointer is not in any of the sets I can just tell you this was a double free most likely and like you've got a problem somewhere in the C code that is causing this double free and so like as soon as I implemented that it took like I don't know two months or something of a bunch of folks playing whack-a-mole like actually just going through the C codebase and finding all of the weird places where they were like keeping dangling pointers around and stuff so like it we certainly found a lot of issues like right away,Interview P18,"Double Free, Temporal Memory Bug",2,,75,75,1,Author 1,8/10/23,Author 1,1/19/24
18:26,¶ 75,,I guess well so I provide basically some slightly nicer error messages that are basically like if if that if I get a pointer to free and it doesn't pass the normal checks which is like it needs to be in this hash map I'll check the hash maps for the other types and say like you've you've screwed up on the C side somewhere ,Interview P18,Runtime Assertion,1,,75,75,1,Author 1,8/10/23,Author 1,1/19/24
18:27,¶ 79,,"No, they're all kind of, all of the types are fixed in size, so there's never any sort of reallocation and they're all Boxed and Pinned so they never move on the heap. So we kind of, I just assume that the pointers are stable everywhere.",Interview P18,"Box<T>, Contract or Invariant, Pin<T>",3,,79,79,1,Author 1,8/10/23,Author 1,1/19/24
18:28,¶ 83,,"So up, if you walk up the stack somewhere, you're gonna find a C frame that represents the game and it's holding that lock, but you need a reference to something in Rust. That's where like, we kind of assume that, well, the C side may be holding a pointer to it too, so like you may be aliasing somewhere on the C side, but we just know that we do have this global lock and the C code is the only thing there. The C code itself is not threaded. And so like we use UnsafeCell to just give you a temporary like unsafe reference to those objects",Interview P18,UnsafeCell<T>,1,,83,83,1,Author 1,8/10/23,Author 1,1/19/24
18:29,¶ 87,,"I think I had a conversation with someone there's an unofficial Rust community discord that's pretty popular. There's a channel in there called Dark Arts that lots of folks kind of sit around and talk about like the minutia of safety and soundness. And I think a conversation there really helped me understand that like you need that UnsafeCell in order to basically tell the compiler like, you must assume that this pointer can alias.",Interview P18,Engaging with the Rust Community,1,,87,87,1,Author 1,8/10/23,Author 1,1/19/24
18:30,¶ 91,,"So Rc/Arc I use for kind of the very granular locking on the, for like the pure Rust side. So like if you don't have that global lock from the C side, you're in Rust. That means you could be doing multi-threaded stuff and everything. And so we basically keep a per object Arc, RWLock that lets you either get, that lets you get access to those things in a safe way.",Interview P18,"Arc<T>/Rc<T>, RwLock<T>",2,,91,91,1,Author 1,8/10/23,Author 1,1/19/24
18:31,¶ 91,,"Actually, I cheat a little bit in the allocation. I allocate the space for the arc just in front of the object itself so that I don't have to do any sort of lookup. Like I take the pointer, I allocate arc and then allocate those things next to each other in memory. And so like the pointer that we get from C is always the start of the C object itself, but actually it's the interior of a struct that has the Rc/Arc in front. So I can just subtract off the pointer and grab the arc once I've made sure that the pointer is valid kind of thing.",Interview P18,"Easier or More Ergonomic, Pointer Arithmetic",2,,91,91,1,Author 1,8/10/23,Author 1,1/19/24
18:32,¶ 103,,"Oh no, my gut says that there's a better way to do that. It was one of the very earliest things I wrote. So like, there's probably a better way that I just don't know about yet or didn't know about at the time and I haven't thought about it.",Interview P18,No Other Choice,1,"For Author 1: similar to the one about using unsafe while learning Rust because you don't know about Cell or RefCell, this doesn't feel like ""No Other Choice""; maybe ""Easier or More Ergonomic""? I suggested ""For Fun"" for that other one, but that doesn't feel right here.",103,103,1,Author 1,8/10/23,Author 1,1/19/24
18:33,¶ 111,,"It feels like given like having hundreds of thousands of lines of C that you can't reasonably audit, like it feels like keeping that runtime information around somewhere is the only way to like even start to think about this thing being sound.",Interview P18,C++ is Difficult,1,,111,111,1,Author 1,8/10/23,Author 1,1/19/24
18:34,¶ 103,,"So like, there's a, you know, for the admins of the game, they've got basically a way to peek and poke at objects through the game itself. And so like, you should be able to do like edit character number and like get a table of all the fields and like a printed version of what they are and say like, I wanna edit this character's name or whatever and do that stuff. And like, there's basically a hacky like V table of the like, these are the field names and their types and their offsets from the struct so that we can kind of generically have the parsing for all the types and just say like, you're writing to the spot kind of thing.",Interview P18,"Pointer Arithmetic, Unsafe Data Structure",2,,103,103,1,Author 1,8/10/23,Author 1,1/19/24
18:35,¶ 115,,"I guess I feel reasonably confident that in isolation, the abstractions are mostly sound. I'm not at all confident that they're actually sound in practice with how they're used because the C code base is so freaking large that like it's doing something weird somewhere that probably breaks my guarantees.",Interview P18,"""Safe"" API, Difficult FFI",2,,115,115,1,Author 1,8/10/23,Author 1,1/19/24
18:36,¶ 127,,"if I remember correctly, actually it may have been finding an issue with Miri and then going back to the Dark Arts channel and saying why the hell is this not working that led me to realizing I needed that extra little UnsafeCell versus just kind of grabbing references from the raw pointers just to prove the aliasing was okay.",Interview P18,"Borrowing or Provenance Bug, Miri found a bug, Stacked/Tree Borrows Violation, UnsafeCell<T>",4,,127,127,1,Author 1,8/10/23,Author 1,1/19/24
18:37,¶ 131,,"So what I ended up doing, I kind of spent a bunch of time very early actually refactoring some of the headers and just pulling just functions and just a subset of the data types that I wanted to touch in Rust into like a separate set of shared headers and running bindgen on just those. And like sharing those headers with the Rust and C-side.",Interview P18,"bindgen, Generate Bindings From a Subset",2,,131,131,1,Author 1,8/10/23,Author 1,1/19/24
18:38,¶ 131,,"I used bindgen to expose all the Rust stuff back to the C-side or sorry, cbindgen rather. To expose that way. And cbindgen almost entirely works. I had two big problems and complaints with it. One is that it requires nightly and we were otherwise able to be on stable. And so it like caused a bunch of tooling thrash to have to hit nightly there. And the other issue is actually that cbindgen doesn't seem to be capable of handling like a loop of dependent structure definitions.",Interview P18,"cbindgen, Limitation of Binding Tool",2,,131,131,1,Author 1,8/10/23,Author 1,1/19/24
18:39,¶ 131,," I used a lot of, or tried to use bindgen very early to just start exposing like bits of the C engine to Rust. And, you know, bindgen seems to work great if you've got really, really simple headers doing no sort of weird macro trickery and just like very common stuff. And that's to say, it didn't work at all in this code base, really.",Interview P18,"bindgen, Limitation of Binding Tool",2,,131,131,1,Author 1,8/10/23,Author 1,1/19/24
18:40,¶ 135 – 136,,"So like a character may be inside a faction and a faction has memberships and a membership points to the character that is the member. And so like technically those structure definitions from like a C-Sense all depend on one another because it says I've got a pointer to this other type in it. But they're not quite like the circular references as you might think of in Rust.

",Interview P18,Multiple / cyclic aliasing,1,,135,136,2,Author 1,8/10/23,Author 1,1/19/24
18:41,¶ 139,,"No, that's been for my own playing around and edification.",Interview P18,For Fun,1,,139,139,1,Author 1,8/10/23,Author 1,1/19/24
18:42,¶ 139 – 140,," I kind of hate Python just by virtue of having spent too much time writing it in the last 10 years probably. But the ecosystem there has just been like so many of the core libraries have been being rewritten in Rust that I've been keeping up quite a lot. So like pydantic is now Rust under the scene, pullers is the data frame library we've started to use all over the place has Rust under the covers. Like there's enough packages that are like Rust with Python packages are now just Rust underneath with that light barrier that it's been useful to keep on top of it.

",Interview P18,Rewrite it in Rust,1,,139,140,2,Author 1,8/10/23,Author 1,3/18/24
18:43,¶ 143,,"And so like that's kind of, I guess the bifurcation is really that like, there's a bunch of stuff that's like C in memory representation compatible and all of that stuff you can kind of access from either C or from Rust. And then there's a bunch of stuff that's only Rust compatible. And the only way to actually access or do anything with it is to just like call across the FFI boundary to Rust and deal with it. And so like that causes a little bit of confusion for some of the newer folks, because they don't realize at first that actually like this character struct has like this Rust extension struct packed onto the end of it. And they just look and see the C version and look at all the fields available and they're like, I don't see this field that I thought was here. And it's like, well, you can't hit it from C, you kind of have to go to the other language if you want to touch that data kind of thing.",Interview P18,Different FFI Memory Model,1,,143,143,1,Author 1,8/10/23,Author 1,3/18/24
18:44,¶ 147,," And that caused kind of interesting, difficult to track down crashes because you crash in Rust and then it unwinds and you've got the like FFI boundary stuff. So like those crashes, and I think in the very early days, I didn't realize actually that you had to kind of prevent unwinding across the FFI boundary.",Interview P18,"FFI & Binding Bug, Unwinding Across FFI Boundaries",2,,147,147,1,Author 1,8/10/23,Author 1,3/18/24
18:45,¶ 151,,"I mean, I think being able to prove soundness across the FFI boundary would be really nice. Like I haven't tracked, but I think Miri is making progress towards doing that in the last year or so, but I haven't tracked it too much lately. But I think that would be one of the largest one is just like a version of Miri that could go across that FFI boundary. ",Interview P18,Wants Solution,1,,151,151,1,Author 1,8/10/23,Author 1,3/18/24
18:46,¶ 151,,"I also, I did try briefly at one point to like do like UBSan and ASan and like the kind of LLVM sanitizers. Like doing those in a mixed C, C++ Rust program turned out to just be too much of a pain for me to bother with. So like any sort of like tooling to make running those sanitizers in multi-language binaries a little bit easier would be amazing.",Interview P18,"Laziness Fights Tooling, Wants Solution",2,,151,151,1,Author 1,8/10/23,Author 1,3/18/24
18:47,¶ 163,," there's kind of all of these efforts going on in the ecosystem to further formalize the memory model of it so there's like the efforts of doing stacked borrows that give us a better bar checker and a more formal model and stuff there. And like, I feel, I feel reasonably confident after a lot of testing and, you know, a few mere things like I think that my code is sound under the current Rust memory model as it exists today, but my gut says that as soon as like if stacked borrows became the new memory model, like it probably blows up everything.",Interview P18,Shifting Ground,1,,163,163,1,Author 1,8/10/23,Author 1,3/18/24
18:48,¶ 167,," I think it is a challenge though. It's like, that's where sort of the, I think the most like the biggest rough edge of the Rust ecosystem is in terms of like just where all the new stuff is happening.",Interview P18,Shifting Ground,1,,167,167,1,Author 1,8/10/23,Author 1,3/18/24
18:49,¶ 23,,"But so all of these things are used and referenced all over the place in the C code base, right? So the Rust side is allocating them. ",Interview P18,Allocation in Rust,1,,23,23,1,Author 1,9/5/23,Author 1,1/19/24
18:50,¶ 27,,"It's 99% in Rust at this point. There's maybe a couple random allocs in the C code floating around somewhere, but all of the core data structures were moved to Rust and all of their allocators are based on Rust now.",Interview P18,Allocation in Rust,1,,27,27,1,Author 1,9/5/23,Author 1,1/19/24
18:51,¶ 43,,"But often if I'm touching a code base anyways and I come across stuff, I'm usually inclined to remove it. ",Interview P18,Preference for Safety,1,,43,43,1,Author 1,9/5/23,Author 1,1/19/24
18:52,¶ 115,,"But at least like a few of the kind of primitives where I could like, so for the kind of global lock piece of things, I kind of prototyped that outside the game and ran it through Miri and made sure that like it looked okay with Miri, but obviously like Miri doesn't do FFI boundaries or anything, so like it kind of, I can't actually do it in the broader scope of the full game or anything, but at least tried to like take a piece of it and prove soundness that way.",Interview P18,"Miri doesn't support this feature, Running tests through Miri, Worked Around Miri's Limitations",3,,115,115,1,Author 1,9/5/23,Author 1,1/19/24
18:53,¶ 131,,"And then started, as I started getting into like the actual core game data structures, it started falling apart, which is why we ended up like, I left the bindgen stuff there, stopped doing the core game data structures via bindgen and actually just hand rewrote all of them in Rust. And I did that for the added benefit of being able to put a proc macro around them and do a bunch of the code gen. But like, if I could have just bindgen them all and then run a RegEx and put the thing in front that way, it would have been nicer.",Interview P18,"Generation VS Validation, Macros",2,,131,131,1,Author 1,9/5/23,Author 1,1/19/24
19:1,¶ 23,,"Mostly it's for, maybe, web development or maybe, yeah, mostly web development.",Interview P19,Web Application Development,1,,23,23,1,Author 1,8/10/23,Author 1,1/19/24
19:2,¶ 11,,"So, okay, when it comes to Rust and its applicability, you know, when it comes to application, maybe in network programming or maybe web development or some kind of such you get, it's easier to to sync it with the programming languages and to synchronize. So for me, it's been a good experience. And I think I like using Rust as per say.",Interview P19,"Networking & Distributed Systems, Rust is ergonomic, Web Application Development",3,,11,11,1,Author 1,8/10/23,Author 1,1/19/24
19:3,¶ 101,,"Maybe let's say I call this supposed to perform a low level operation and in this instance, it's also supposed to run some kind of unsafe safety guarantees. So you have to write a documentation to instructs in some kind of file that the code can be handled and I think that's the right way to do it just avoid backlogs and maybe pointer dereferencing or some kind of, yeah.",Interview P19,Documented Contract or Invariant,1,,101,101,1,Author 1,8/10/23,Author 1,3/18/24
19:4,¶ 145,,"Okay. It's not a major significant performance, but I'll say there's a substantial difference.",Interview P19,Profiling,1,,145,145,1,Author 1,8/10/23,Author 1,3/18/24
19:5,¶ 201,," And sometimes it can lead to crashes or memory corruption. And multiple unpredictable program behaviors that you've had. You cannot even tell what it is or so, or maybe it's challenging to maybe to know or maybe how to locate where. It becomes a challenge. ",Interview P19,Unsafe is Difficult to Understand,1,,201,201,1,Author 1,8/10/23,Author 1,3/18/24
19:6,¶ 7,,"using Rust I think it's easy to learn and also to apply and also it's integration with the other programming languages, it's easy. And so I feel it's convenient for me to work with.",Interview P19,Rust is ergonomic,1,,7,7,1,Author 1,9/5/23,Author 1,1/19/24
19:7,¶ 61,, something that you can get results from this undefined behavior of which you're going to have challenges trying to work it through. And so I try to talk with that just because it can be difficult to identify and resolve bugs and it's an upheaval task to go through that.,Interview P19,Unsafe is Difficult to Understand,1,,61,61,1,Author 1,9/5/23,Author 1,1/19/24
19:8,¶ 77,,"I use unsafe rust just to maybe do some unsafe abstractions. And that is to use unsafe rust just to create safe abstraction. And this may be involved, maybe writing a safe API around unsafe implementation.",Interview P19,Exposing a Safe API,1,,77,77,1,Author 1,9/5/23,Author 1,1/19/24
19:9,¶ 89 – 90,,"And these safety guarantees when it comes to Rust, I think they are much useful when you're creating with multiple APIs and they have some kind of synchronization behavior in these calls for security and also have maybe less bugs or less challenges trying to implement and I think those have got a way to let others more applicable with Rust.

",Interview P19,"Fearless Concurrency, Memory Safety",2,,89,90,2,Author 1,9/5/23,Author 1,3/18/24
19:10,¶ 189,,"I can maybe call an instance where I had to maybe edit it or do some kind of improvements. I think they just work for me to maybe, once I know that I need these binding tools. And then I can find myself, maybe trying to review the code or maybe trying to, how to edit or maybe, you know, no, no, it's a real case. I can't recall that.",Interview P19,Generation VS Validation,1,,189,189,1,Author 1,9/5/23,Author 1,3/18/24